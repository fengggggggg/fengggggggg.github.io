{"meta":{"title":"Simita","subtitle":null,"description":null,"author":"V17","url":"http://fengggggggg.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-06-28T15:17:49.173Z","updated":"2019-06-28T15:17:49.173Z","comments":true,"path":"404.html","permalink":"http://fengggggggg.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"ALL CATEGORIES","date":"2019-06-28T15:35:37.852Z","updated":"2019-06-28T15:35:37.852Z","comments":true,"path":"categories/index.html","permalink":"http://fengggggggg.github.io/categories/index.html","excerpt":"","text":""},{"title":"ALL TAGS","date":"2019-06-28T15:35:48.311Z","updated":"2019-06-28T15:35:48.311Z","comments":true,"path":"tags/index.html","permalink":"http://fengggggggg.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-28T15:23:09.839Z","updated":"2019-06-28T15:23:09.839Z","comments":true,"path":"mylist/index.html","permalink":"http://fengggggggg.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"C++中结构体和类的区别","slug":"computer_science/C&C++/different_between_struct_and_class","date":"2019-08-09T16:00:00.000Z","updated":"2019-08-09T16:00:00.000Z","comments":true,"path":"2019/08/10/computer_science/C&C++/different_between_struct_and_class/","link":"","permalink":"http://fengggggggg.github.io/2019/08/10/computer_science/C&C++/different_between_struct_and_class/","excerpt":"C++中结构体和类的区别","text":"C++中结构体和类的区别 1. C和C++中struct的不同 C中的结构体只能定义成员变量，不能定义成员函数，C++可以； C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性； C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1; C++中之所以要引入结构体，是为了保持和C程序的兼容性。C++中不使用结构体丝毫不会影响程序的表达能力，但有时仍会在C++中使用结构体，这是因为使用结构体将不同类型数据组成整体便于保存数据。（若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦。） 2. C++中struct和class的不同C++中struct和class唯一的不同是struct和class具有不同的默认访问控制属性，class中的成员的默认控制访问属性为private，而struct中的默认访问控制属性为public。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"常见排序算法总结与比较","slug":"computer_science/Algorithm/sort","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-07T16:00:00.000Z","comments":true,"path":"2019/08/08/computer_science/Algorithm/sort/","link":"","permalink":"http://fengggggggg.github.io/2019/08/08/computer_science/Algorithm/sort/","excerpt":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。","text":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。 1. 总体比较时间复杂度与稳定性 类别 名称 平均复杂度 最好情况 最差情况 空间复杂度 稳定性 交换比较类 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 交换比较类 快速排序 $O(nlogn)$ $O(n^2)$ $O(n^2)$ $O(logn)$ 不稳定 选择类 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 选择类 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 插入类 直接插入 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 插入类 二分排序 $O(n^2)$ $O(nlogn)$ $O(n^2)$ – 稳定 插入类 希尔排序 $O(nlogn)$ $O(n)$ $O(n^s)1$ $O(1)$ 不稳定 其他 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 其他 基数排序 $O(log_R B)$ – $O(log_R B)$ $O(n)$ 稳定 其他 二叉排序 $O(nlogn)$ – $O(nlogn)$ $O(n)$ 稳定 其他 计数排序 $O(n+k)$ – $O(n+k)$ $O(k)$ 稳定 其他 拓扑排序 $O(n+e)$ – – $O(n)$ – 其他 枚举排序 $O(n^2)$ – – – – 算法特性 名称 时间复杂度与初序 移动次数与初序 比较次数与初序 排序趟数与初序 每趟确定最终位置 冒泡排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 快速排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 选择排序 ❌ ❌ ❌ ❌ - 堆排序 ❌ ❌ ❌ - ⭕️ 直接插入 ⭕️ ⭕️ ⭕️ ❌ ❌ 二分排序 - - ❌ - - 希尔排序 ⭕️ - ⭕️ - ❌ 归并排序 ❌ ❌ ⭕️ - - 基数排序 ❌ ❌ ❌ - - 二叉排序 ⭕️ - - - - 计数排序 ⭕️ - - - - 拓扑排序 - - - - - 枚举排序 - - - - - 2. 冒泡排序冒泡排序是一种典型的交换排序算法，相邻两数两两⽐比较并交换，直到所有数据排序完成，每一趟排序总能够将无序队列中的最⼤/小置于队尾。适用情况: 待排序列列较小时性能较优。最坏情况: 初始序列基本有序但顺序相反最好情况: 初始序列列基本有序(没有插⼊快，因为要两两比较)应用: 对基本有序序列查前n个元素 12345678void BubbleSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) for (int j = 0; j &lt; array.size() - i; j++) if (array[j] &gt; array[j + 1]) swap(array[j + 1], array[j]);&#125; 3. 选择排序反复选择未排序序列中最大或最小元素，并将其放于已排序序列尾部，直到未排序序列长度为0 1234567891011void SelectSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) &#123; int minIndex = i; for (int j = i; j &lt; array.size(); j++) if (array[j] &lt; array[minIndex]) minIndex = j; swap(array[i], array[minIndex]); &#125;&#125; 4. 直接插入排序将数据分为有序和无序两部分，首先有序部分为空，依次从无序部分中拿出元素插入到有序序列中可能出现情况: 最后一趟开始前，所有元素都不在正确位置上最佳情况: 基本有序下，插⼊排序是最快的 123456789101112void InsertionSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 1; i &lt; array.size(); i++) &#123; int temp = array[i], j = i; while (j &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = temp; &#125;&#125; 5. 归并排序n越⼤大越好优点: 当待排序列列较大，内存一次性放不不下时，需要外部排序，通常使用归并排序归并趟数: m个元素k路归并趟数$s = log_k m$ 12345678910111213141516171819202122232425262728293031void MergeSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return MergeSort(array, left, right);&#125;void Merge(vector&lt;int&gt;&amp; array, int l1, int r1, int l2, int r2) &#123; int i = l1, j = l2; vector&lt;int&gt; temp(array.size()); int index = 0; while (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123; if (array[i] &lt;= array[j]) temp[index++] = array[i++]; else temp[index++] = array[j++]; &#125; while (i &lt;= r1) temp[index++] = array[i++]; while (j &lt;= r2) temp[index++] = array[j++]; for (int i = 0; i &lt; index; i++) array[l1 + i] = temp[i];&#125;void MergeSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; MergeSort(array, left, mid); MergeSort(array, mid + 1, right); Merge(array, left, mid, mid + 1, right); &#125;&#125; 6. 快速排序分治法优点: 平均最快，平均比较次数最少最好情况: 每次能够均匀划分最坏情况: 序列有序，或不均匀划分优化: 快排需要使用递归，因此处理左右子段时，先处理短子段可以减少时间复杂度。先处理短⼦段的话，每次递归深度都是短⼦段的长度对排序对象的要求: 待排序列的存储方式是顺序存储 1234567891011121314151617181920212223242526void QuickSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return QuickSort(array, left, right);&#125;int Partition(vector&lt;int&gt;&amp; array, int left, int right) &#123; int temp = array[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[right] &gt; temp) right--; array[left] = array[right]; while (left &lt; right &amp;&amp; array[left] &lt; temp) left++; array[right] = array[left]; &#125; array[left] = temp; return left;&#125;void QuickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int pos = Partition(array, left, right); QuickSort(array, left, pos - 1); QuickSort(array, pos + 1, right); &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://fengggggggg.github.io/tags/Sort/"}]},{"title":"LeetCode 探索初级算法 字符串","slug":"computer_science/LeetCode/Primary_Algorithm_String","date":"2019-08-06T16:00:00.000Z","updated":"2019-08-06T16:00:00.000Z","comments":true,"path":"2019/08/07/computer_science/LeetCode/Primary_Algorithm_String/","link":"","permalink":"http://fengggggggg.github.io/2019/08/07/computer_science/LeetCode/Primary_Algorithm_String/","excerpt":"反转字符串 整数反转 字符串中的第一个唯一字符 有效的字母异位词 验证回文字符串 字符串转换整数(atoi) 实现strStr() 报数 最长公共前缀","text":"反转字符串 整数反转 字符串中的第一个唯一字符 有效的字母异位词 验证回文字符串 字符串转换整数(atoi) 实现strStr() 报数 最长公共前缀 1. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。 示例 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 解法1：双指针法设置双指针i、j分别指向头尾，交换头尾后各向中间进1. 1234567891011class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; swap(s[i], s[j]); i++; j--; &#125; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 解法2：reverse函数直接使用reverse()函数 123456class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; reverse(s.begin(), s.end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 2. 整数反转给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 12输入: 123输出: 321 解法：模拟栈每次对x取%10余，并将余数×10累加到res中 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; int res = 0, cur; while (x != 0) &#123; cur = x % 10; x /= 10; if (res &gt; INT_MAX/10 || (res == INT_MAX / 10 &amp;&amp; cur &gt; 7)) return 0; if (res &lt; INT_MIN/10 || (res == INT_MIN / 10 &amp;&amp; cur &lt; -8)) return 0; res = res * 10 + cur; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：$O(log(x))$ 空间复杂度：$O(1)$ 3. 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1 示例 12345s = &quot;leetcode&quot;返回0.s = &quot;loveleetcode&quot;,返回2. 解法：hash表使用map保存字符-位置键对，且这一键对的值为该字符出现的次数。随后从头按字符出现的次序遍历map，第一个键值为1的便是解。 123456789101112131415161718class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char,int&gt; hash; for (auto i : s) &#123; hash[i]++; &#125; for (int i = 0; i &lt; s.size(); ++i) if (hash[s[i]] == 1) return i; return -1; &#125;&#125;;**复杂度分析**- 时间复杂度：$O(n)$- 空间复杂度：$O(n)$ 4. 有效的字母异位词给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。 示例1 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例2 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 示例3 12输入: s = &quot;aacc&quot;, t = &quot;ccac&quot;输出: false 解法：hash表使用26大小的数组作为hash表，同时遍历s和t，并在对应位分别++和–。最后再遍历一遍hash表，如果存在不为0的元素，则说明s和t字符不对应，即不是异位词 12345678910111213141516class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.size() != t.size()) return false; int count[26] = &#123;0&#125;; for (int i = 0; i &lt; s.size(); ++i) &#123; count[s[i] - 'a']++; count[t[i] - 'a']--; &#125; for (auto i : count) if (i != 0) return false; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 5. 验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写 示例1 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例2 12输入: &quot;race a car&quot;输出: false 解法：双指针法利用双指针分别从头和尾进行比较，两个关键函数：isalnum()判断是否为字母数字，以及tolower()转换成小写字母 123456789101112131415class Solution &#123;public: bool isPalindrome(string s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; !isalnum(s[i])) i++; while (i &lt; j &amp;&amp; !isalnum(s[j])) j--; if (tolower(s[i++]) != tolower(s[j--])) return false; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 6. 字符串转换整数(atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。 解法这题实在是太麻烦了，各种意想不到的输入都需要考虑到，因此这里提供一个懒人方法，使用sstream库。 123456789class Solution &#123;public: int myAtoi(string str) &#123; int digit = 0; istringstream is(str); is &gt;&gt; digit; return digit; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"LeetCode","slug":"Computer-Science/LeetCode","permalink":"http://fengggggggg.github.io/categories/Computer-Science/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://fengggggggg.github.io/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://fengggggggg.github.io/tags/String/"}]},{"title":"LeetCode 探索初级算法 数组","slug":"computer_science/LeetCode/Primary_Algorithm_Array","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-05T16:00:00.000Z","comments":true,"path":"2019/08/03/computer_science/LeetCode/Primary_Algorithm_Array/","link":"","permalink":"http://fengggggggg.github.io/2019/08/03/computer_science/LeetCode/Primary_Algorithm_Array/","excerpt":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像","text":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像 1. 旋转数组给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数 示例1 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例2 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 解法1：暴力解法旋转k次，每次将数组向右旋转移动一位 1234567891011void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int pre, tmp; for (int i = 0; i &lt; k; ++i) &#123; int pre = nums[nums.size() - 1]; for (int j = 0; j &lt; nums.size(); ++j) &#123; tmp = nums[j]; nums[j] = pre; pre = tmp; &#125; &#125;&#125; 复杂度分析 时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$ 空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$ 解法2：使用额外数组使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上. 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; arr = nums; for (int i = 0; i &lt; nums.size(); ++i) arr[(i + k) % nums.size()] = nums[i]; for (int i = 0; i &lt; nums.size(); ++i) nums[i] = arr[i];&#125; 复杂度分析 时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$ 空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$ 解法3：使用环状替换如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。 现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上 12345678910111213141516void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 复杂度分析 时间复杂度：只遍历了一遍数组，$O(n)$ 空间复杂度：只用了常数个额外空间，$O(1)$ 解法4：数组反转先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end());&#125; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$，没有使用额外空间 2. 从数组中删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成. 解法：双指针法数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例： 1234567[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ i i i j j j[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ... i i i j j j 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int j:nums) if (!i || j &gt; nums[i - 1]) nums[i++] = j; return i; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 3. 买卖股票的最佳时机II给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1 12345输入: [7,1,5,3,6,4]输出: 7解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入， 在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。 示例2 12345输入: [1,2,3,4,5]输出: 4解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票， 之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 解法：暴力解法首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论： 一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断； 一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况； 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt; 2) return 0; int profit = 0; bool has_buy = false; if (prices[0] &lt; prices[1]) &#123; profit -= prices[0]; has_buy = true; &#125; for (int i = 1; i &lt; prices.size() - 1; ++i) &#123; if (has_buy == true &amp;&amp; prices[i] &gt; prices[i + 1]) &#123; profit += prices[i]; has_buy = false; &#125; else if (has_buy == false &amp;&amp; prices[i] &lt; prices[i + 1]) &#123; profit -= prices[i]; has_buy = true; &#125; &#125; if (has_buy == true) profit += *(prices.end() - 1); return profit; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 4. 存在重复给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。 解法：使用unorder_set使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set; for (auto it : nums) &#123; if (set.count(it) &gt; 0) return true; else set.insert(it); &#125; return false; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 5. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解法：使用异或该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) ans ^= i; return ans; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 6. 两个数组的交集II给定两个数组，编写一个函数来计算它们的交集。 示例1 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 示例2 12输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]输出: [2,3,5] 解法：使用find()函数使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;nums1.size();i++) &#123; auto it=find(nums2.begin(),nums2.end(),nums1[i]); if(it!=nums2.end()) &#123; res.push_back(*it); nums2.erase(it); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \\sim O(n^2)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 7. 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。 示例 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 解法：反向遍历首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; digits[digits.size() - 1]++; for (auto i = digits.size() - 1; i &gt; 0; --i) &#123; if (digits[i] == 10) &#123; digits[i] = 0; digits[i - 1]++; &#125; &#125; if (digits[0] == 10) &#123; digits[0] = 0; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 8. 移动零给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。 示例 123输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。 解法：双指针法设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1. 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j = 0; while (i &lt; nums.size()) &#123; if (nums[i] == 0) i++; else &#123; swap(nums[i], nums[j]); i++; j++; &#125; &#125; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 9. 两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 123输入: nums = [2, 7, 11, 15], target = 9输出: [0,1]说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1] 解法1：暴力法暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; ans.push_back(i); ans.push_back(j); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 解法2：两遍哈希表以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_set; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash_set.count(target - nums[i]) &gt; 0) &#123; ans.push_back(hash_set[target - nums[i]]); ans.push_back(i); break; &#125; hash_set[nums[i]] = i; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 10. 有效的数独示例 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 解法：一次遍历使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中 1234567891011121314151617181920class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;unordered_map&lt;int,int&gt;&gt; rows(9), cols(9), boxes(9); for(int i = 0; i &lt; 9; ++ i) &#123; for(int j = 0; j &lt; 9; ++ j) &#123; int box_index = (i / 3) * 3 + j / 3; char n = board[i][j]; if(n != '.') &#123; if(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n)) return false; rows[i][n] = 1; cols[j][n] = 1; boxes[box_index][n] = 1; &#125; &#125; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 11. 旋转图像给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。 示例1 12345678910111213给定matrix= [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 解法：翻转先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$ 12345678910class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (int i = 0; i &lt; matrix.size(); ++i) for (int j = i; j &lt; matrix[0].size(); ++j) swap(matrix[i][j], matrix[j][i]); for (int i = 0; i &lt; matrix.size(); ++i) reverse(matrix[i].begin(), matrix[i].end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"LeetCode","slug":"Computer-Science/LeetCode","permalink":"http://fengggggggg.github.io/categories/Computer-Science/LeetCode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://fengggggggg.github.io/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fengggggggg.github.io/tags/LeetCode/"}]},{"title":"C++中的内联函数","slug":"computer_science/C&C++/inline_in_C++","date":"2019-07-30T01:45:00.000Z","updated":"2019-07-30T01:45:00.000Z","comments":true,"path":"2019/07/30/computer_science/C&C++/inline_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/30/computer_science/C&C++/inline_in_C++/","excerpt":"内联函数相关知识点梳理","text":"内联函数相关知识点梳理 1. 内联函数的作用引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏： 1#define Expression(a, b) (((a) + (b)) * ((a) - (b))) 该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它使用预处理器实现，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏不能进行参数有效性检测，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。 另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。 为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。 2. inline与宏定义的区别 inline函数的本质是一个函数，而宏不是； inline函数在编译时展开，宏在预编译时展开； 在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换； inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能； 宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。 3. inline的优点 inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高； 类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性； inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。 4. inline的使用场合 用于取代表达式形式的宏定义； 用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，定义在类体内的函数会被自动转换成内联函数。 5. inline的缺点inline是以代码复制为代价的，仅仅省去了函数调用的开销，从而提高函数的执行效率。若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低。另外，每一处内联函数的调用都需要复制代码，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline： 函数体内代码较长：使用inline将导致较高的内存消耗； 函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大； 不用于类的构造函数和析构函数。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"C++中的数据类型及其大小","slug":"computer_science/C&C++/data_type_in_C++","date":"2019-07-29T11:58:00.000Z","updated":"2019-07-29T11:58:00.000Z","comments":true,"path":"2019/07/29/computer_science/C&C++/data_type_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/29/computer_science/C&C++/data_type_in_C++/","excerpt":"在C/C++中的数据类型及其所占空间大小总结","text":"在C/C++中的数据类型及其所占空间大小总结 1. 内置数据类型常见的内置数据类型如下表所示，可以使用sizeof查看其大小： type size char 1B unsigned char 1B signed char 1B int 4B unsigned int 4B signed int 4B short (int) 2B long (int) 8B float 4B double 8B long double 16B wchar_t 2B or 4B 其中wchar_t是宽字符型，其定义为 1typedef short int wchar_t; 也就是说，实际上wchar_t和short int是等价的。 2. 数组与字符串对数组使用sizeof运算，其大小为数组中元素的个数*元素所占内存大小，而对于char数组型的字符串，例如char str[] = &quot;Hello&quot;，其大小为字符个数+1，因为结尾需要保存\\0。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。 3. 自定义数据类型3.1. class及struct3.1.1. 空类对于一个空类，例如 1234class A&#123;&#125; 其大小为1B，因为C++中每一个类都有一个独一无二的地址，因此即使是空类也会为其分配1B的内存空间。 3.1.2. 类对象所占内存大小类所占的内存大小由其成员变量决定，成员函数不计算在内，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如 123456789101112131415161718192021222324252627282930313233343536373839404142// sizeof(A) = 4class A&#123; int a;&#125;;// sizeof(B) = 4, 成员函数不计入class B&#123; int a; int fun1() &#123; return 0; &#125;&#125;;// sizeof(C) = 1, 结构体不计入class C&#123; struct stc1 &#123; int sa; char sb; &#125;;&#125;;// sizeof(D) = 1, 联合体不计入class D&#123; union un1 &#123; int ua; short ub; &#125;;&#125;;// sizeof(E) = 1, class不计入class E&#123; class cl1 &#123; int ca; short cb; &#125;;&#125;; 3.1.3. 类对象的字节对齐由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能从某些特定地址开始存取，如果不对其，会给存取效率带来损失。 字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 如果类中包含虚函数，则无论其有多少个虚函数，这些虚函数所占内存均为4B，因为内存中需要保存一个虚表指针成员 举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class A&#123; int i;&#125;;class B&#123; char ch;&#125;;class C&#123; int i; short s;&#125;;class D&#123; int i; short j; char ch;&#125;;class E&#123; int i; int ii; short j; char ch; char ch2;&#125;;class F&#123; int i; int ii; int iii; short j; char ch; char ch2;&#125;;struct G&#123; char ch; int i; short b2;&#125;;class H&#123; int i; virtual void fun1() &#123;&#125; virtual void fun2() &#123;&#125;&#125;;class I : public A, public B &#123;&#125;;class J : virtual public A &#123;&#125;;class K : virtual public A, virtual B &#123;&#125;;class L&#123; int i; static int ii;&#125;// sizeof(A) = 4// sizeof(B) = 1// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)// sizeof(J) = 8// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中) 3.2. union联合体的大小取决于该体中所有的成员中占用空间最大的一个成员的大小，并且同样的需要对齐： 123456789101112131415161718192021union u1&#123; double a; int b;&#125;;union u2&#123; char a[13]; int b;&#125;;union u3&#123; char a[13]; char b;&#125;;// sizeof(u1) = 8;// sizeof(u2) = 13 + 3(以int的整数倍补齐);// sizeof(u3) = 13;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"Ubuntu下GDB的使用","slug":"computer_science/Linux/gdb_in_ubuntu","date":"2019-07-27T14:00:00.000Z","updated":"2019-07-27T14:00:00.000Z","comments":true,"path":"2019/07/27/computer_science/Linux/gdb_in_ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2019/07/27/computer_science/Linux/gdb_in_ubuntu/","excerpt":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧","text":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧 1. 使用GDB调试可执行文件123gdb a.out # 不带参数或gdb --args a.out 参数 # 带参数 2. GDB常用命令12345678910111213141516171819202122232425r [args] # 带参数从头开始执行程序b arg # 在arg处设置断点，arg可以为行数、地址b xxx if (condition) # 条件断点b test.c:30 if n==100 # 当变量n等于100的时候在test.c的30行处加断点n (next) # 单步执行，如遇函数则直接返回函数的执行结果s (step) # 单步执行，如遇函数则进入函数体执行stop # 停止执行q (quit) # 退出GDBuntil # 当不想反复执行循环时，可以用until跳出循环finish # 跳出当前函数c (continue) # 继续执行，直到下一个断点或程序结束p arg # 打印出arg的值，arg可以为变量或地址whatis variable # 打印出变量的类型ptype variable # 打印出变量的类型，只不过比whatis更详细i variables variable # 打印出定义variable的文件i source # 查看当前程序i b # 查看arg，arg可以为断点、变量值、i args # 打印出当前函数的参数值i locals # 打印出当前函数中所有局部变量值i r (r_name) # 查看所有寄存器(寄存器r_name)的值i threads # 查看线程d b # 删除断点，b为断点编号bt # 查看函数的back tracel (list) arg # 显示arg附近的前后共10行代码，arg可以为行数或函数名watch arg # 设置监控，在arg改变时停止(需要先加断点) 3. 设置断点1234# 当欲设断点在当前文件中时，可以b+行数或b+函数名b 45/main# 当欲设断点在其他文件中时，b 文件名:行数b head.cpp:45","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"http://fengggggggg.github.io/tags/GDB/"}]},{"title":"C++中const、define和static","slug":"computer_science/C&C++/const_define_static_in_C++","date":"2019-07-03T03:29:37.000Z","updated":"2019-07-02T16:00:00.000Z","comments":true,"path":"2019/07/03/computer_science/C&C++/const_define_static_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/03/computer_science/C&C++/const_define_static_in_C++/","excerpt":"关键字const、define和static相关知识点整理","text":"关键字const、define和static相关知识点整理 1. const和define区别 宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查; const常量存在于程序的数据段，并在堆栈分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查; 2. C++中关键字const的作用 定义常量; 修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const: 12void fun(A a);void fun(A const &amp;a); 修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量: 123const char *GetChar()&#123;&#125;;char *ch = GetChar(); // errorconst char *ch = GetChar() //correct const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下: 1int GeoCount() const; 3. 静态变量static1. static的作用 一个static变量可以维持其值在被调用的过程中不变； 在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问； 模块内的一个static修饰的函数只可以被该模块内的函数调用。 2. static变量和普通变量的区别1. static全局变量和普通全局变量 static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值； static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用； （相同点）两种都以静态存储方式存储； 2. static局部变量和普通局部变量 static局部变量只被初始化一次，下一次使用依据上一次的结果 3. static函数和普通函数 static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品； static函数作用域仅在本文件中，普通函数可在其他文件被调用；","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"Introduction to Array","slug":"computer_science/Data_Structure/array","date":"2019-06-28T16:04:37.000Z","updated":"2019-06-28T16:00:00.000Z","comments":true,"path":"2019/06/29/computer_science/Data_Structure/array/","link":"","permalink":"http://fengggggggg.github.io/2019/06/29/computer_science/Data_Structure/array/","excerpt":"学习数组时的一个简单的笔记","text":"学习数组时的一个简单的笔记 数组及其初始化对于一个只声明未赋值的int型数组，如果该数组为全局变量，该数组会被初始化为0，若为局部变量，则被初始化为乱值； 矩阵的压缩存储稀疏矩阵：对于一个稀疏矩阵(即矩阵中的大部分元素为0)，可以使用三元组表示法对其压缩。在一个三元组中，每一个一个条目都形如(行号, 列号, 值)，稀疏矩阵中的每一个非零值由三元组表中的条目唯一表示。稀疏矩阵经过三元组压缩存储后，会失去随机存取能力； 特殊矩阵：特殊矩阵形如上三角矩阵、对角矩阵、对称矩阵等，特殊矩阵的压缩存储并不会丧失随机存取的能力。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://fengggggggg.github.io/tags/Array/"}]},{"title":"MacOS/Ubuntu 18.10 安装PyTorch","slug":"computer_science/Linux/PyTorch_for_Linux","date":"2019-03-29T16:00:00.000Z","updated":"2018-03-29T16:00:00.000Z","comments":true,"path":"2019/03/30/computer_science/Linux/PyTorch_for_Linux/","link":"","permalink":"http://fengggggggg.github.io/2019/03/30/computer_science/Linux/PyTorch_for_Linux/","excerpt":"MacOS/Ubuntu 18.10 安装PyTorch","text":"MacOS/Ubuntu 18.10 安装PyTorch 1. MacOS/Ubuntu 18.10 安装Conda管理环境MacOS下前往Anaconda官网下载安装即可Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加export PATH=”/home/user_name/anaconda3/bin:$PATH”并source一下即可 2. MacOS/Ubuntu 18中安装PyTorch (可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch 123conda create -n environment_name python=X.X (2.7/3.6) # 创建虚拟环境conda info --env # 显示所有的conda虚拟环境conda activate environment_name # 激活虚拟环境 修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源 12345678# for Anacondaconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# for PyTrochconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes 安装PyTorch 12conda install pytorch torchvisionconda deactivate # 使用结束后退出虚拟环境 3. 虚拟环境中安装jupyter如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter 1python3 -m pip install jupyter","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://fengggggggg.github.io/tags/PyTorch/"},{"name":"MacOS","slug":"MacOS","permalink":"http://fengggggggg.github.io/tags/MacOS/"}]},{"title":"Introduction to Queue","slug":"computer_science/Data_Structure/Queue","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-03T16:00:00.000Z","comments":true,"path":"2019/03/04/computer_science/Data_Structure/Queue/","link":"","permalink":"http://fengggggggg.github.io/2019/03/04/computer_science/Data_Structure/Queue/","excerpt":"A note to queue","text":"A note to queue 1. 循环队列 计算大小为n的循环队列中元素的个数 $(rear - front + n) % n$ $(rear - front + n + 1) % n$ 循环队列判空 $front = rear$ 循环队列判满 $(rear + 1) % n = front $ 出队后头指针front的值 $ front = (front + 1) % m $","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fengggggggg.github.io/tags/Data-Structure/"},{"name":"Queue","slug":"Queue","permalink":"http://fengggggggg.github.io/tags/Queue/"}]},{"title":"Ubuntu 18.10安装LLVM","slug":"computer_science/Linux/LLVM_for_Ubuntu","date":"2018-12-29T16:00:00.000Z","updated":"2018-12-29T16:00:00.000Z","comments":true,"path":"2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","excerpt":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本","text":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本 1.安装cmake安装LLVM需要使用cmake，可以使用如下命令安装: 1sudo apt install cmake 2.修改swap分区(可选，不推荐)从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下： 查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间: 123sudo swapon --showorfree -h 检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值 1df -h 在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。 123sudo swapoff -a # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，sudo fallocate -l 20G /swapfile # 创建swapfilels -lh /swapfile # 验证是否成功创建swapfile， 如果显示-rw——1 root root 20G 日期 /swapfile 则表示创建成功 启用交换文件 12sudo chmod 600 /swapfile # 锁定swapfile权限sudo mkswap /swapfile # 将文件标记为交换空间 若显示:Setting up swapspace…… 则表示成功标记swapfile，标记之后启用该文件 12sudo swapon /swapfile # 启用free -h # 验证 永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留 12sudo cp /etc/fstab /etc/fstab.bak # 备份echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab # 将swap文件信息添加到/etc/fstab文件 3.安装LLVM-8.0 Debug版本 首先去LLVM官网下载必要的软件包; 获取源码: 1234567891011121314151617181920212223# 在适当位置放置LLVM源码，此处放在home下cd ~mkdir tmp# 解压LLVM源码cd tmptar -Jxvg llvm-7.0.0.src.tar.xzmv llvm-7.0.0.src llvm# 解压clang源码(此时在tmp目录下)cd llvm/toolstar -Jxvg cfe-7.0.0.src.tar.xzmv cfe-7.0.0.src clang# 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)cd clang/toolstar -Jxvg clang-tools-extra-7.0.0.src.tar.xzmv clang-tools-extra-7.0.0.src extra# 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)cd ~/tmp/llvm/projectstar -Jxvg compiler-rt-7.0.0.src.tar.xzmv compiler-rt-7.0.0.src compiler-rt 开始安装 123456789101112# 在tmp目录下新建build文件夹cd buildcmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Debug ../llvmmake -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半sudo make install# 将路径添加到环境变量中cd ~vim .bashrcexport PATH=/usr/lib/llvm-7/binexport LD_LIBRARY_PATH=/usr/lib/llvm-7/libsource .bashrc 重启终端并测试 123clang -vclang++ -vclang test.c","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"LLVM","slug":"LLVM","permalink":"http://fengggggggg.github.io/tags/LLVM/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu 18.10安装与配置","slug":"computer_science/Linux/install_ubuntu","date":"2017-06-03T16:00:00.000Z","updated":"2017-06-03T16:00:00.000Z","comments":true,"path":"2017/06/04/computer_science/Linux/install_ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2017/06/04/computer_science/Linux/install_ubuntu/","excerpt":"Ubuntu 18.10安装与配置","text":"Ubuntu 18.10安装与配置 1. 安装Ubuntu 18.10安装过程不多说，安装镜像可以去中科大镜像下载。 2. 安装搜狗输入法 前往搜狗输入法官网下载deb安装文件，双击安装； 前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt； 当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法； 重启系统。 3. 修改软件源应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn 4. 安装Chrome前往Chrome官网下载.deb安装包，双击安装即可。 5. 开启夜览模式夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整： 打开Terminal安装dconf-editor 1sudo apt install dconf-editor 在终端打开dconf-editor 1dconf-editor dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature 关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适 6. 系统美化安装Tweaks工具用以配置桌面 12sudo apt updatesudo apt install gnome-tweak-tool 在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有： Weather In The Clock，点击屏幕上方的时间可以展示天气; Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏； 7. 配置终端 安装zsh与git 12sudo apt install zsh sudo apt install git 安装oh-my-zsh 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 将Shell切换到zsh，登出并重新登入 1chsh -s /bin/zsh 在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题 1ZSH_THEME=\"ys\" 安装一些强大的zsh插件首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令： 1source ~/.oh-my-zsh/plugins/incr/incr*.zsh 同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"}]},{"title":"Introduction To Data Structure","slug":"computer_science/Data_Structure/introduction","date":"2016-09-22T16:00:00.000Z","updated":"2014-09-22T16:00:00.000Z","comments":true,"path":"2016/09/23/computer_science/Data_Structure/introduction/","link":"","permalink":"http://fengggggggg.github.io/2016/09/23/computer_science/Data_Structure/introduction/","excerpt":"对常见数据结构的一个简单地总结","text":"对常见数据结构的一个简单地总结 1. 数据结构定义数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成，记为： $Data Structure = (D, R)$ 其中$D$是数据元素的集合，$R$是$D$中元素之间的关系的集合。 通俗的理解，数据结构=逻辑结构(线性、非线性) + 存储结构(顺序、链式、索引、散列) 逻辑结构：数据元素间抽象化的相互关系 存储结构：数据在计算机中的存储形式，也是物理结构 2. 逻辑结构数据的逻辑结构是指数据之间的逻辑关系，比如一对一、一对多、多对一、多对多等。通常，逻辑关系可以分为两种：线性关系和非线性关系。线性关系指：除第一个外，每个元素有且只有一个前驱；除最后一个元素外，每个元素有且只有一个后继。 常见的逻辑结构有以下几种： 集合：数据元素间没有任何关系 线性结构：数据元素间存在线性关系 树：数据元素间有层次关系 图：数据元素间you网状关系 常见的线性结构：线性表、栈、队列、双队列、数组、串等常见的非线性结构：多维数组、树、图、广义表等 3. 存储结构数据的存储结构是指数据在计算机中的存储形式，也是数据的物理结构。 常见的存储结构有以下几种： 顺序存储：逻辑上相邻的节点存储在物理位置上相邻的存储单元中，节点之间的逻辑关系由存储单元的邻接关系体现 优点：可实现对节点的随机存取 缺点：不便于插入、删除，因为要大量移动数据 链式存储：逻辑上相邻的节点在物理存储上不相邻，而是通过指针等体现逻辑关系 优点：便于插入、删除，存储密度比顺序存储小 缺点：不便于查找 索引存储：通过建立索引表来标识节点的地址 散列存储：根据节点的关键字直接计算出节点的存储地址","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fengggggggg.github.io/tags/Data-Structure/"}]},{"title":"计算机网络物理层简介","slug":"computer_science/Computer_Network/physical_layer_in_network","date":"2015-03-22T06:12:00.000Z","updated":"2015-03-22T06:12:00.000Z","comments":true,"path":"2015/03/22/computer_science/Computer_Network/physical_layer_in_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/22/computer_science/Computer_Network/physical_layer_in_network/","excerpt":"物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议","text":"物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议 1. 物理层的主要作用物理层有如下几个作用 构建数据通路：即两个通信端之间的可以连续传输数据的物理通路 透明传输：作为物理通路的材质可能有很多，例如双绞线、光纤等，物理层需要确保数据对这些材质透明，即不管什么材质都不影响数据传输 传输数据：既然是通路其基本功能就是传输数据。物理层的基本传输单元是bit 数据编码：不同传输介质所支持的数据编码可能不同，如归零码、曼彻斯特码、差分曼彻斯特码等。物理层需要确保不同编码的数据能够正常在通路上传输 数据传输管理：对比特流的数据传输流量控制、差错控制、物理线路的激活与释放等 2. 物理层特性物理层需要规范其接口的特性，有了统一的标准，不同的厂商能够以相同的标准来实现彼此产品的互联 机械特性：定义了传输介质接线器、物理接口的形状和尺寸、引线数目和排列顺序以及连接器与接口之间的固定和锁定装置 电气特性：规定了在通路上传输比特流时线路上信号电压的高低、阻抗匹配情况，以及传输速率和传输距离限制等参数属性，主要分为三类： 非平衡型 差分接收器的非平衡型 平衡型 功能特性：指传输介质中各条线上所出现的某一电平的含义，以及物理接口各条信号线的用途，包括：接口信号线的功能规定，接口信号线的功能分类。 3. 物理层传输介质 导向性传输介质 双绞线 同轴电缆 光纤 非导向性传输介质 短波无线传输 地面微波接力通信 卫星通信","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://fengggggggg.github.io/tags/Network/"}]},{"title":"死锁问题","slug":"computer_science/Operating_System/deadlock","date":"2015-03-16T06:12:00.000Z","updated":"2015-03-16T06:12:00.000Z","comments":true,"path":"2015/03/16/computer_science/Operating_System/deadlock/","link":"","permalink":"http://fengggggggg.github.io/2015/03/16/computer_science/Operating_System/deadlock/","excerpt":"关于死锁的一些归纳和总结","text":"关于死锁的一些归纳和总结 1. 死锁产生的原因和必要条件进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。 可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。 不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。 因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点： 系统资源不足。这是根本原因，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时； 进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。 对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4： 互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用； 请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源； 不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占； 循环等待。若干个进程形成循环等待链。 2. 死锁的预防通过破坏死锁的必要条件来控制死锁的策略称为死锁预防，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。 破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的优点是安全简单易实现，缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源。 破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”。 破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高。 3. 死锁的避免与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的前提是每个进程清除自己需要多少资源，因此死锁避免还是有局限性的。 系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全； 银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。 4. 银行家算法银行家算法有5种数据结构： 系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲； 最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k； 分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数； 需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源； 请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。 当某个进程i对j类资源提出k个请求是，需要按照下列步骤检查： 若$Request[j]&lt;=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错； 若$Request[j]&lt;=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i； 系统进行试探性分配，并修改相应的表： Available[j] -= Request[j]; Allocation[i][j] += Request[j]; Need[i][j] -= Request[j]; 调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。 判断当前状态是否安全 添加两个数组： Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa； Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。 检查当前状态的完整过程如下： 初始化Work和Finish。Work[j]=Available[j], Finish[i]=false; 在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4: Finish[h] = false; Need[h][j] &lt;= Work[j] 由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2 若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。 5. 死锁检测6. 死锁解除","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Deadlock","slug":"Deadlock","permalink":"http://fengggggggg.github.io/tags/Deadlock/"}]},{"title":"计算机网络的分类","slug":"computer_science/Computer_Network/classify_in_network","date":"2015-03-15T06:12:00.000Z","updated":"2015-03-15T06:12:00.000Z","comments":true,"path":"2015/03/15/computer_science/Computer_Network/classify_in_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/15/computer_science/Computer_Network/classify_in_network/","excerpt":"计算机网络分类","text":"计算机网络分类 1. 按覆盖范围分 局域网LAN：最常见、最长应用的网络 城域网MAN 广域网WAN","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://fengggggggg.github.io/tags/Network/"}]},{"title":"计算机网络中的数制与编码","slug":"computer_science/Computer_Basic/number_system_and_coding_in_network","date":"2015-03-08T06:12:00.000Z","updated":"2015-03-08T06:12:00.000Z","comments":true,"path":"2015/03/08/computer_science/Computer_Basic/number_system_and_coding_in_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/08/computer_science/Computer_Basic/number_system_and_coding_in_network/","excerpt":"计算机网络中的进制与编码","text":"计算机网络中的进制与编码 1. 常见进制计算机是二进制的世界，及其只能识别01串，但是为了人类理解方便，还是制定了多种进制，例如: 十进制：十进制数的标志为D，例如(123)D 二进制：二进制的标识为B，例如(101)B 八进制：标识为\b字母O，在C/C++中八进制数前需要加数字0，如0123位八进制数 十六进制：标识为H，C/C++中十六进制数以0x开头 十二进制：时钟用到的进制 六十进制：分钟与秒钟用到的进制 2. 进制转换 非十进制转换成十进制：按位的幂的累加和，例如$(11010)2 = 12^4 + 12^3 + 02^2 + 12^1 + 0*2^0 = (26){10}$ 十进制转换成非十进制：整数使用除基取余法，小数使用乘基正序取整法(即每次乘基后，取大于1的部分整数) 非十进制与非十进制之间的转换：可以利用二进制作为中介 3. 计算机中二进制数的表示计算机中二进制采用的表示形式为补码。计算机中的字长是指计算机一次可以处理的二进制数的长度。 原码：最高位用于表示数的正负。这种表示的缺陷是对异号加减操作不便，与此同时0有+0和-0两种不同的表示，存在二义性。故计算机不采用这种表示形式 补码：正数补码与原码相同，负数的补码为原码除符号位外按位取反，再将末位加1得到。补码的优点是运算时可以将符号位一起运算，且0只有一种表示形式 反码：正数反码与源码相同，负数为除符号位外按位取反。反码是原码和补码的中间过渡形式。 移码：补码的符号位取反即是移码","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Basic","slug":"Computer-Science/Computer-Basic","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Basic/"}],"tags":[{"name":"Basic","slug":"Basic","permalink":"http://fengggggggg.github.io/tags/Basic/"}]},{"title":"进程的基本概念","slug":"computer_science/Operating_System/process","date":"2015-03-07T06:12:00.000Z","updated":"2015-03-07T06:12:00.000Z","comments":true,"path":"2015/03/07/computer_science/Operating_System/process/","link":"","permalink":"http://fengggggggg.github.io/2015/03/07/computer_science/Operating_System/process/","excerpt":"","text":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。 1. 进程的概念1.1 程序的顺序执行在计算机中常使用程序这个概念，程序是一个在时间上严格按先后次序操作实现算法功能的指令序列，程序本身是静态的，是指令编译出的结果。在单道程序设计环境中，程序总是顺序执行的，若有多个程序，则各个程序试一次呗调入内存的。程序的顺行执行有以下三个特点： 顺序性。CPU严格按照程序规定的顺序(即指令顺序)执行程序的操作，每个操作都必须在前一个操作结束后才能执行； 封闭性。程序一旦开始执行，其结果仅由初始条件和程序本身操作决定，不受外界因素影响； 可再现性。当初始条件相同，程序的运行结果也相同。 单道程序的顺序性、封闭性和可再现性给程序的编制、调试带来了便利，但是资源利用率底。 1.2 程序的并发执行1.3 进程1.3.1. 进程的定义单道程序环境下，程序与CPU执行的活动是一致的。多道环境下，并发破坏了程序的封闭性和可再现性，程序与CPU执行的活动不再一一对应。程序是完成某一特定功能的指令序列，是一个静态过程，而CPU执行的活动是一个动态的过程。因此20世纪60年代Dijkstra引入了进程的概念。他给出的进程定义是：行为的规则称为程序，程序在CPU上执行时的活动称为进程。 1.3.2. 进程的结构通常程序是不能并发执行的，为了使程序及它所要使用的资源能独立运行，OS为程序配置了一个特殊的数据结构进程控制块PCB(Process Control Block)，PCB用来存储程序向前执行过程中所要记录的有关运行信息，即该进程动态之行的相关资料。因此： 进程实体 = 程序段 + 相关数据段 + PCB 1.3.3. 进程的特征进程作为OS的一个实体有以下5个特征。 动态性。进程是程序的一次执行，因此进程是动态的，具有生命期。 并发性。多个进程实体在一段时间内能够并发执行，从而提高系统资源利用率。 独立性。每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位。 异步性。各进程按各自独立的、不可预知的速度向前推进。对单CPU系统而言，任何时刻只能有一个进程占用CPU。 结构性。每个进程的结构都由程序段、数据段和PCB组成。 1.3.4. 进程和程序的区别 程序是指令的有序集合，是静态的；Process是程序在CPU上的一次执行，是动态的； 程序作为软件可以长期保存；Process有自己的生命周期； 程序不会占有和调度资源；Process会为其分配和调度资源； 进程与程序之间无一一对应关系，一个程序可以多次执行产生多个进程，不同进程也可以包含同一个程序； 程序是记录在存储介质上的指令有序集合；进程则由程序段、数据段、PCB组成。 2. 进程的状态及转换2.1. 5状态进程模型进程有5个状态：创建、就绪、运行、阻塞、终止，下面对其一一说明。 进程的创建。通常有4件事会导致新进程的产生： 在一个批处理环境中，为了响应一个任务的要求而产生进程； 在一个交互式环境中，当一个新用户企图登录时会产生进程； 操作系统代替用户程序产生进程； 由用户程序产生进程。通常进程都是由操作系统产生的，但是一个进程也可以产生另一个进程，分别称为父进程和子进程。 进程的终止。当一个进程执行到自然结束点，或因不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程进入终止态。处于终止态的进程不能被再次调度执行，与其相关的数据信息由OS临时保存，随后OS逐步释放为其分配的资源，最后释放PCB。 进程的就绪。进程获得了除CPU之外的所需资源，一旦得到CPU就可运行。就绪状态的进程会组成就绪队列。 进程的运行。进程获得了CPU和其他资源，正在CPU上运行时的状态。 进程的阻塞。进程运行中发生了某种等待事件(如I/O操作)而暂时不能运行的状态，此状态的进程不能竞争CPU，而需要等事件完成后转到就绪态才能竞争。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://fengggggggg.github.io/tags/Process/"}]},{"title":"Introduction To Computer","slug":"computer_science/Computer_Basic/introduction","date":"2014-02-22T16:00:00.000Z","updated":"2014-02-22T16:00:00.000Z","comments":true,"path":"2014/02/23/computer_science/Computer_Basic/introduction/","link":"","permalink":"http://fengggggggg.github.io/2014/02/23/computer_science/Computer_Basic/introduction/","excerpt":"《计算机组装与维修技术》阅读笔记","text":"《计算机组装与维修技术》阅读笔记 1.计算机及其组成什么是计算机计算机全称电子计算机，俗称电脑、PC等，是一种用于计算的机器，其种类繁多，包括个人计算机、高性能计算机、服务器等。 计算机的组成一个完整的可正常工作的计算机包括硬件和软件两个部分： 1. 计算机硬件硬件是指组成计算机的实体部件，从外观上来看硬件包括：主机、显示器、键盘、鼠标、音响、打印机、扫描仪等，其中主机使整个计算机最重要的组件，一般的，主机都包括: CPU：Central Processing Uint，计算机核心的核心，目前CPU的生产厂商有Intel和AMD两家公司，市场占比大约82开 主板：承担着操控和协调CPU、声卡、显卡等部件的任务 显卡 风扇 电源 网卡 声卡 2. 计算机软件软件是指在硬件上运行的各种程序，例如聊天软件、游戏软件，其中操作系统也是软件的一种，例如Unbuntu、Windows等 2. CPUCPU作为计算机的核心，其性能指标包括以下几种： 主频：即CPU的时钟频率，单位为MHz或GHz，标示CPU的运算速度，CPU的主频=外频x倍频 外频：CPU的总线频率，是由主板为CPU提供的基准时钟频率，单位为MHz，外频决定了主板的运行速度。通常我们在台机中所说的超频，就是指超CPU的外频，大部分CPU外频和主板频率是同步运行的，如果改变外频可能会导致系统不稳定 倍频：CPU主频和外频之间的倍率，一般情况下CPU的倍频是锁定的，有的CPU可以调节倍频 前端总线频率：也称FSB带宽，是CPU与内存间的数据交换的速率，一般数据带宽=(总线频率x数据位宽)/8 缓存：由于CPU和内存处理数据速度不一致，因而引入了缓存，一般而言CPU中有2～3级缓存，L1 Cache是一级缓存，由SRAM组成 3. 主板主板是一块印刷电路板PCB，一般采用4或6层板，4层板包括主板信号层、接地层、电源层、次信号层，6层板多了辅助电源层和中信号层，6层的抗电磁干扰能力更强。一般主板有如下几个组件： 芯片组：芯片组主要由BIOS芯片、南北桥芯片、磁盘阵列RAID、控制芯片等组成 BIOS芯片：BIOS芯片是一块方块型的存储器，里面存有与该主板搭配的基本输入输出系统程序，改程序能够让主板识别各种硬件，以及设置引导系统、调整CPU外频等，BIOS芯片是可写入的。 南北桥：横跨AGP插槽左右两侧的两块芯片就是南北桥芯片。南桥芯片多位于PCI插槽的上方；而CPU插槽旁边，被散热片盖住的则是北桥芯片，一般而言主板的命名都是以北桥的核心名称命名的。北桥芯片主要负责处理CPU、内存、显卡三者之间的交互；南桥负责硬盘等存储设备和PCI之间的数据流通。南北桥合称芯片组。现代的一些高端主机会将南北桥芯片封装到一起。 RAID：控制芯片 总线：总线是主板的重要组成部分，各个部件通过插槽连接到总线上，通常包括：CPU插槽、内存插槽、AGP插槽(用于插AGP显卡，目前逐渐被PCI Express插槽取缔)、PCI插槽(插声卡、网卡等)、CNR插槽(插CNR接口的软Modem或网卡) 对外接口：硬盘接口(一般都是SATA接口)、软驱接口、COM接口(连接串行鼠标和外置Modem等)、PS/2接口(仅用于连接键鼠，目前逐渐被USB接口取代)、USB接口、LPT接口(连接打印机或扫描仪)、MIDI接口(声卡和游戏杆，目前逐渐淘汰)。 4. 内存内存是有内存芯片、电路板、金手指(即内存条边缘的一排金黄色导电触片)等组成，当计算机运行时，CPU就会把运行所需的数据从硬盘中调到内存中，运算完成后再传出，目前市面上流行的内存类型为DDR3和DDR4，DDR即双倍速率同步动态随机存储器Double Data Rate Synchronous Dynamic Random Access Memory的简称，DDR在每个时钟的上升沿和下降沿各传输一次数据 性能指标 内存主频：内存的运行速度 内存容量 CAS延迟：内存读写数据所需的时延 5. 显卡显卡即显示接口卡、显示适配器、显示器配置卡，承担输出图形显示的重要任务。由于显卡的特性，它特别适合处理矩阵运算，因此显卡在现代机器学习中扮演了重要的角色。在机器学习中通常会有大量的矩阵操作，所以可以将这部分操作送给显卡中的GPU去操作。显卡一般分为两种 集成显卡：即芯片组中集成了显卡，这样的芯片组也称为整合型芯片，集显一般没有显存，而是使用内存作为其显存，因此其性能和独显相比较差 独立显卡：显卡成独立的板卡，通常有自己的显存 显卡的基本结构如下： GPU:图形处理芯片 显存 显卡BIOS:驱动程序之间的控制程序,存有显卡的型号、规格、生产厂家及出场时间等 输出接口 显卡PCB板 性能指标 显卡频率：显卡的工作频率，通常越高越好 显存位宽：一个时钟周期内所能传送数据的位数，市场上主流的有128位、256位、320位等 显存在显卡上工作时的频率 显存容量：主流的是256MB和512MB 3D API：显卡与应用程序之间的接口 6. 声卡声卡是实现模拟信号/数字信号相互转换的一种硬件，一般分为板卡式(目前已被淘汰)、集成式(主流)和外置式三种，声卡的基本构成有： 声音控制芯片：可通过数模转换器将模拟信号转换成数字信号，或反过来 DSP：执行和声音处理有关的命令、执行压缩解压缩程序、增加特殊声效和传真Modem等，高档声卡一般配有DSP CODEC：编解码器 输入输出接口 跳线：用于设置声卡的硬件设备，包括CD-ROM的I/O地址、声卡的I/O地址设置。 性能指标 采样频率：每秒从连续信号中采样出离散信号的个数，单位Hz。通俗地讲是指计算机美妙采集多少个声音样本 采样位数：即采样值或取样值，用来衡量声音波动变化的参数，含义是声卡在采集和播放声音文件时所使用数字声音信号的二进制位数 信噪比SNR：放大器的输出信号的电压与同时输出的噪声电压的比例，单位分贝，一般信噪比越高，说明信号李的噪声越小，声音质量越高 频率响应：系统或计量传感器的阻抗随频率的变化 7. 硬盘硬盘是计算机中的存储器件，一般的机械硬盘由一个或多个铝制或玻璃制的碟片组成，碟片外覆盖有铁磁性材料。传统的机械硬盘其内部构造包括： 磁头：负责对磁盘进行读写，与磁盘表面的磁性物质发生作用，一般有MR磁头和GMR磁头，硬盘里的磁头数=磁盘盘体数x2 盘体：存储数据的主体，有一或多个盘片叠在一起组成，盘体有以下几个概念： 磁道：一个盘片的一个面上的一个同心圆成为一个磁道，一般内侧磁道和外侧磁道存储量不同 扇区：每个磁道都被分为若干个弧段，这些弧段就是扇区，每个扇区可以存放512字节的信息，磁盘读写数据以扇区为单位 柱面：每个盘面上相同位置的磁道组成一个柱面，硬盘容量=柱面数x磁头数x扇区数x512B 主轴电机：用于驱动盘体转动的设备，主流的为7200转/分钟 寻道电机、驱动臂：寻道电机带动磁头在盘体上寻道，驱动臂把磁头和寻道电机连接在一起 性能指标 容量 转速：单位为转/分钟或RPM，转的越快，其传输率越高，发热量越大 平均访问时间：磁头从起始位置找到需要读写的数据位置的时间，体现了硬盘的读写速度。一般包括了平均寻道时间和平均等待时间，平均寻道时间是指磁头移动到指定磁道所需的时间，平均等待时间磁头已经在目标磁道，等待所需访问的扇区转至磁头下方所需时间 传输速率：包括内部传输速率和外部传输速率，内部传输速率指未用硬盘缓冲区时的性能，外部传输速率是系统总线与硬盘缓冲区之间的传输速率 缓存：硬盘也有缓存，是硬盘控制器上的一块内存芯片 固态硬盘SSD是一种新型的硬盘，由固态电子存储芯片阵列组成，其存储介质一般有闪存(FLASH)和DRAM两种，和传统硬盘比，SSD有读写速度快、低功耗、无噪声、体积小等优点，也有造价高、使用寿命短的缺点。关于SSD的使用寿命，也就是SSD擦写次数限制，闪存完全擦写一次叫做一次P/E，因此闪存的寿命以P/E为单位，一般34nm的闪存寿命为5000P/E，25nm的为3000P/E。不过由于SSD固件算法升级，SSD能提供更少的不必要写入量。 举个例子，一款128G的SSD，要写入128G的文件才算做一次P/E，即使每天写入50G的内容，2.5天才能完成一次P/E，一年也才用去150次左右的P/E，一块3000P/E的SSD够用200年了。 8. BIOS和CMOSBIOS是基本输入输出系统。启动计算机时，CPU首先根据集成在主板、显卡等设备上的BIOS芯片来核对每个基础设备是否正常，然后从硬盘中拷贝操作系统到内存中。BIOS有3个基本功能： 自检及初始化：开机后BIOS最先被启动，然后BIOS会检查计算机硬件设备，若设备正常才会启动操作系统 程序服务：BIOS直接与计算机的I/O设备交互，实现软件程序对硬件的直接操作 设定中断 CMOS是指互补金属氧化物半导体，是计算机主板上的一块可读写的RAM芯片，用来保存当前系统的硬件配置和用户对某些参数的设定。CMOS由主板的可充电电池供电，即使系统断电CMOS中的信息也不会丢失。 通常计算机中的开机密码存储在CMOS中，当忘记密码时，可以抠下主板上的电池，将CMOS放电，放电后CMOS内容会被清空，因而密码也会被清除。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Basic","slug":"Computer-Science/Computer-Basic","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Basic/"}],"tags":[{"name":"Basic","slug":"Basic","permalink":"http://fengggggggg.github.io/tags/Basic/"}]}]}
{"meta":{"title":"Simita","subtitle":null,"description":null,"author":"V17","url":"http://fengggggggg.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-06-28T15:17:49.173Z","updated":"2019-06-28T15:17:49.173Z","comments":true,"path":"404.html","permalink":"http://fengggggggg.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"ALL CATEGORIES","date":"2019-06-28T15:35:37.852Z","updated":"2019-06-28T15:35:37.852Z","comments":true,"path":"categories/index.html","permalink":"http://fengggggggg.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-28T15:23:09.839Z","updated":"2019-06-28T15:23:09.839Z","comments":true,"path":"mylist/index.html","permalink":"http://fengggggggg.github.io/mylist/index.html","excerpt":"","text":""},{"title":"ALL TAGS","date":"2019-06-28T15:35:48.311Z","updated":"2019-06-28T15:35:48.311Z","comments":true,"path":"tags/index.html","permalink":"http://fengggggggg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 探索初级算法 数组","slug":"computer_science/data_structure/LeetCode_Primary_Algorithm_Array","date":"2019-08-03T13:00:00.000Z","updated":"2019-08-04T16:00:00.000Z","comments":true,"path":"2019/08/03/computer_science/data_structure/LeetCode_Primary_Algorithm_Array/","link":"","permalink":"http://fengggggggg.github.io/2019/08/03/computer_science/data_structure/LeetCode_Primary_Algorithm_Array/","excerpt":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像","text":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像 1. 旋转数组给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数 示例1 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例2 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 解法1：暴力解法旋转k次，每次将数组向右旋转移动一位 1234567891011void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int pre, tmp; for (int i = 0; i &lt; k; ++i) &#123; int pre = nums[nums.size() - 1]; for (int j = 0; j &lt; nums.size(); ++j) &#123; tmp = nums[j]; nums[j] = pre; pre = tmp; &#125; &#125;&#125; 复杂度分析 时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$ 空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$ 解法2：使用额外数组使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上. 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; arr = nums; for (int i = 0; i &lt; nums.size(); ++i) arr[(i + k) % nums.size()] = nums[i]; for (int i = 0; i &lt; nums.size(); ++i) nums[i] = arr[i];&#125; 复杂度分析 时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$ 空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$ 解法3：使用环状替换如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。 现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上 12345678910111213141516void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 复杂度分析 时间复杂度：只遍历了一遍数组，$O(n)$ 空间复杂度：只用了常数个额外空间，$O(1)$ 解法4：数组反转先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end());&#125; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$，没有使用额外空间 2. 从数组中删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成. 解法：双指针法数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例： 1234567[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ i i i j j j[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ... i i i j j j 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int j:nums) if (!i || j &gt; nums[i - 1]) nums[i++] = j; return i; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 3. 买卖股票的最佳时机II给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1 12345输入: [7,1,5,3,6,4]输出: 7解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入， 在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。 示例2 12345输入: [1,2,3,4,5]输出: 4解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票， 之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 解法：暴力解法首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论： 一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断； 一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况； 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt; 2) return 0; int profit = 0; bool has_buy = false; if (prices[0] &lt; prices[1]) &#123; profit -= prices[0]; has_buy = true; &#125; for (int i = 1; i &lt; prices.size() - 1; ++i) &#123; if (has_buy == true &amp;&amp; prices[i] &gt; prices[i + 1]) &#123; profit += prices[i]; has_buy = false; &#125; else if (has_buy == false &amp;&amp; prices[i] &lt; prices[i + 1]) &#123; profit -= prices[i]; has_buy = true; &#125; &#125; if (has_buy == true) profit += *(prices.end() - 1); return profit; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 4. 存在重复给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。 解法：使用unorder_set使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set; for (auto it : nums) &#123; if (set.count(it) &gt; 0) return true; else set.insert(it); &#125; return false; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 5. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解法：使用异或该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) ans ^= i; return ans; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 6. 两个数组的交集II给定两个数组，编写一个函数来计算它们的交集。 示例1 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 示例2 12输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]输出: [2,3,5] 解法：使用find()函数使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;nums1.size();i++) &#123; auto it=find(nums2.begin(),nums2.end(),nums1[i]); if(it!=nums2.end()) &#123; res.push_back(*it); nums2.erase(it); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \\sim O(n^2)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 7. 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。 示例 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 解法：反向遍历首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; digits[digits.size() - 1]++; for (auto i = digits.size() - 1; i &gt; 0; --i) &#123; if (digits[i] == 10) &#123; digits[i] = 0; digits[i - 1]++; &#125; &#125; if (digits[0] == 10) &#123; digits[0] = 0; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 8. 移动零给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。 示例 123输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。 解法：双指针法设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1. 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j = 0; while (i &lt; nums.size()) &#123; if (nums[i] == 0) i++; else &#123; swap(nums[i], nums[j]); i++; j++; &#125; &#125; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 9. 两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 123输入: nums = [2, 7, 11, 15], target = 9输出: [0,1]说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1] 解法1：暴力法暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; ans.push_back(i); ans.push_back(j); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 解法2：两遍哈希表以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_set; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash_set.count(target - nums[i]) &gt; 0) &#123; ans.push_back(hash_set[target - nums[i]]); ans.push_back(i); break; &#125; hash_set[nums[i]] = i; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 10. 有效的数独示例 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 解法：一次遍历使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中 1234567891011121314151617181920class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;unordered_map&lt;int,int&gt;&gt; rows(9), cols(9), boxes(9); for(int i = 0; i &lt; 9; ++ i) &#123; for(int j = 0; j &lt; 9; ++ j) &#123; int box_index = (i / 3) * 3 + j / 3; char n = board[i][j]; if(n != '.') &#123; if(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n)) return false; rows[i][n] = 1; cols[j][n] = 1; boxes[box_index][n] = 1; &#125; &#125; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 11. 旋转图像给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。 示例1 12345678910111213给定matrix= [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 解法：翻转先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$ 12345678910class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (int i = 0; i &lt; matrix.size(); ++i) for (int j = i; j &lt; matrix[0].size(); ++j) swap(matrix[i][j], matrix[j][i]); for (int i = 0; i &lt; matrix.size(); ++i) reverse(matrix[i].begin(), matrix[i].end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"LeetCode","slug":"Computer-Science/LeetCode","permalink":"http://fengggggggg.github.io/categories/Computer-Science/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://fengggggggg.github.io/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://fengggggggg.github.io/tags/Array/"}]},{"title":"C++中的内联函数","slug":"computer_science/C&C++/inline_in_C++","date":"2019-07-30T01:45:00.000Z","updated":"2019-07-30T01:45:00.000Z","comments":true,"path":"2019/07/30/computer_science/C&C++/inline_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/30/computer_science/C&C++/inline_in_C++/","excerpt":"内联函数相关知识点梳理","text":"内联函数相关知识点梳理 1. 内联函数的作用引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏： 1#define Expression(a, b) (((a) + (b)) * ((a) - (b))) 该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它使用预处理器实现，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏不能进行参数有效性检测，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。 另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。 为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。 2. inline与宏定义的区别 inline函数的本质是一个函数，而宏不是； inline函数在编译时展开，宏在预编译时展开； 在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换； inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能； 宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。 3. inline的优点 inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高； 类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性； inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。 4. inline的使用场合 用于取代表达式形式的宏定义； 用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，定义在类体内的函数会被自动转换成内联函数。 5. inline的缺点inline是以代码复制为代价的，仅仅省去了函数调用的开销，从而提高函数的执行效率。若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低。另外，每一处内联函数的调用都需要复制代码，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline： 函数体内代码较长：使用inline将导致较高的内存消耗； 函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大； 不用于类的构造函数和析构函数。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"C++中的数据类型及其大小","slug":"computer_science/C&C++/data_type_in_C++","date":"2019-07-29T11:58:00.000Z","updated":"2019-07-29T11:58:00.000Z","comments":true,"path":"2019/07/29/computer_science/C&C++/data_type_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/29/computer_science/C&C++/data_type_in_C++/","excerpt":"在C/C++中的数据类型及其所占空间大小总结","text":"在C/C++中的数据类型及其所占空间大小总结 1. 内置数据类型常见的内置数据类型如下表所示，可以使用sizeof查看其大小： type size char 1B unsigned char 1B signed char 1B int 4B unsigned int 4B signed int 4B short (int) 2B long (int) 8B float 4B double 8B long double 16B wchar_t 2B or 4B 其中wchar_t是宽字符型，其定义为 1typedef short int wchar_t; 也就是说，实际上wchar_t和short int是等价的。 2. 数组与字符串对数组使用sizeof运算，其大小为数组中元素的个数*元素所占内存大小，而对于char数组型的字符串，例如char str[] = &quot;Hello&quot;，其大小为字符个数+1，因为结尾需要保存\\0。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。 3. 自定义数据类型3.1. class及struct3.1.1. 空类对于一个空类，例如 1234class A&#123;&#125; 其大小为1B，因为C++中每一个类都有一个独一无二的地址，因此即使是空类也会为其分配1B的内存空间。 3.1.2. 类对象所占内存大小类所占的内存大小由其成员变量决定，成员函数不计算在内，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如 123456789101112131415161718192021222324252627282930313233343536373839404142// sizeof(A) = 4class A&#123; int a;&#125;;// sizeof(B) = 4, 成员函数不计入class B&#123; int a; int fun1() &#123; return 0; &#125;&#125;;// sizeof(C) = 1, 结构体不计入class C&#123; struct stc1 &#123; int sa; char sb; &#125;;&#125;;// sizeof(D) = 1, 联合体不计入class D&#123; union un1 &#123; int ua; short ub; &#125;;&#125;;// sizeof(E) = 1, class不计入class E&#123; class cl1 &#123; int ca; short cb; &#125;;&#125;; 3.1.3. 类对象的字节对齐由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能从某些特定地址开始存取，如果不对其，会给存取效率带来损失。 字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 如果类中包含虚函数，则无论其有多少个虚函数，这些虚函数所占内存均为4B，因为内存中需要保存一个虚表指针成员 举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class A&#123; int i;&#125;;class B&#123; char ch;&#125;;class C&#123; int i; short s;&#125;;class D&#123; int i; short j; char ch;&#125;;class E&#123; int i; int ii; short j; char ch; char ch2;&#125;;class F&#123; int i; int ii; int iii; short j; char ch; char ch2;&#125;;struct G&#123; char ch; int i; short b2;&#125;;class H&#123; int i; virtual void fun1() &#123;&#125; virtual void fun2() &#123;&#125;&#125;;class I : public A, public B &#123;&#125;;class J : virtual public A &#123;&#125;;class K : virtual public A, virtual B &#123;&#125;;class L&#123; int i; static int ii;&#125;// sizeof(A) = 4// sizeof(B) = 1// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)// sizeof(J) = 8// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中) 3.2. union联合体的大小取决于该体中所有的成员中占用空间最大的一个成员的大小，并且同样的需要对齐： 123456789101112131415161718192021union u1&#123; double a; int b;&#125;;union u2&#123; char a[13]; int b;&#125;;union u3&#123; char a[13]; char b;&#125;;// sizeof(u1) = 8;// sizeof(u2) = 13 + 3(以int的整数倍补齐);// sizeof(u3) = 13;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"Ubuntu下GDB的使用","slug":"computer_science/Linux/gdb_in_ubuntu","date":"2019-07-27T14:00:00.000Z","updated":"2019-07-27T14:00:00.000Z","comments":true,"path":"2019/07/27/computer_science/Linux/gdb_in_ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2019/07/27/computer_science/Linux/gdb_in_ubuntu/","excerpt":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧","text":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧 1. 使用GDB调试可执行文件123gdb a.out # 不带参数或gdb --args a.out 参数 # 带参数 2. GDB常用命令12345678910111213141516171819202122r [args] # 带参数从头开始执行程序b arg # 在arg处设置断点，arg可以为行数、地址b xxx if (condition) # 条件断点b test.c:30 if n==100 # 当变量n等于100的时候在test.c的30行处加断点n (next) # 单步执行，如遇函数则直接返回函数的执行结果s (step) # 单步执行，如遇函数则进入函数体执行stop # 停止执行q (quit) # 退出GDBuntil # 当不想反复执行循环时，可以用until跳出循环finish # 跳出当前函数c (continue) # 继续执行，直到下一个断点或程序结束p arg # 打印出arg的值，arg可以为变量或地址i source # 查看当前程序i b # 查看arg，arg可以为断点、变量值、i args # 打印出当前函数的参数值i locals # 打印出当前函数中所有局部变量值i r (r_name) # 查看所有寄存器(寄存器r_name)的值i threads # 查看线程d b # 删除断点，b为断点编号bt # 查看函数的back tracel (list) arg # 显示arg附近的前后共10行代码，arg可以为行数或函数名watch arg # 设置监控，在arg改变时停止(需要先加断点) 3. 设置断点1234# 当欲设断点在当前文件中时，可以b+行数或b+函数名b 45/main# 当欲设断点在其他文件中时，b 文件名:行数b head.cpp:45","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Ubuntu","slug":"Computer-Science/Ubuntu","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Ubuntu/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"http://fengggggggg.github.io/tags/GDB/"}]},{"title":"C++中const、define和static","slug":"computer_science/C&C++/const_define_static_in_C++","date":"2019-07-03T03:29:37.000Z","updated":"2019-07-02T16:00:00.000Z","comments":true,"path":"2019/07/03/computer_science/C&C++/const_define_static_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/03/computer_science/C&C++/const_define_static_in_C++/","excerpt":"关键字const、define和static相关知识点整理","text":"关键字const、define和static相关知识点整理 1. const和define区别 宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查; const常量存在于程序的数据段，并在堆栈分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查; 2. C++中关键字const的作用 定义常量; 修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const: 12void fun(A a);void fun(A const &amp;a); 修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量: 123const char *GetChar()&#123;&#125;;char *ch = GetChar(); // errorconst char *ch = GetChar() //correct const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下: 1int GeoCount() const; 3. 静态变量static1. static的作用 一个static变量可以维持其值在被调用的过程中不变； 在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问； 模块内的一个static修饰的函数只可以被该模块内的函数调用。 2. static变量和普通变量的区别1. static全局变量和普通全局变量 static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值； static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用； （相同点）两种都以静态存储方式存储； 2. static局部变量和普通局部变量 static局部变量只被初始化一次，下一次使用依据上一次的结果 3. static函数和普通函数 static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品； static函数作用域仅在本文件中，普通函数可在其他文件被调用；","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"Introduction to Array","slug":"computer_science/data_structure/array","date":"2019-06-28T16:04:37.000Z","updated":"2019-06-28T16:00:00.000Z","comments":true,"path":"2019/06/29/computer_science/data_structure/array/","link":"","permalink":"http://fengggggggg.github.io/2019/06/29/computer_science/data_structure/array/","excerpt":"学习数组时的一个简单的笔记","text":"学习数组时的一个简单的笔记 数组及其初始化对于一个只声明未赋值的int型数组，如果该数组为全局变量，该数组会被初始化为0，若为局部变量，则被初始化为乱值； 矩阵的压缩存储稀疏矩阵：对于一个稀疏矩阵(即矩阵中的大部分元素为0)，可以使用三元组表示法对其压缩。在一个三元组中，每一个一个条目都形如(行号, 列号, 值)，稀疏矩阵中的每一个非零值由三元组表中的条目唯一表示。稀疏矩阵经过三元组压缩存储后，会失去随机存取能力； 特殊矩阵：特殊矩阵形如上三角矩阵、对角矩阵、对称矩阵等，特殊矩阵的压缩存储并不会丧失随机存取的能力。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://fengggggggg.github.io/tags/Array/"}]},{"title":"MacOS/Ubuntu 18.10 安装PyTorch","slug":"computer_science/Linux/PyTorch_for_Linux","date":"2019-03-29T16:00:00.000Z","updated":"2018-03-29T16:00:00.000Z","comments":true,"path":"2019/03/30/computer_science/Linux/PyTorch_for_Linux/","link":"","permalink":"http://fengggggggg.github.io/2019/03/30/computer_science/Linux/PyTorch_for_Linux/","excerpt":"MacOS/Ubuntu 18.10 安装PyTorch","text":"MacOS/Ubuntu 18.10 安装PyTorch 1. MacOS/Ubuntu 18.10 安装Conda管理环境MacOS下前往Anaconda官网下载安装即可Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加export PATH=”/home/user_name/anaconda3/bin:$PATH”并source一下即可 2. MacOS/Ubuntu 18中安装PyTorch (可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch 123conda create -n environment_name python=X.X (2.7/3.6) # 创建虚拟环境conda info --env # 显示所有的conda虚拟环境conda activate environment_name # 激活虚拟环境 修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源 12345678# for Anacondaconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# for PyTrochconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes 安装PyTorch 12conda install pytorch torchvisionconda deactivate # 使用结束后退出虚拟环境 3. 虚拟环境中安装jupyter如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter 1python3 -m pip install jupyter","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Ubuntu","slug":"Computer-Science/Ubuntu","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://fengggggggg.github.io/tags/PyTorch/"},{"name":"MacOS","slug":"MacOS","permalink":"http://fengggggggg.github.io/tags/MacOS/"}]},{"title":"Introduction to Queue","slug":"computer_science/data_structure/Queue","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-03T16:00:00.000Z","comments":true,"path":"2019/03/04/computer_science/data_structure/Queue/","link":"","permalink":"http://fengggggggg.github.io/2019/03/04/computer_science/data_structure/Queue/","excerpt":"A note to queue","text":"A note to queue 1. 循环队列 计算大小为n的循环队列中元素的个数 $(rear - front + n) % n$ $(rear - front + n + 1) % n$ 循环队列判空 $front = rear$ 循环队列判满 $(rear + 1) % n = front $ 出队后头指针front的值 $ front = (front + 1) % m $","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fengggggggg.github.io/tags/Data-Structure/"},{"name":"Queue","slug":"Queue","permalink":"http://fengggggggg.github.io/tags/Queue/"}]},{"title":"Ubuntu 18.10安装LLVM","slug":"computer_science/Linux/LLVM_for_Ubuntu","date":"2018-12-29T16:00:00.000Z","updated":"2018-12-29T16:00:00.000Z","comments":true,"path":"2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","excerpt":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本","text":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本 1.安装cmake安装LLVM需要使用cmake，可以使用如下命令安装: 1sudo apt install cmake 2.修改swap分区(可选，不推荐)从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下： 查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间: 123sudo swapon --showorfree -h 检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值 1df -h 在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。 123sudo swapoff -a # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，sudo fallocate -l 20G /swapfile # 创建swapfilels -lh /swapfile # 验证是否成功创建swapfile， 如果显示-rw——1 root root 20G 日期 /swapfile 则表示创建成功 启用交换文件 12sudo chmod 600 /swapfile # 锁定swapfile权限sudo mkswap /swapfile # 将文件标记为交换空间 若显示:Setting up swapspace…… 则表示成功标记swapfile，标记之后启用该文件 12sudo swapon /swapfile # 启用free -h # 验证 永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留 12sudo cp /etc/fstab /etc/fstab.bak # 备份echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab # 将swap文件信息添加到/etc/fstab文件 3.安装LLVM-8.0 Debug版本 首先去LLVM官网下载必要的软件包; 获取源码: 1234567891011121314151617181920212223# 在适当位置放置LLVM源码，此处放在home下cd ~mkdir tmp# 解压LLVM源码cd tmptar -Jxvg llvm-7.0.0.src.tar.xzmv llvm-7.0.0.src llvm# 解压clang源码(此时在tmp目录下)cd llvm/toolstar -Jxvg cfe-7.0.0.src.tar.xzmv cfe-7.0.0.src clang# 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)cd clang/toolstar -Jxvg clang-tools-extra-7.0.0.src.tar.xzmv clang-tools-extra-7.0.0.src extra# 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)cd ~/tmp/llvm/projectstar -Jxvg compiler-rt-7.0.0.src.tar.xzmv compiler-rt-7.0.0.src compiler-rt 开始安装 123456789101112# 在tmp目录下新建build文件夹cd buildcmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Debug ../llvmmake -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半sudo make install# 将路径添加到环境变量中cd ~vim .bashrcexport PATH=/usr/lib/llvm-7/binexport LD_LIBRARY_PATH=/usr/lib/llvm-7/libsource .bashrc 重启终端并测试 123clang -vclang++ -vclang test.c","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Ubuntu","slug":"Computer-Science/Ubuntu","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Ubuntu/"}],"tags":[{"name":"LLVM","slug":"LLVM","permalink":"http://fengggggggg.github.io/tags/LLVM/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu 18.10安装与配置","slug":"computer_science/Linux/install_ubuntu","date":"2017-06-03T16:00:00.000Z","updated":"2017-06-03T16:00:00.000Z","comments":true,"path":"2017/06/04/computer_science/Linux/install_ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2017/06/04/computer_science/Linux/install_ubuntu/","excerpt":"Ubuntu 18.10安装与配置","text":"Ubuntu 18.10安装与配置 1. 安装Ubuntu 18.10安装过程不多说，安装镜像可以去中科大镜像下载。 2. 安装搜狗输入法 前往搜狗输入法官网下载deb安装文件，双击安装； 前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt； 当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法； 重启系统。 3. 修改软件源应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn 4. 安装Chrome前往Chrome官网下载.deb安装包，双击安装即可。 5. 开启夜览模式夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整： 打开Terminal安装dconf-editor 1sudo apt install dconf-editor 在终端打开dconf-editor 1dconf-editor dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature 关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适 6. 系统美化安装Tweaks工具用以配置桌面 12sudo apt updatesudo apt install gnome-tweak-tool 在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有： Weather In The Clock，点击屏幕上方的时间可以展示天气; Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏； 7. 配置终端 安装zsh与git 12sudo apt install zsh sudo apt install git 安装oh-my-zsh 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 将Shell切换到zsh，登出并重新登入 1chsh -s /bin/zsh 在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题 1ZSH_THEME=\"ys\" 安装一些强大的zsh插件首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令： 1source ~/.oh-my-zsh/plugins/incr/incr*.zsh 同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Ubuntu","slug":"Computer-Science/Ubuntu","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"}]},{"title":"Introduction To Data Structure","slug":"computer_science/data_structure/introduction","date":"2016-09-22T16:00:00.000Z","updated":"2014-09-22T16:00:00.000Z","comments":true,"path":"2016/09/23/computer_science/data_structure/introduction/","link":"","permalink":"http://fengggggggg.github.io/2016/09/23/computer_science/data_structure/introduction/","excerpt":"对常见数据结构的一个简单地总结","text":"对常见数据结构的一个简单地总结 1. 数据结构定义数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成，记为： $Data Structure = (D, R)$ 其中$D$是数据元素的集合，$R$是$D$中元素之间的关系的集合。 通俗的理解，数据结构=逻辑结构(线性、非线性) + 存储结构(顺序、链式、索引、散列) 逻辑结构：数据元素间抽象化的相互关系 存储结构：数据在计算机中的存储形式，也是物理结构 2. 逻辑结构数据的逻辑结构是指数据之间的逻辑关系，比如一对一、一对多、多对一、多对多等。通常，逻辑关系可以分为两种：线性关系和非线性关系。线性关系指：除第一个外，每个元素有且只有一个前驱；除最后一个元素外，每个元素有且只有一个后继。 常见的逻辑结构有以下几种： 集合：数据元素间没有任何关系 线性结构：数据元素间存在线性关系 树：数据元素间有层次关系 图：数据元素间you网状关系 常见的线性结构：线性表、栈、队列、双队列、数组、串等常见的非线性结构：多维数组、树、图、广义表等 3. 存储结构数据的存储结构是指数据在计算机中的存储形式，也是数据的物理结构。 常见的存储结构有以下几种： 顺序存储：逻辑上相邻的节点存储在物理位置上相邻的存储单元中，节点之间的逻辑关系由存储单元的邻接关系体现 优点：可实现对节点的随机存取 缺点：不便于插入、删除，因为要大量移动数据 链式存储：逻辑上相邻的节点在物理存储上不相邻，而是通过指针等体现逻辑关系 优点：便于插入、删除，存储密度比顺序存储小 缺点：不便于查找 索引存储：通过建立索引表来标识节点的地址 散列存储：根据节点的关键字直接计算出节点的存储地址","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fengggggggg.github.io/tags/Data-Structure/"}]},{"title":"Introduction To Computer","slug":"computer_science/computer_basic/introduction","date":"2014-02-22T16:00:00.000Z","updated":"2014-02-22T16:00:00.000Z","comments":true,"path":"2014/02/23/computer_science/computer_basic/introduction/","link":"","permalink":"http://fengggggggg.github.io/2014/02/23/computer_science/computer_basic/introduction/","excerpt":"《计算机组装与维修技术》阅读笔记","text":"《计算机组装与维修技术》阅读笔记 1.计算机及其组成什么是计算机计算机全称电子计算机，俗称电脑、PC等，是一种用于计算的机器，其种类繁多，包括个人计算机、高性能计算机、服务器等。 计算机的组成一个完整的可正常工作的计算机包括硬件和软件两个部分： 1. 计算机硬件硬件是指组成计算机的实体部件，从外观上来看硬件包括：主机、显示器、键盘、鼠标、音响、打印机、扫描仪等，其中主机使整个计算机最重要的组件，一般的，主机都包括: CPU：Central Processing Uint，计算机核心的核心，目前CPU的生产厂商有Intel和AMD两家公司，市场占比大约82开 主板：承担着操控和协调CPU、声卡、显卡等部件的任务 显卡 风扇 电源 网卡 声卡 2. 计算机软件软件是指在硬件上运行的各种程序，例如聊天软件、游戏软件，其中操作系统也是软件的一种，例如Unbuntu、Windows等 2. CPUCPU作为计算机的核心，其性能指标包括以下几种： 主频：即CPU的时钟频率，单位为MHz或GHz，标示CPU的运算速度，CPU的主频=外频x倍频 外频：CPU的总线频率，是由主板为CPU提供的基准时钟频率，单位为MHz，外频决定了主板的运行速度。通常我们在台机中所说的超频，就是指超CPU的外频，大部分CPU外频和主板频率是同步运行的，如果改变外频可能会导致系统不稳定 倍频：CPU主频和外频之间的倍率，一般情况下CPU的倍频是锁定的，有的CPU可以调节倍频 前端总线频率：也称FSB带宽，是CPU与内存间的数据交换的速率，一般数据带宽=(总线频率x数据位宽)/8 缓存：由于CPU和内存处理数据速度不一致，因而引入了缓存，一般而言CPU中有2～3级缓存，L1 Cache是一级缓存，由SRAM组成 3. 主板主板是一块印刷电路板PCB，一般采用4或6层板，4层板包括主板信号层、接地层、电源层、次信号层，6层板多了辅助电源层和中信号层，6层的抗电磁干扰能力更强。一般主板有如下几个组件： 芯片组：芯片组主要由BIOS芯片、南北桥芯片、磁盘阵列RAID、控制芯片等组成 BIOS芯片：BIOS芯片是一块方块型的存储器，里面存有与该主板搭配的基本输入输出系统程序，改程序能够让主板识别各种硬件，以及设置引导系统、调整CPU外频等，BIOS芯片是可写入的。 南北桥：横跨AGP插槽左右两侧的两块芯片就是南北桥芯片。南桥芯片多位于PCI插槽的上方；而CPU插槽旁边，被散热片盖住的则是北桥芯片，一般而言主板的命名都是以北桥的核心名称命名的。北桥芯片主要负责处理CPU、内存、显卡三者之间的交互；南桥负责硬盘等存储设备和PCI之间的数据流通。南北桥合称芯片组。现代的一些高端主机会将南北桥芯片封装到一起。 RAID：控制芯片 总线：总线是主板的重要组成部分，各个部件通过插槽连接到总线上，通常包括：CPU插槽、内存插槽、AGP插槽(用于插AGP显卡，目前逐渐被PCI Express插槽取缔)、PCI插槽(插声卡、网卡等)、CNR插槽(插CNR接口的软Modem或网卡) 对外接口：硬盘接口(一般都是SATA接口)、软驱接口、COM接口(连接串行鼠标和外置Modem等)、PS/2接口(仅用于连接键鼠，目前逐渐被USB接口取代)、USB接口、LPT接口(连接打印机或扫描仪)、MIDI接口(声卡和游戏杆，目前逐渐淘汰)。 4. 内存内存是有内存芯片、电路板、金手指(即内存条边缘的一排金黄色导电触片)等组成，当计算机运行时，CPU就会把运行所需的数据从硬盘中调到内存中，运算完成后再传出，目前市面上流行的内存类型为DDR3和DDR4，DDR即双倍速率同步动态随机存储器Double Data Rate Synchronous Dynamic Random Access Memory的简称，DDR在每个时钟的上升沿和下降沿各传输一次数据 性能指标 内存主频：内存的运行速度 内存容量 CAS延迟：内存读写数据所需的时延 5. 显卡显卡即显示接口卡、显示适配器、显示器配置卡，承担输出图形显示的重要任务。由于显卡的特性，它特别适合处理矩阵运算，因此显卡在现代机器学习中扮演了重要的角色。在机器学习中通常会有大量的矩阵操作，所以可以将这部分操作送给显卡中的GPU去操作。显卡一般分为两种 集成显卡：即芯片组中集成了显卡，这样的芯片组也称为整合型芯片，集显一般没有显存，而是使用内存作为其显存，因此其性能和独显相比较差 独立显卡：显卡成独立的板卡，通常有自己的显存 显卡的基本结构如下： GPU:图形处理芯片 显存 显卡BIOS:驱动程序之间的控制程序,存有显卡的型号、规格、生产厂家及出场时间等 输出接口 显卡PCB板 性能指标 显卡频率：显卡的工作频率，通常越高越好 显存位宽：一个时钟周期内所能传送数据的位数，市场上主流的有128位、256位、320位等 显存在显卡上工作时的频率 显存容量：主流的是256MB和512MB 3D API：显卡与应用程序之间的接口 6. 声卡声卡是实现模拟信号/数字信号相互转换的一种硬件，一般分为板卡式(目前已被淘汰)、集成式(主流)和外置式三种，声卡的基本构成有： 声音控制芯片：可通过数模转换器将模拟信号转换成数字信号，或反过来 DSP：执行和声音处理有关的命令、执行压缩解压缩程序、增加特殊声效和传真Modem等，高档声卡一般配有DSP CODEC：编解码器 输入输出接口 跳线：用于设置声卡的硬件设备，包括CD-ROM的I/O地址、声卡的I/O地址设置。 性能指标 采样频率：每秒从连续信号中采样出离散信号的个数，单位Hz。通俗地讲是指计算机美妙采集多少个声音样本 采样位数：即采样值或取样值，用来衡量声音波动变化的参数，含义是声卡在采集和播放声音文件时所使用数字声音信号的二进制位数 信噪比SNR：放大器的输出信号的电压与同时输出的噪声电压的比例，单位分贝，一般信噪比越高，说明信号李的噪声越小，声音质量越高 频率响应：系统或计量传感器的阻抗随频率的变化 7. 硬盘硬盘是计算机中的存储器件，一般的机械硬盘由一个或多个铝制或玻璃制的碟片组成，碟片外覆盖有铁磁性材料。传统的机械硬盘其内部构造包括： 磁头：负责对磁盘进行读写，与磁盘表面的磁性物质发生作用，一般有MR磁头和GMR磁头，硬盘里的磁头数=磁盘盘体数x2 盘体：存储数据的主体，有一或多个盘片叠在一起组成，盘体有以下几个概念： 磁道：一个盘片的一个面上的一个同心圆成为一个磁道，一般内侧磁道和外侧磁道存储量不同 扇区：每个磁道都被分为若干个弧段，这些弧段就是扇区，每个扇区可以存放512字节的信息，磁盘读写数据以扇区为单位 柱面：每个盘面上相同位置的磁道组成一个柱面，硬盘容量=柱面数x磁头数x扇区数x512B 主轴电机：用于驱动盘体转动的设备，主流的为7200转/分钟 寻道电机、驱动臂：寻道电机带动磁头在盘体上寻道，驱动臂把磁头和寻道电机连接在一起 性能指标 容量 转速：单位为转/分钟或RPM，转的越快，其传输率越高，发热量越大 平均访问时间：磁头从起始位置找到需要读写的数据位置的时间，体现了硬盘的读写速度。一般包括了平均寻道时间和平均等待时间，平均寻道时间是指磁头移动到指定磁道所需的时间，平均等待时间磁头已经在目标磁道，等待所需访问的扇区转至磁头下方所需时间 传输速率：包括内部传输速率和外部传输速率，内部传输速率指未用硬盘缓冲区时的性能，外部传输速率是系统总线与硬盘缓冲区之间的传输速率 缓存：硬盘也有缓存，是硬盘控制器上的一块内存芯片 固态硬盘SSD是一种新型的硬盘，由固态电子存储芯片阵列组成，其存储介质一般有闪存(FLASH)和DRAM两种，和传统硬盘比，SSD有读写速度快、低功耗、无噪声、体积小等优点，也有造价高、使用寿命短的缺点。关于SSD的使用寿命，也就是SSD擦写次数限制，闪存完全擦写一次叫做一次P/E，因此闪存的寿命以P/E为单位，一般34nm的闪存寿命为5000P/E，25nm的为3000P/E。不过由于SSD固件算法升级，SSD能提供更少的不必要写入量。 举个例子，一款128G的SSD，要写入128G的文件才算做一次P/E，即使每天写入50G的内容，2.5天才能完成一次P/E，一年也才用去150次左右的P/E，一块3000P/E的SSD够用200年了。 8. BIOS和CMOSBIOS是基本输入输出系统。启动计算机时，CPU首先根据集成在主板、显卡等设备上的BIOS芯片来核对每个基础设备是否正常，然后从硬盘中拷贝操作系统到内存中。BIOS有3个基本功能： 自检及初始化：开机后BIOS最先被启动，然后BIOS会检查计算机硬件设备，若设备正常才会启动操作系统 程序服务：BIOS直接与计算机的I/O设备交互，实现软件程序对硬件的直接操作 设定中断 CMOS是指互补金属氧化物半导体，是计算机主板上的一块可读写的RAM芯片，用来保存当前系统的硬件配置和用户对某些参数的设定。CMOS由主板的可充电电池供电，即使系统断电CMOS中的信息也不会丢失。 通常计算机中的开机密码存储在CMOS中，当忘记密码时，可以抠下主板上的电池，将CMOS放电，放电后CMOS内容会被清空，因而密码也会被清除。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Basic","slug":"Computer-Science/Computer-Basic","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Basic/"}],"tags":[{"name":"PC","slug":"PC","permalink":"http://fengggggggg.github.io/tags/PC/"}]}]}
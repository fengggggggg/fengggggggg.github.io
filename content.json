{"meta":{"title":"Simita","subtitle":null,"description":null,"author":"Simita","url":"http://fengggggggg.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-12T15:58:04.156Z","updated":"2019-08-12T15:58:04.156Z","comments":true,"path":"404.html","permalink":"http://fengggggggg.github.io/404.html","excerpt":"","text":"404 Not Found 这里是我的知识盲区"},{"title":"","date":"2019-06-28T15:23:09.839Z","updated":"2019-06-28T15:23:09.839Z","comments":true,"path":"mylist/index.html","permalink":"http://fengggggggg.github.io/mylist/index.html","excerpt":"","text":""},{"title":"ALL CATEGORIES","date":"2019-06-28T15:35:37.852Z","updated":"2019-06-28T15:35:37.852Z","comments":true,"path":"categories/index.html","permalink":"http://fengggggggg.github.io/categories/index.html","excerpt":"","text":""},{"title":"ALL TAGS","date":"2019-06-28T15:35:48.311Z","updated":"2019-06-28T15:35:48.311Z","comments":true,"path":"tags/index.html","permalink":"http://fengggggggg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Obfuscation with Mixed Boolean-Arithmetic","slug":"computer_science/Paper/Obfuscation with Mixed Boolean-Arithmetic","date":"2019-09-16T05:00:00.000Z","updated":"2019-09-16T05:00:00.000Z","comments":true,"path":"2019/09/16/computer_science/Paper/Obfuscation with Mixed Boolean-Arithmetic/","link":"","permalink":"http://fengggggggg.github.io/2019/09/16/computer_science/Paper/Obfuscation with Mixed Boolean-Arithmetic/","excerpt":"论文翻译及整理论文作者: Ninon Eyrolles","text":"论文翻译及整理论文作者: Ninon Eyrolles Introduction软件保护的目的：保护程序免受不必要的分析；软件保护的原因：保护知识产权、防止未授权访问等；软件保护的关键：多样性，程序分析通常基于模式识别，这意味着当一段代码与其语义相关联时，它可以在程序的其他位置，甚至在其他程序中识别出来。此外，生成相同软件的多种实例(即程序代码不同但功能相同)可以降低分析的可复现性。 程序混淆是指对代码进行转换使程序变的难以理解。多样性旨在降低对不同实例的分析的可重复性，而程序混淆旨在使一个特定实例的分析尽可能复杂。混淆以两种主要方式隐藏软件的语义：1.改变code和data(例如，改变数据的值)，2.添加无关信息(例如垃圾代码)。本文研究的混淆技术使用上述两种方法来混淆常见的数学表达式。使用混合布尔算术(Mixed Boolean-Arithmetic, MBA)表达式重写转换操作符，并在混淆过程中添加无用的运算符和常量。同时本文也着重研究了MBA反渗透和MBA反混淆。 文章贡献在这项工作中作者解决了如下几个问题： 提供先进的MBA混淆技术：该领域比较年轻，相关文献很少。本文从公共混淆的例子中重建了MBA混淆技术。 阐述了混淆表达式的简化定义：本文分析了反混淆的难点，并定义了MBA表达式简单度量。 生成反混淆(简化)算法：提供用于分析和自动化逆转混淆技术的开源工具。 评估针对表达式和常量的MBA混淆技术的健壮性：本文将健壮性定义为对混淆表达式进行反混淆的难度。 提供新想法提高健壮性：我们使用一般反混淆效技术以及我们的简化算法提出了几个想法，用于提高MBA混淆技术的整体健壮性。 1. 背景1.1 软件混淆1.1.1 定义混淆是对程序的动态转换行为，其目的是使程序的分析变的困难，同时保证程序的可观察性。混淆通常有三个属性： 功能：混淆后的程序必须具有与原始程序相同的功能； 效率：与原始程序相比，混淆后的程序的大小和执行时间必须是可接受的。 健壮性：混淆程序必须比原始程序更难分析。 1.1.2 应用软件混淆应用领域包括软件加密、打包、反调试或防篡改等。混淆存在于软件的上下文中，这意味着分析者具有该程序的实例并以及该程序的执行的环境—-在白盒设计领域，它被称为白盒攻击上下文。分析已完成并分发的产品的过程称为逆向工程，其目的是理解程序的特征，从而描述程序的形式、算法、协议或在开发中的错误。这里，这些描述可以用伪代码、带输入和参数的标准算法的名称、源代码描述(反编译)等表示。程序的逆向工程通常被认为是混淆的逆向实践，该技术在1.3节中介绍。 软件分析的目的有很多：非授权使用软件、提取秘密或专有信息、重新分发、出于安全目的的分析或互操作性。混淆一般在以下领域提供针对逆向工程的保护： 恶意软件：混淆变换会造成混淆和多态，从而允许恶意软件避免反病毒引擎自动签名检测。此外，混淆还会减慢反向工程师分析恶意软件以进行进一步检测或调查的工作。 保护知识产权：混淆可以保护商业软件中包含的算法或协议，例如Skype、DropBox。 权限管理：无论是通过许可检查来保护对软件的访问，还是通过数字版权管理(DRM)方案保护数字内容，这些技术通常都会嵌入关键信息(例如加密密钥和协议)，并且使用混淆来保护这些信息。嵌入在程序中的DRM方案(例如VOD服务或视频游戏保护)目前是现代环境中混淆的主要来源之一。 保护个人或敏感数据：例如，在移动应用程序中，设备中保存了大量敏感数据(例如银行帐户详细信息)。混淆可以帮助保护这些数据以及处理它的协议。 1.2 理论混淆和实际混淆理论混淆又被称为密码混淆，实际混淆即商用解决方案。 1.2.1 密码混淆密码混淆旨在为混淆提供一个正式的上下文，特别是围绕量化分析给定程序$P$的混淆程序$\\mathcal O(P)$的难度。 软件混淆的正式研究由Barak等人发起，他们引入了虚拟黑匣子(VBB)的概念作为混淆程序的最佳属性。VBB保证任何可以从程序$\\mathcal O(P)$的输入/输出行为中学到的，从$P$中也可以学到。 Barak提出了不可区分混淆的定义：如果两个相同大小的程序P1和P2实现相同的功能，则它们的混淆$\\mathcal O(P_1)$和$\\mathcal O(P_2)$应无法区分。 Goldwasser等人提供了最佳可能混淆的定义：从$\\mathcal O(P)$中提取的任何信息都可以通过类似大小的其他功能相同的的程序取得。 他们还证明，对于有效的混淆器，不可区分混淆和最佳混淆是等价的。 2013年，Garg等人提出了通用的不可区分混淆，该混淆基于三个组成部分：作为计算模型的分支程序，完全同态加密和多线性映射。 1.2.2 实际混淆密码混淆在实际上难以应用，因此商用混淆一般都是基于不同程序转换的组合。一些最常用的商业混淆器是strong.protect和Arxan3。混淆器可以将其技术应用于程序的不同表示，主要是源代码，中间表示(IR)或汇编语言。混淆器设计者的主要问题是在混淆带来的保护和性能下降(在内存、执行时间等方面)之间找到正确的权衡。 源代码在源代码上操作的obfuscator混淆器被称为source-to-source obfuscator，并且允许使用利用输入编程语言的特定性的混淆技术。因为混淆步骤是在编译之前进行的，因此它也更容易集成到现有的编译链中。源到源的混淆也可以用于解释性语言。这种方法的主要缺点是它将自己限制为一种编程语言。 中间代码中间代码IR被编译器、虚拟机或逆向工程框架等用来表示代码。它旨在独立于任何源语言或目标语言。因此，在IR级别上工作的混淆器比源到源混淆器更通用，并且能够处理来自各种源语言和目标汇编语言的程序，但同时该类混淆器集成更加困难，因为它需要将混淆器添加到现有的编译工具链中。 汇编语言与IR和源码相比，汇编级混淆器会导致大量信息的丢失，因此很难实现仅在汇编时工作的通用混淆器。但是，虚拟化保护技术可以直接应用于二进制程序，受保护的代码在与标准CPU不同的虚拟CPU上运行。实现虚拟化的商业混淆器的一个示例是VMProtect。除了虚拟化之外，在汇编语言上操作的变换通常属于较大的软件保护领域，更具体地说，涉及防篡改(例如完整性检查)或打包(例如程序的加密)。 1.3 程序分析2. 已有工作3. MBA复杂性4. MBA混淆技术分析5. MBA混淆技术的健壮性结论","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"}],"tags":[{"name":"Software Obfuscation","slug":"Software-Obfuscation","permalink":"http://fengggggggg.github.io/tags/Software-Obfuscation/"}]},{"title":"《周恩来传》时间线整理","slug":"Books/a biography of zhou en-lai","date":"2019-09-16T04:00:00.000Z","updated":"2019-09-16T04:00:00.000Z","comments":true,"path":"2019/09/16/Books/a biography of zhou en-lai/","link":"","permalink":"http://fengggggggg.github.io/2019/09/16/Books/a biography of zhou en-lai/","excerpt":"周恩来传时间线整理","text":"周恩来传时间线整理 1. 求索童年(1898~1913) A.D. REMARKS 1898.03.05 周恩来出生于淮安，并被过继给叔父周贻淦(gan)，并由叔母陈三姑养育到5岁 1907 生母万冬儿因病去世 1910年春 12岁的周远赴铁岭、沈阳等地投奔伯父，不久后在奉天入读东关模范学校 1913年 15岁的周于东关模范学校毕业 求学天津(1913~1917) A.D. REMARKS 1913年 周随四伯父周贻赓来到天津，入读南开中学 1914年初 和朋友建立课外学习社团敬业乐群会，创刊《敬业》 1914年 在《敬业》上开始诗作 1916年5月 发表《诚能动物论》 1917.06.26 于南开中学毕业，学习十分优异，文科全校第一，立刻名列前茅 春日偶成•其一极目青郊外，烟霾布正浓。中原方逐鹿，博浪踵相踪。 春日偶成•其二樱花红陌上，柳叶绿池边。燕子声声里，相思有一年。 东渡日本(1917~1919) A.D. REMARKS 1917年9月 在朋友的邀请下赴日求学 1919年 因凡尔赛条约及五四运动，毅然返国 周在日本的两年内，没有学到新的知识。但在此期间，周接触到了马克思主义与社会主义。 身陷囹圄(1919~1920) A.D. REMARKS 1919.09.16 创建觉悟社，办《觉悟》杂志 1919.09.25 入读南开大学，任《天津学生联合会报》编辑 1919.01.20 在《觉悟》上发表短诗《死人的享福》 1920.01.29 周等因抗议被捕入狱 1920年7月 释放周等学生代表 2. 奋斗3. 开国总理","categories":[{"name":"Books","slug":"Books","permalink":"http://fengggggggg.github.io/categories/Books/"}],"tags":[{"name":"Biography","slug":"Biography","permalink":"http://fengggggggg.github.io/tags/Biography/"}]},{"title":"使用conda管理Python虚拟环境","slug":"computer_science/Linux/python_virtualenv_conda","date":"2019-09-08T16:00:00.000Z","updated":"2019-09-08T16:00:00.000Z","comments":true,"path":"2019/09/09/computer_science/Linux/python_virtualenv_conda/","link":"","permalink":"http://fengggggggg.github.io/2019/09/09/computer_science/Linux/python_virtualenv_conda/","excerpt":"使用conda管理Python虚拟环境","text":"使用conda管理Python虚拟环境 1. 安装Anaconda可以在Anaconda官网下载相应Python版本的软件 2. 创建Python虚拟环境1conda create -n virtual_env_name python=x.x 3. 激活/关闭虚拟环境1234# 激活source activate virtual_env_name# 关闭source deactivate 4. 为相应的虚拟环境安装包1conda install -n virtual_env_name [package] 5. 删除虚拟环境1conda remove --name virtual_env_name 6. 常用conda命令1conda env list # 列出所有已创建的虚拟环境","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Conda","slug":"Conda","permalink":"http://fengggggggg.github.io/tags/Conda/"},{"name":"Python","slug":"Python","permalink":"http://fengggggggg.github.io/tags/Python/"}]},{"title":"Install Syntia with Ubuntu 18.04","slug":"computer_science/Linux/syntia_install","date":"2019-09-08T16:00:00.000Z","updated":"2019-09-08T16:00:00.000Z","comments":true,"path":"2019/09/09/computer_science/Linux/syntia_install/","link":"","permalink":"http://fengggggggg.github.io/2019/09/09/computer_science/Linux/syntia_install/","excerpt":"Ubuntu下安装syntia","text":"Ubuntu下安装syntia 1. 下载源码1git clone https://github.com/RUB-SysSec/syntia 2. 安装第三方Python库Syntiasyntia是一个第三方Python库，使用的是Python2。为了避免Python版本紊乱，可以使用conda创建一个Python2.7的虚拟环境，在该环境中安装syntia。在下载的源码中有setup.py文件，使用下面命令可以安装该Python库： 1python setup.py install 3. 安装依赖软件依赖软件包含在install_deps.sh脚本文件中，原则上可以通过执行该脚本文件来安装4个依赖，但是实际操作却总是报错。因此我使用手动安装 3.1 安装Unicorn12345678910111213# 使用git下载源码git clone https://github.com/unicorn-engine/unicorn.gitcd unicorn# compile./make.sh# installsudo ./make.sh install# 验证，命令执行后出现success，可认为是安装成功了./samples/sample_all.sh 3.2 安装Capstone12345678910111213# 使用git下载源码git clone https://github.com/aquynh/capstone.gitcd capstone# compile./make.sh# installsudo ./make.sh install# 验证，我也不清楚验证结果是什么样代表正确安装./tests/test* 3.3 安装Miasm1234567891011121314151617181920212223# 1. 安装额外Python依赖库# 使用git下载源码git clone https://github.com/serpilliere/elfesteem.git elfesteemcd elfesteempython setup.py buildpython setup.py install# 2. 安装miasmcd ..# 使用git下载源码git clone https://github.com/cea-sec/miasm.gitcd miasmpython setup.py buildpython setup.py install# 验证# 可以通过在Python编程环境中import miasm来验证，若不报错则说明成功安装 3.4 安装Z31234567891011# 使用git下载源码git clone https://github.com/Z3Prover/z3.gitcd z3python scripts/mk_make.py --pythoncd buildmakemake install # 该语句执行后会打印 Z3 was successfully installed.","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Syntia","slug":"Syntia","permalink":"http://fengggggggg.github.io/tags/Syntia/"}]},{"title":"熵权法","slug":"mathematics/entropy_weight_method","date":"2019-09-04T16:00:00.000Z","updated":"2019-09-04T16:00:00.000Z","comments":true,"path":"2019/09/05/mathematics/entropy_weight_method/","link":"","permalink":"http://fengggggggg.github.io/2019/09/05/mathematics/entropy_weight_method/","excerpt":"熵权法计算权值，Python3实现","text":"熵权法计算权值，Python3实现 1. 输入矩阵假设计算矩阵为：$x=[[1,2,2],[2,1,1]]$ 2. 极差标准化评价指标分为正指标和逆指标，计算公式如下 $$x_{ij}’=\\frac{x_{ij} - \\min_{j=1}^n x_{ij}}{\\max_{j=1}^n x_{ij} - \\min_{j=1}^n x_{ij}}$$ 此处仅展示正指标计算公式。将所有指标都视为正指标，标准化后的$x=[[0,1,1],[1,0,0]]$，可以使用scikit learn库中的MinMaxScaler()方法对数据进行最大最小归一化。 3. 计算指标信息熵信息熵是一个对象所能提供的信息量大小的量化指标，其范围在$(0,1)$之间。 $e$应当为$1*n$大小的矩阵，式中$e_j$代表第$j$项指标的信息熵，信息熵的计算公式为：$$e_j = (-\\frac{1}{\\ln m})\\sum_{i=1}^m (p_{ij} \\cdot \\ln p_{ij})$$其中$p_{ij}$为第$j$个指标的状态为$i$时的概率，即$$p_{ij}= \\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}}$$因此$$e_j = (-\\frac{1}{\\ln m})\\sum_{i=1}^m (\\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}} \\cdot \\ln(\\frac{x_{ij}}{\\sum_{i=1}^m x_{ij}}))$$应用到上述矩阵，可以得到$e=[0.9183, 0.9183, 0.9183]$即 指标名称 信息熵 指标1 0.9183 指标2 0.9183 指标3 0.9183 4.计算指标权重$w$应当为$1*n$大小的矩阵，式中$w_j$代表第$j$项指标的权重$$w_j = \\frac{1 - e_j}{\\sum_{j=1}^n (1-e_j)}$$应用到上述$e$，可以得到$w=[0.33, 0.33, 0.33]$，即 指标名称 权重 指标1 0.33 指标2 0.33 指标3 0.33 5. Coding12345678910111213141516171819202122# language = python3import mathimport numpy as npimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfile = \"test.csv\"data = pd.read_csv(file, header = None)x = data.values.astype(np.float64)x_std = MinMaxScaler().fit_transform(x)def Entropy_Weight(data): m, n = np.shape(data) p = data / data.sum(axis = 0) p[np.where(data == 0)] = 0.01 e = (-1.0 / np.log(m)) * np.nan_to_num(np.sum(p * np.log(p), axis = 0)) w = (1 - e) / np.sum(1 - e) return ww = Entropy_Weight(x_std)","categories":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://fengggggggg.github.io/categories/Mathematics/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://fengggggggg.github.io/tags/Mathematics/"}]},{"title":"字节跳动2020校招笔试题","slug":"computer_science/Algorithm/xor1","date":"2019-08-11T13:12:00.000Z","updated":"2019-08-11T13:12:00.000Z","comments":true,"path":"2019/08/11/computer_science/Algorithm/xor1/","link":"","permalink":"http://fengggggggg.github.io/2019/08/11/computer_science/Algorithm/xor1/","excerpt":"字节跳动2020校招笔试真题","text":"字节跳动2020校招笔试真题 1. 第二题对于给定的一串0/1串，我们给定一种加密方式： 将字符串右移K-1次，每次右移一位，随后将这K串0/1串异或，得到的结果就是密文。 例如： 1234K = 2原始明文 = 101111右移一次 = 101111加密密文 = 1110001 现给出加密后的密文、原文的长度以及K，求原文。 2. 第三题第三题其实就是LeetCode第135题。 题目描述 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？ 解法 使用一个数组C用来保存最终每个孩子分到的糖果数，先将数组C初始化为全1，表示每个孩子至少分到一个糖果。 随后从左边第1个元素开始向右遍历，如果当前孩子评分比前一个高，则该孩子分到的糖果比前一个孩子多1个，否则还是1个。 最后从右边第1个元素向左遍历，如果当前孩子比后一个评分高，如果当前孩子已有的糖果数比后一个孩子多，则不变，否则比后一个孩子多分一个糖果；如果当前孩子比后一个孩子评分低，则当前孩子分的糖果数不变 1234567891011121314151617class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); vector&lt;int&gt; candy(n, 1); if (n &lt; 1) return 0; for (int i = 1; i &lt; n; ++i) candy[i] = (ratings[i] &gt; ratings[i - 1] ? (candy[i - 1] + 1): candy[i]); for (int i = n - 2; i &gt;= 0; --i) candy[i] = (ratings[i] &gt; ratings[i + 1]) ? max(candy[i + 1] + 1, candy[i]) : candy[i]; int count = 0; for (int i = 0; i &lt; n; ++i) count += candy[i]; return count; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://fengggggggg.github.io/tags/Algorithm/"}]},{"title":"C++11/14/17新特性简单总结","slug":"computer_science/C&C++/C++14新特性","date":"2019-08-11T02:12:00.000Z","updated":"2019-08-11T02:12:00.000Z","comments":true,"path":"2019/08/11/computer_science/C&C++/C++14新特性/","link":"","permalink":"http://fengggggggg.github.io/2019/08/11/computer_science/C&C++/C++14新特性/","excerpt":"C++11/14/17新特性简单总结","text":"C++11/14/17新特性简单总结 1. C++11新特性包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进 1. auto关键字C++11中引入auto第一种作用是为了自动类型推导，auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作。需要注意的是，使用auto声明一个变量时，必须对其进行初始化，因为auto是通过初始化表达式进行类型推导的。 2. decltype关键字decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型 3. nullptrnullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0 4. 序列for循环在C++中for循环可以使用类似python的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator） 5. Lambda表达式lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下： 1[函数对象参数]（操作符重载函数参数）-&gt;返回值类型&#123;函数体&#125; 6. 其他。。。2. C++14新特性C++14的新特性主要分为三个领域：Lambda函数、constexpr和类型推导。 函数返回类型auto lambda参数auto lambda捕获参数初始化 [[deprecated]] 二进制常量0b/0B 单引号分位符0b1111’0000 模板变量 3. C++17新特性 结构化绑定auto [a, b]构造函数模板推导std::pair{1, 5.0} inline变量 if constexpr fold表达式 非类型模板参数auto satic_assert自定义错误信息 typename代替class声明模板的模板参数 嵌套命名空间namespace X::Y {…} 新增加属性[[fallthrough]] [[maybe_unused]] [[nodiscard]] if/switch初始化 string_view variant/any/optional void_t container.extract 删除trigraphs（即三连字符??*)","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"C++中结构体和类的区别","slug":"computer_science/C&C++/different_between_struct_and_class","date":"2019-08-09T16:00:00.000Z","updated":"2019-08-09T16:00:00.000Z","comments":true,"path":"2019/08/10/computer_science/C&C++/different_between_struct_and_class/","link":"","permalink":"http://fengggggggg.github.io/2019/08/10/computer_science/C&C++/different_between_struct_and_class/","excerpt":"C++中结构体和类的区别","text":"C++中结构体和类的区别 1. C和C++中struct的不同 C中的结构体只能定义成员变量，不能定义成员函数，C++可以； C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性； C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1; C++中之所以要引入结构体，是为了保持和C程序的兼容性。C++中不使用结构体丝毫不会影响程序的表达能力，但有时仍会在C++中使用结构体，这是因为使用结构体将不同类型数据组成整体便于保存数据。（若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦。） 2. C++中struct和class的不同C++中struct和class唯一的不同是struct和class具有不同的默认访问控制属性，class中的成员的默认控制访问属性为private，而struct中的默认访问控制属性为public。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"常见排序算法总结与比较","slug":"computer_science/Algorithm/sort","date":"2019-08-07T16:00:00.000Z","updated":"2019-08-07T16:00:00.000Z","comments":true,"path":"2019/08/08/computer_science/Algorithm/sort/","link":"","permalink":"http://fengggggggg.github.io/2019/08/08/computer_science/Algorithm/sort/","excerpt":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。","text":"本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。 1. 总体比较时间复杂度与稳定性 类别 名称 平均复杂度 最好情况 最差情况 空间复杂度 稳定性 交换比较类 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 交换比较类 快速排序 $O(nlogn)$ $O(n^2)$ $O(n^2)$ $O(logn)$ 不稳定 选择类 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 选择类 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 插入类 直接插入 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 插入类 二分排序 $O(n^2)$ $O(nlogn)$ $O(n^2)$ – 稳定 插入类 希尔排序 $O(nlogn)$ $O(n)$ $O(n^s)1$ $O(1)$ 不稳定 其他 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 其他 基数排序 $O(log_R B)$ – $O(log_R B)$ $O(n)$ 稳定 其他 二叉排序 $O(nlogn)$ – $O(nlogn)$ $O(n)$ 稳定 其他 计数排序 $O(n+k)$ – $O(n+k)$ $O(k)$ 稳定 其他 拓扑排序 $O(n+e)$ – – $O(n)$ – 其他 枚举排序 $O(n^2)$ – – – – 算法特性 名称 时间复杂度与初序 移动次数与初序 比较次数与初序 排序趟数与初序 每趟确定最终位置 冒泡排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 快速排序 ⭕️ ⭕️ ⭕️ ⭕️ ⭕️ 选择排序 ❌ ❌ ❌ ❌ - 堆排序 ❌ ❌ ❌ - ⭕️ 直接插入 ⭕️ ⭕️ ⭕️ ❌ ❌ 二分排序 - - ❌ - - 希尔排序 ⭕️ - ⭕️ - ❌ 归并排序 ❌ ❌ ⭕️ - - 基数排序 ❌ ❌ ❌ - - 二叉排序 ⭕️ - - - - 计数排序 ⭕️ - - - - 拓扑排序 - - - - - 枚举排序 - - - - - 2. 冒泡排序冒泡排序是一种典型的交换排序算法，相邻两数两两⽐比较并交换，直到所有数据排序完成，每一趟排序总能够将无序队列中的最⼤/小置于队尾。适用情况: 待排序列列较小时性能较优。最坏情况: 初始序列基本有序但顺序相反最好情况: 初始序列列基本有序(没有插⼊快，因为要两两比较)应用: 对基本有序序列查前n个元素 12345678void BubbleSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) for (int j = 0; j &lt; array.size() - i; j++) if (array[j] &gt; array[j + 1]) swap(array[j + 1], array[j]);&#125; 3. 选择排序反复选择未排序序列中最大或最小元素，并将其放于已排序序列尾部，直到未排序序列长度为0 1234567891011void SelectSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 0; i &lt; array.size(); i++) &#123; int minIndex = i; for (int j = i; j &lt; array.size(); j++) if (array[j] &lt; array[minIndex]) minIndex = j; swap(array[i], array[minIndex]); &#125;&#125; 4. 直接插入排序将数据分为有序和无序两部分，首先有序部分为空，依次从无序部分中拿出元素插入到有序序列中可能出现情况: 最后一趟开始前，所有元素都不在正确位置上最佳情况: 基本有序下，插⼊排序是最快的 123456789101112void InsertionSort(vector&lt;int&gt;&amp; array) &#123; if (array.size() &lt;= 1) return; for (int i = 1; i &lt; array.size(); i++) &#123; int temp = array[i], j = i; while (j &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = temp; &#125;&#125; 5. 归并排序n越⼤大越好优点: 当待排序列列较大，内存一次性放不不下时，需要外部排序，通常使用归并排序归并趟数: m个元素k路归并趟数$s = log_k m$ 12345678910111213141516171819202122232425262728293031void MergeSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return MergeSort(array, left, right);&#125;void Merge(vector&lt;int&gt;&amp; array, int l1, int r1, int l2, int r2) &#123; int i = l1, j = l2; vector&lt;int&gt; temp(array.size()); int index = 0; while (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123; if (array[i] &lt;= array[j]) temp[index++] = array[i++]; else temp[index++] = array[j++]; &#125; while (i &lt;= r1) temp[index++] = array[i++]; while (j &lt;= r2) temp[index++] = array[j++]; for (int i = 0; i &lt; index; i++) array[l1 + i] = temp[i];&#125;void MergeSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; MergeSort(array, left, mid); MergeSort(array, mid + 1, right); Merge(array, left, mid, mid + 1, right); &#125;&#125; 6. 快速排序分治法优点: 平均最快，平均比较次数最少最好情况: 每次能够均匀划分最坏情况: 序列有序，或不均匀划分优化: 快排需要使用递归，因此处理左右子段时，先处理短子段可以减少时间复杂度。先处理短⼦段的话，每次递归深度都是短⼦段的长度对排序对象的要求: 待排序列的存储方式是顺序存储 1234567891011121314151617181920212223242526void QuickSort(vector&lt;int&gt;&amp; array) &#123; int left = 0, right = (int)array.size() - 1; return QuickSort(array, left, right);&#125;int Partition(vector&lt;int&gt;&amp; array, int left, int right) &#123; int temp = array[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[right] &gt; temp) right--; array[left] = array[right]; while (left &lt; right &amp;&amp; array[left] &lt; temp) left++; array[right] = array[left]; &#125; array[left] = temp; return left;&#125;void QuickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int pos = Partition(array, left, right); QuickSort(array, left, pos - 1); QuickSort(array, pos + 1, right); &#125;&#125;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Algorithm/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://fengggggggg.github.io/tags/Sort/"}]},{"title":"LeetCode 探索初级算法 字符串","slug":"computer_science/LeetCode/Primary_Algorithm_String","date":"2019-08-06T16:00:00.000Z","updated":"2019-08-06T16:00:00.000Z","comments":true,"path":"2019/08/07/computer_science/LeetCode/Primary_Algorithm_String/","link":"","permalink":"http://fengggggggg.github.io/2019/08/07/computer_science/LeetCode/Primary_Algorithm_String/","excerpt":"反转字符串 整数反转 字符串中的第一个唯一字符 有效的字母异位词 验证回文字符串 字符串转换整数(atoi) 实现strStr() 报数 最长公共前缀","text":"反转字符串 整数反转 字符串中的第一个唯一字符 有效的字母异位词 验证回文字符串 字符串转换整数(atoi) 实现strStr() 报数 最长公共前缀 1. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。 示例 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 解法1：双指针法设置双指针i、j分别指向头尾，交换头尾后各向中间进1. 1234567891011class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; swap(s[i], s[j]); i++; j--; &#125; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 解法2：reverse函数直接使用reverse()函数 123456class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; reverse(s.begin(), s.end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 2. 整数反转给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 12输入: 123输出: 321 解法：模拟栈每次对x取%10余，并将余数×10累加到res中 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; int res = 0, cur; while (x != 0) &#123; cur = x % 10; x /= 10; if (res &gt; INT_MAX/10 || (res == INT_MAX / 10 &amp;&amp; cur &gt; 7)) return 0; if (res &lt; INT_MIN/10 || (res == INT_MIN / 10 &amp;&amp; cur &lt; -8)) return 0; res = res * 10 + cur; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：$O(log(x))$ 空间复杂度：$O(1)$ 3. 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1 示例 12345s = &quot;leetcode&quot;返回0.s = &quot;loveleetcode&quot;,返回2. 解法：hash表使用map保存字符-位置键对，且这一键对的值为该字符出现的次数。随后从头按字符出现的次序遍历map，第一个键值为1的便是解。 123456789101112131415161718class Solution &#123;public: int firstUniqChar(string s) &#123; unordered_map&lt;char,int&gt; hash; for (auto i : s) &#123; hash[i]++; &#125; for (int i = 0; i &lt; s.size(); ++i) if (hash[s[i]] == 1) return i; return -1; &#125;&#125;;**复杂度分析**- 时间复杂度：$O(n)$- 空间复杂度：$O(n)$ 4. 有效的字母异位词给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。 示例1 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例2 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 示例3 12输入: s = &quot;aacc&quot;, t = &quot;ccac&quot;输出: false 解法：hash表使用26大小的数组作为hash表，同时遍历s和t，并在对应位分别++和–。最后再遍历一遍hash表，如果存在不为0的元素，则说明s和t字符不对应，即不是异位词 12345678910111213141516class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.size() != t.size()) return false; int count[26] = &#123;0&#125;; for (int i = 0; i &lt; s.size(); ++i) &#123; count[s[i] - 'a']++; count[t[i] - 'a']--; &#125; for (auto i : count) if (i != 0) return false; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 5. 验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写 示例1 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例2 12输入: &quot;race a car&quot;输出: false 解法：双指针法利用双指针分别从头和尾进行比较，两个关键函数：isalnum()判断是否为字母数字，以及tolower()转换成小写字母 123456789101112131415class Solution &#123;public: bool isPalindrome(string s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; !isalnum(s[i])) i++; while (i &lt; j &amp;&amp; !isalnum(s[j])) j--; if (tolower(s[i++]) != tolower(s[j--])) return false; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 6. 字符串转换整数(atoi)请你来实现一个atoi函数，使其能将字符串转换成整数。 解法这题实在是太麻烦了，各种意想不到的输入都需要考虑到，因此这里提供一个懒人方法，使用sstream库。 123456789class Solution &#123;public: int myAtoi(string str) &#123; int digit = 0; istringstream is(str); is &gt;&gt; digit; return digit; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 7. 实现strStr()给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置(从0开始)。如果不存在，则返回-1 示例 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 解法1：暴力求解从头至尾遍历一遍 12345678class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if needle == \"\": return 0 for i in range(len(haystack)) : if needle == haystack[i : i + len(needle)]: return i return -1 复杂度分析 时间复杂度：$O(nm)$ 空间复杂度：$O(1)$ 解法2：KMP算法123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; getnext(string str) &#123; int len=str.size(); vector&lt;int&gt; next; next.push_back(-1);//next数组初值为-1 int j=0,k=-1; while(j&lt;len-1) &#123; if(k==-1||str[j]==str[k]) &#123; j++; k++; if(str[j]!=str[k]) next.push_back(k); else next.push_back(next[k]); &#125; else &#123; k=next[k]; &#125; &#125; return next; &#125; int strStr(string haystack, string needle) &#123; if(needle.empty()) return 0; int i=0;//源串 int j=0;//子串 int len1=haystack.size(); int len2=needle.size(); vector&lt;int&gt; next; next=getnext(needle); while((i&lt;len1)&amp;&amp;(j&lt;len2)) &#123; if((j==-1)||(haystack[i]==needle[j])) &#123; i++; j++; &#125; else &#123; j=next[j];//获取下一次匹配的位置 &#125; &#125; if(j==len2) return i-j; return -1; &#125;&#125;; 时间复杂度：$O(n+m)$ 空间复杂度：$O(n)$ 解法3：BM算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123;public: void get_bmB(string&amp; T,vector&lt;int&gt;&amp; bmB) &#123; int tlen=T.size(); for(int i=0;i&lt;256;i++) &#123; bmB.push_back(tlen); &#125; for(int i=0;i&lt;tlen-1;i++) &#123; bmB[T[i]]=tlen-i-1; &#125; &#125; void get_suff(string&amp; T,vector&lt;int&gt;&amp; suff) &#123; int tlen=T.size(); int k; for(int i=tlen-2;i&gt;=0;i--) &#123; k=i; while(k&gt;=0&amp;&amp;T[k]==T[tlen-1-i+k]) k--; suff[i]=i-k; &#125; &#125; void get_bmG(string&amp; T,vector&lt;int&gt;&amp; bmG) &#123; int i,j; int tlen=T.size(); vector&lt;int&gt; suff(tlen+1,0); get_suff(T,suff);//suff存储子串的最长匹配长度 //初始化 当没有好后缀也没有公共前缀时 for(i=0;i&lt;tlen;i++) bmG[i]=tlen; //没有好后缀 有公共前缀 调用suff 但是要右移一位 类似KMP里的next数组 for(i=tlen-1;i&gt;=0;i--) if(suff[i]==i+1) for(j=0;j&lt;tlen-1;j++) if(bmG[j]==tlen)//保证每个位置不会重复修改 bmG[j]=tlen-1-i; //有好后缀 有公共前缀 for(i=0;i&lt;tlen-1;i++) bmG[tlen-1-suff[i]]=tlen-1-i;//移动距离 &#125; int strStr(string haystack, string needle) &#123; int i=0; int j=0; int tlen=needle.size(); int slen=haystack.size(); vector&lt;int&gt; bmG(tlen,0); vector&lt;int&gt; bmB; get_bmB(needle,bmB); get_bmG(needle,bmG); while(i&lt;=slen-tlen) &#123; for(j=tlen-1;j&gt;-1&amp;&amp;haystack[i+j]==needle[j];j--); if(j==(-1)) return i; i+=max(bmG[j],bmB[haystack[i+j]]-(tlen-1-j)); &#125; return -1; &#125;&#125;; 时间复杂度：最差$O(n+m)$，最好$O(n)$ 空间复杂度：$O(n)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"LeetCode","slug":"Computer-Science/LeetCode","permalink":"http://fengggggggg.github.io/categories/Computer-Science/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://fengggggggg.github.io/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://fengggggggg.github.io/tags/String/"}]},{"title":"LeetCode 探索初级算法 数组","slug":"computer_science/LeetCode/Primary_Algorithm_Array","date":"2019-08-02T16:00:00.000Z","updated":"2019-08-05T16:00:00.000Z","comments":true,"path":"2019/08/03/computer_science/LeetCode/Primary_Algorithm_Array/","link":"","permalink":"http://fengggggggg.github.io/2019/08/03/computer_science/LeetCode/Primary_Algorithm_Array/","excerpt":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像","text":"旋转数组 从数组中删除重复项 买卖股票的最佳时机II 存在重复 只出现一次的数字 两个数组的交集II 加一 移动零 两数之和 有效的数独 旋转图像 1. 旋转数组给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数 示例1 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例2 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 解法1：暴力解法旋转k次，每次将数组向右旋转移动一位 1234567891011void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int pre, tmp; for (int i = 0; i &lt; k; ++i) &#123; int pre = nums[nums.size() - 1]; for (int j = 0; j &lt; nums.size(); ++j) &#123; tmp = nums[j]; nums[j] = pre; pre = tmp; &#125; &#125;&#125; 复杂度分析 时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$ 空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$ 解法2：使用额外数组使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上. 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; arr = nums; for (int i = 0; i &lt; nums.size(); ++i) arr[(i + k) % nums.size()] = nums[i]; for (int i = 0; i &lt; nums.size(); ++i) nums[i] = arr[i];&#125; 复杂度分析 时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$ 空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$ 解法3：使用环状替换如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。 现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上 12345678910111213141516void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 复杂度分析 时间复杂度：只遍历了一遍数组，$O(n)$ 空间复杂度：只用了常数个额外空间，$O(1)$ 解法4：数组反转先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素 1234567void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end());&#125; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$，没有使用额外空间 2. 从数组中删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成. 解法：双指针法数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例： 1234567[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ i i i j j j[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ... i i i j j j 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int j:nums) if (!i || j &gt; nums[i - 1]) nums[i++] = j; return i; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 3. 买卖股票的最佳时机II给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1 12345输入: [7,1,5,3,6,4]输出: 7解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入， 在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。 示例2 12345输入: [1,2,3,4,5]输出: 4解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出, 这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票， 之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 解法：暴力解法首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论： 一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断； 一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况； 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt; 2) return 0; int profit = 0; bool has_buy = false; if (prices[0] &lt; prices[1]) &#123; profit -= prices[0]; has_buy = true; &#125; for (int i = 1; i &lt; prices.size() - 1; ++i) &#123; if (has_buy == true &amp;&amp; prices[i] &gt; prices[i + 1]) &#123; profit += prices[i]; has_buy = false; &#125; else if (has_buy == false &amp;&amp; prices[i] &lt; prices[i + 1]) &#123; profit -= prices[i]; has_buy = true; &#125; &#125; if (has_buy == true) profit += *(prices.end() - 1); return profit; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 4. 存在重复给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。 解法：使用unorder_set使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set; for (auto it : nums) &#123; if (set.count(it) &gt; 0) return true; else set.insert(it); &#125; return false; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 5. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解法：使用异或该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) ans ^= i; return ans; &#125;&#125;; 复杂度分析 时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 6. 两个数组的交集II给定两个数组，编写一个函数来计算它们的交集。 示例1 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 示例2 12输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]输出: [2,3,5] 解法：使用find()函数使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;nums1.size();i++) &#123; auto it=find(nums2.begin(),nums2.end(),nums1[i]); if(it!=nums2.end()) &#123; res.push_back(*it); nums2.erase(it); &#125; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \\sim O(n^2)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 7. 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。 示例 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字123。 解法：反向遍历首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; digits[digits.size() - 1]++; for (auto i = digits.size() - 1; i &gt; 0; --i) &#123; if (digits[i] == 10) &#123; digits[i] = 0; digits[i - 1]++; &#125; &#125; if (digits[0] == 10) &#123; digits[0] = 0; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 8. 移动零给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。 示例 123输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。 解法：双指针法设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1. 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j = 0; while (i &lt; nums.size()) &#123; if (nums[i] == 0) i++; else &#123; swap(nums[i], nums[j]); i++; j++; &#125; &#125; &#125;&#125;; 复杂度分析 时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$ 空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$ 9. 两数之和给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例 123输入: nums = [2, 7, 11, 15], target = 9输出: [0,1]说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1] 解法1：暴力法暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; ans.push_back(i); ans.push_back(j); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 解法2：两遍哈希表以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_set; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash_set.count(target - nums[i]) &gt; 0) &#123; ans.push_back(hash_set[target - nums[i]]); ans.push_back(i); break; &#125; hash_set[nums[i]] = i; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 10. 有效的数独示例 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 解法：一次遍历使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中 1234567891011121314151617181920class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;unordered_map&lt;int,int&gt;&gt; rows(9), cols(9), boxes(9); for(int i = 0; i &lt; 9; ++ i) &#123; for(int j = 0; j &lt; 9; ++ j) &#123; int box_index = (i / 3) * 3 + j / 3; char n = board[i][j]; if(n != '.') &#123; if(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n)) return false; rows[i][n] = 1; cols[j][n] = 1; boxes[box_index][n] = 1; &#125; &#125; &#125; return true; &#125;&#125;; 复杂度分析 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 11. 旋转图像给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。 示例1 12345678910111213给定matrix= [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 解法：翻转先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$ 12345678910class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (int i = 0; i &lt; matrix.size(); ++i) for (int j = i; j &lt; matrix[0].size(); ++j) swap(matrix[i][j], matrix[j][i]); for (int i = 0; i &lt; matrix.size(); ++i) reverse(matrix[i].begin(), matrix[i].end()); &#125;&#125;; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"LeetCode","slug":"Computer-Science/LeetCode","permalink":"http://fengggggggg.github.io/categories/Computer-Science/LeetCode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://fengggggggg.github.io/tags/Array/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://fengggggggg.github.io/tags/LeetCode/"}]},{"title":"C++中的内联函数","slug":"computer_science/C&C++/inline_in_C++","date":"2019-07-30T01:45:00.000Z","updated":"2019-07-30T01:45:00.000Z","comments":true,"path":"2019/07/30/computer_science/C&C++/inline_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/30/computer_science/C&C++/inline_in_C++/","excerpt":"内联函数相关知识点梳理","text":"内联函数相关知识点梳理 1. 内联函数的作用引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏： 1#define Expression(a, b) (((a) + (b)) * ((a) - (b))) 该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它使用预处理器实现，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏不能进行参数有效性检测，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。 另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。 为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。 2. inline与宏定义的区别 inline函数的本质是一个函数，而宏不是； inline函数在编译时展开，宏在预编译时展开； 在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换； inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能； 宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。 3. inline的优点 inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高； 类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性； inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。 4. inline的使用场合 用于取代表达式形式的宏定义； 用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，定义在类体内的函数会被自动转换成内联函数。 5. inline的缺点inline是以代码复制为代价的，仅仅省去了函数调用的开销，从而提高函数的执行效率。若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低。另外，每一处内联函数的调用都需要复制代码，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline： 函数体内代码较长：使用inline将导致较高的内存消耗； 函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大； 不用于类的构造函数和析构函数。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"C++中的数据类型及其大小","slug":"computer_science/C&C++/data_type_in_C++","date":"2019-07-29T11:58:00.000Z","updated":"2019-07-29T11:58:00.000Z","comments":true,"path":"2019/07/29/computer_science/C&C++/data_type_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/29/computer_science/C&C++/data_type_in_C++/","excerpt":"在C/C++中的数据类型及其所占空间大小总结","text":"在C/C++中的数据类型及其所占空间大小总结 1. 内置数据类型常见的内置数据类型如下表所示，可以使用sizeof查看其大小： type size char 1B unsigned char 1B signed char 1B int 4B unsigned int 4B signed int 4B short (int) 2B long (int) 8B float 4B double 8B long double 16B wchar_t 2B or 4B 其中wchar_t是宽字符型，其定义为 1typedef short int wchar_t; 也就是说，实际上wchar_t和short int是等价的。 2. 数组与字符串对数组使用sizeof运算，其大小为数组中元素的个数*元素所占内存大小，而对于char数组型的字符串，例如char str[] = &quot;Hello&quot;，其大小为字符个数+1，因为结尾需要保存\\0。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。 3. 自定义数据类型3.1. class及struct3.1.1. 空类对于一个空类，例如 1234class A&#123;&#125; 其大小为1B，因为C++中每一个类都有一个独一无二的地址，因此即使是空类也会为其分配1B的内存空间。 3.1.2. 类对象所占内存大小类所占的内存大小由其成员变量决定，成员函数不计算在内，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如 123456789101112131415161718192021222324252627282930313233343536373839404142// sizeof(A) = 4class A&#123; int a;&#125;;// sizeof(B) = 4, 成员函数不计入class B&#123; int a; int fun1() &#123; return 0; &#125;&#125;;// sizeof(C) = 1, 结构体不计入class C&#123; struct stc1 &#123; int sa; char sb; &#125;;&#125;;// sizeof(D) = 1, 联合体不计入class D&#123; union un1 &#123; int ua; short ub; &#125;;&#125;;// sizeof(E) = 1, class不计入class E&#123; class cl1 &#123; int ca; short cb; &#125;;&#125;; 3.1.3. 类对象的字节对齐由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能从某些特定地址开始存取，如果不对其，会给存取效率带来损失。 字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则： 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节； 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 如果类中包含虚函数，则无论其有多少个虚函数，这些虚函数所占内存均为4B，因为内存中需要保存一个虚表指针成员 举例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class A&#123; int i;&#125;;class B&#123; char ch;&#125;;class C&#123; int i; short s;&#125;;class D&#123; int i; short j; char ch;&#125;;class E&#123; int i; int ii; short j; char ch; char ch2;&#125;;class F&#123; int i; int ii; int iii; short j; char ch; char ch2;&#125;;struct G&#123; char ch; int i; short b2;&#125;;class H&#123; int i; virtual void fun1() &#123;&#125; virtual void fun2() &#123;&#125;&#125;;class I : public A, public B &#123;&#125;;class J : virtual public A &#123;&#125;;class K : virtual public A, virtual B &#123;&#125;;class L&#123; int i; static int ii;&#125;// sizeof(A) = 4// sizeof(B) = 1// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)// sizeof(J) = 8// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中) 3.2. union联合体的大小取决于该体中所有的成员中占用空间最大的一个成员的大小，并且同样的需要对齐： 123456789101112131415161718192021union u1&#123; double a; int b;&#125;;union u2&#123; char a[13]; int b;&#125;;union u3&#123; char a[13]; char b;&#125;;// sizeof(u1) = 8;// sizeof(u2) = 13 + 3(以int的整数倍补齐);// sizeof(u3) = 13;","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"Ubuntu下GDB的使用","slug":"computer_science/Linux/gdb_in_ubuntu","date":"2019-07-27T14:00:00.000Z","updated":"2019-07-27T14:00:00.000Z","comments":true,"path":"2019/07/27/computer_science/Linux/gdb_in_ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2019/07/27/computer_science/Linux/gdb_in_ubuntu/","excerpt":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧","text":"最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧 1. 使用GDB调试可执行文件123gdb a.out # 不带参数或gdb --args a.out 参数 # 带参数 2. GDB常用命令12345678910111213141516171819202122232425r [args] # 带参数从头开始执行程序b arg # 在arg处设置断点，arg可以为行数、地址b xxx if (condition) # 条件断点b test.c:30 if n==100 # 当变量n等于100的时候在test.c的30行处加断点n (next) # 单步执行，如遇函数则直接返回函数的执行结果s (step) # 单步执行，如遇函数则进入函数体执行stop # 停止执行q (quit) # 退出GDBuntil # 当不想反复执行循环时，可以用until跳出循环finish # 跳出当前函数c (continue) # 继续执行，直到下一个断点或程序结束p arg # 打印出arg的值，arg可以为变量或地址whatis variable # 打印出变量的类型ptype variable # 打印出变量的类型，只不过比whatis更详细i variables variable # 打印出定义variable的文件i source # 查看当前程序i b # 查看arg，arg可以为断点、变量值、i args # 打印出当前函数的参数值i locals # 打印出当前函数中所有局部变量值i r (r_name) # 查看所有寄存器(寄存器r_name)的值i threads # 查看线程d b # 删除断点，b为断点编号bt # 查看函数的back tracel (list) arg # 显示arg附近的前后共10行代码，arg可以为行数或函数名watch arg # 设置监控，在arg改变时停止(需要先加断点) 3. 设置断点1234# 当欲设断点在当前文件中时，可以b+行数或b+函数名b 45/main# 当欲设断点在其他文件中时，b 文件名:行数b head.cpp:45","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"http://fengggggggg.github.io/tags/GDB/"}]},{"title":"C++中const、define和static","slug":"computer_science/C&C++/const_define_static_in_C++","date":"2019-07-03T03:29:37.000Z","updated":"2019-07-02T16:00:00.000Z","comments":true,"path":"2019/07/03/computer_science/C&C++/const_define_static_in_C++/","link":"","permalink":"http://fengggggggg.github.io/2019/07/03/computer_science/C&C++/const_define_static_in_C++/","excerpt":"关键字const、define和static相关知识点整理","text":"关键字const、define和static相关知识点整理 1. const和define区别 宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查; const常量存在于程序的数据段，并在堆栈分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查; 2. C++中关键字const的作用 定义常量; 修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const: 12void fun(A a);void fun(A const &amp;a); 修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量: 123const char *GetChar()&#123;&#125;;char *ch = GetChar(); // errorconst char *ch = GetChar() //correct const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下: 1int GeoCount() const; 3. 静态变量static1. static的作用 一个static变量可以维持其值在被调用的过程中不变； 在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问； 模块内的一个static修饰的函数只可以被该模块内的函数调用。 2. static变量和普通变量的区别1. static全局变量和普通全局变量 static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值； static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用； （相同点）两种都以静态存储方式存储； 2. static局部变量和普通局部变量 static局部变量只被初始化一次，下一次使用依据上一次的结果 3. static函数和普通函数 static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品； static函数作用域仅在本文件中，普通函数可在其他文件被调用；","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"C & C++","slug":"Computer-Science/C-C","permalink":"http://fengggggggg.github.io/categories/Computer-Science/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://fengggggggg.github.io/tags/C/"}]},{"title":"Introduction to Array","slug":"computer_science/Data_Structure/array","date":"2019-06-28T16:04:37.000Z","updated":"2019-06-28T16:00:00.000Z","comments":true,"path":"2019/06/29/computer_science/Data_Structure/array/","link":"","permalink":"http://fengggggggg.github.io/2019/06/29/computer_science/Data_Structure/array/","excerpt":"学习数组时的一个简单的笔记","text":"学习数组时的一个简单的笔记 数组及其初始化对于一个只声明未赋值的int型数组，如果该数组为全局变量，该数组会被初始化为0，若为局部变量，则被初始化为乱值； 矩阵的压缩存储稀疏矩阵：对于一个稀疏矩阵(即矩阵中的大部分元素为0)，可以使用三元组表示法对其压缩。在一个三元组中，每一个一个条目都形如(行号, 列号, 值)，稀疏矩阵中的每一个非零值由三元组表中的条目唯一表示。稀疏矩阵经过三元组压缩存储后，会失去随机存取能力； 特殊矩阵：特殊矩阵形如上三角矩阵、对角矩阵、对称矩阵等，特殊矩阵的压缩存储并不会丧失随机存取的能力。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Array","slug":"Array","permalink":"http://fengggggggg.github.io/tags/Array/"}]},{"title":"MacOS/Ubuntu 18.10 安装PyTorch","slug":"computer_science/Linux/PyTorch_for_Linux","date":"2019-03-29T16:00:00.000Z","updated":"2018-03-29T16:00:00.000Z","comments":true,"path":"2019/03/30/computer_science/Linux/PyTorch_for_Linux/","link":"","permalink":"http://fengggggggg.github.io/2019/03/30/computer_science/Linux/PyTorch_for_Linux/","excerpt":"MacOS/Ubuntu 18.10 安装PyTorch","text":"MacOS/Ubuntu 18.10 安装PyTorch 1. MacOS/Ubuntu 18.10 安装Conda管理环境MacOS下前往Anaconda官网下载安装即可Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加export PATH=”/home/user_name/anaconda3/bin:$PATH”并source一下即可 2. MacOS/Ubuntu 18中安装PyTorch (可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch 123conda create -n environment_name python=X.X (2.7/3.6) # 创建虚拟环境conda info --env # 显示所有的conda虚拟环境conda activate environment_name # 激活虚拟环境 修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源 12345678# for Anacondaconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# for PyTrochconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --set show_channel_urls yes 安装PyTorch 12conda install pytorch torchvisionconda deactivate # 使用结束后退出虚拟环境 3. 虚拟环境中安装jupyter如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter 1python3 -m pip install jupyter","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://fengggggggg.github.io/tags/PyTorch/"},{"name":"MacOS","slug":"MacOS","permalink":"http://fengggggggg.github.io/tags/MacOS/"}]},{"title":"Introduction to Queue","slug":"computer_science/Data_Structure/Queue","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-03T16:00:00.000Z","comments":true,"path":"2019/03/04/computer_science/Data_Structure/Queue/","link":"","permalink":"http://fengggggggg.github.io/2019/03/04/computer_science/Data_Structure/Queue/","excerpt":"A note to queue","text":"A note to queue 1. 循环队列 计算大小为n的循环队列中元素的个数 $(rear - front + n) % n$ $(rear - front + n + 1) % n$ 循环队列判空 $front = rear$ 循环队列判满 $(rear + 1) % n = front $ 出队后头指针front的值 $ front = (front + 1) % m $","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fengggggggg.github.io/tags/Data-Structure/"},{"name":"Queue","slug":"Queue","permalink":"http://fengggggggg.github.io/tags/Queue/"}]},{"title":"Ubuntu 18.10安装LLVM","slug":"computer_science/Linux/LLVM_for_Ubuntu","date":"2018-12-29T16:00:00.000Z","updated":"2018-12-29T16:00:00.000Z","comments":true,"path":"2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/","excerpt":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本","text":"因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本 1.安装cmake安装LLVM需要使用cmake，可以使用如下命令安装: 1sudo apt install cmake 2.修改swap分区(可选，不推荐)从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下： 查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间: 123sudo swapon --showorfree -h 检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值 1df -h 在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。 123sudo swapoff -a # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，sudo fallocate -l 20G /swapfile # 创建swapfilels -lh /swapfile # 验证是否成功创建swapfile， 如果显示-rw——1 root root 20G 日期 /swapfile 则表示创建成功 启用交换文件 12sudo chmod 600 /swapfile # 锁定swapfile权限sudo mkswap /swapfile # 将文件标记为交换空间 若显示:Setting up swapspace…… 则表示成功标记swapfile，标记之后启用该文件 12sudo swapon /swapfile # 启用free -h # 验证 永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留 12sudo cp /etc/fstab /etc/fstab.bak # 备份echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab # 将swap文件信息添加到/etc/fstab文件 3.安装LLVM-8.0 Debug版本 首先去LLVM官网下载必要的软件包; 获取源码: 1234567891011121314151617181920212223# 在适当位置放置LLVM源码，此处放在home下cd ~mkdir tmp# 解压LLVM源码cd tmptar -Jxvg llvm-7.0.0.src.tar.xzmv llvm-7.0.0.src llvm# 解压clang源码(此时在tmp目录下)cd llvm/toolstar -Jxvg cfe-7.0.0.src.tar.xzmv cfe-7.0.0.src clang# 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)cd clang/toolstar -Jxvg clang-tools-extra-7.0.0.src.tar.xzmv clang-tools-extra-7.0.0.src extra# 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)cd ~/tmp/llvm/projectstar -Jxvg compiler-rt-7.0.0.src.tar.xzmv compiler-rt-7.0.0.src compiler-rt 开始安装 123456789101112# 在tmp目录下新建build文件夹cd buildcmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Debug ../llvmmake -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半sudo make install# 将路径添加到环境变量中cd ~vim .bashrcexport PATH=/usr/lib/llvm-7/binexport LD_LIBRARY_PATH=/usr/lib/llvm-7/libsource .bashrc 重启终端并测试 123clang -vclang++ -vclang test.c","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"LLVM","slug":"LLVM","permalink":"http://fengggggggg.github.io/tags/LLVM/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu 18.10安装与配置","slug":"computer_science/Linux/install_ubuntu","date":"2017-06-03T16:00:00.000Z","updated":"2017-06-03T16:00:00.000Z","comments":true,"path":"2017/06/04/computer_science/Linux/install_ubuntu/","link":"","permalink":"http://fengggggggg.github.io/2017/06/04/computer_science/Linux/install_ubuntu/","excerpt":"Ubuntu 18.10安装与配置","text":"Ubuntu 18.10安装与配置 1. 安装Ubuntu 18.10安装过程不多说，安装镜像可以去中科大镜像下载。 2. 安装搜狗输入法 前往搜狗输入法官网下载deb安装文件，双击安装； 前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt； 当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法； 重启系统。 3. 修改软件源应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn 4. 安装Chrome前往Chrome官网下载.deb安装包，双击安装即可。 5. 开启夜览模式夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整： 打开Terminal安装dconf-editor 1sudo apt install dconf-editor 在终端打开dconf-editor 1dconf-editor dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature 关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适 6. 系统美化安装Tweaks工具用以配置桌面 12sudo apt updatesudo apt install gnome-tweak-tool 在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有： Weather In The Clock，点击屏幕上方的时间可以展示天气; Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏； 7. 配置终端 安装zsh与git 12sudo apt install zsh sudo apt install git 安装oh-my-zsh 1sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 将Shell切换到zsh，登出并重新登入 1chsh -s /bin/zsh 在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题 1ZSH_THEME=\"ys\" 安装一些强大的zsh插件首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令： 1source ~/.oh-my-zsh/plugins/incr/incr*.zsh 同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Linux","slug":"Computer-Science/Linux","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://fengggggggg.github.io/tags/Ubuntu/"}]},{"title":"Introduction To Data Structure","slug":"computer_science/Data_Structure/introduction","date":"2016-09-22T16:00:00.000Z","updated":"2014-09-22T16:00:00.000Z","comments":true,"path":"2016/09/23/computer_science/Data_Structure/introduction/","link":"","permalink":"http://fengggggggg.github.io/2016/09/23/computer_science/Data_Structure/introduction/","excerpt":"对常见数据结构的一个简单地总结","text":"对常见数据结构的一个简单地总结 1. 数据结构定义数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成，记为： $Data Structure = (D, R)$ 其中$D$是数据元素的集合，$R$是$D$中元素之间的关系的集合。 通俗的理解，数据结构=逻辑结构(线性、非线性) + 存储结构(顺序、链式、索引、散列) 逻辑结构：数据元素间抽象化的相互关系 存储结构：数据在计算机中的存储形式，也是物理结构 2. 逻辑结构数据的逻辑结构是指数据之间的逻辑关系，比如一对一、一对多、多对一、多对多等。通常，逻辑关系可以分为两种：线性关系和非线性关系。线性关系指：除第一个外，每个元素有且只有一个前驱；除最后一个元素外，每个元素有且只有一个后继。 常见的逻辑结构有以下几种： 集合：数据元素间没有任何关系 线性结构：数据元素间存在线性关系 树：数据元素间有层次关系 图：数据元素间you网状关系 常见的线性结构：线性表、栈、队列、双队列、数组、串等常见的非线性结构：多维数组、树、图、广义表等 3. 存储结构数据的存储结构是指数据在计算机中的存储形式，也是数据的物理结构。 常见的存储结构有以下几种： 顺序存储：逻辑上相邻的节点存储在物理位置上相邻的存储单元中，节点之间的逻辑关系由存储单元的邻接关系体现 优点：可实现对节点的随机存取 缺点：不便于插入、删除，因为要大量移动数据 链式存储：逻辑上相邻的节点在物理存储上不相邻，而是通过指针等体现逻辑关系 优点：便于插入、删除，存储密度比顺序存储小 缺点：不便于查找 索引存储：通过建立索引表来标识节点的地址 散列存储：根据节点的关键字直接计算出节点的存储地址","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://fengggggggg.github.io/tags/Data-Structure/"}]},{"title":"TCP中的拥塞控制简介","slug":"computer_science/Computer_Network/congestion_control","date":"2015-05-27T13:12:00.000Z","updated":"2015-05-27T13:12:00.000Z","comments":true,"path":"2015/05/27/computer_science/Computer_Network/congestion_control/","link":"","permalink":"http://fengggggggg.github.io/2015/05/27/computer_science/Computer_Network/congestion_control/","excerpt":"TCP中的拥塞控制的目的是控制网络拥塞的出现，网络拥塞的原因多种多样，比如某结点的缓存太小、某段链路带宽太低等等。为了防止网络拥塞，V.Jacobson在1988年的论文中提出了用于TCP的拥塞控制，由慢开始和拥塞避免组成，后来在TCP Reno版本中又加入了快重传和快恢复。这4种技术能够很好的避免网络拥塞。","text":"TCP中的拥塞控制的目的是控制网络拥塞的出现，网络拥塞的原因多种多样，比如某结点的缓存太小、某段链路带宽太低等等。为了防止网络拥塞，V.Jacobson在1988年的论文中提出了用于TCP的拥塞控制，由慢开始和拥塞避免组成，后来在TCP Reno版本中又加入了快重传和快恢复。这4种技术能够很好的避免网络拥塞。 1. 慢开始如果将网络通路比作高速公路，那么我们可以想象一下，如果这条路的出口只有一个车道，而入口却有很多车道，那么这条路必然会造成拥塞。慢开始就是针对这一情况而提出的。其基本思想是逐渐增大发送的数据大小(即拥塞窗口)直到指定的阈值(即慢开始阈值)。 在慢开始中，发送端除了要维护正常情况下根据接收端发来的窗口大小字段值而调整的发送窗口外，还要维护一个拥塞窗口(Congestion Window, CWND)，CWND的目的是为了避免发生拥塞，最终允许发送的字节数是CWND和发送窗口两者中的最小值。 下面介绍慢开始的具体步骤(假设CWND总是小于发送窗口)： 在TCP传输连接建立时，发送端将CWND初始化为该连接上当前使用的最大数据段大小(Maximum Segment Size, MSS)，即CWND=MSS，然后发送端发送一个MSS大小的数据段M1。 如果在定时器过期前发送端收到了该数据段的确认(即对M1的确认)，则发送端将CWND大小翻倍，即CWND=2MSS，并发送2MSS大小的数据，假定发送的数据段位M2、M3。 同样的，如果在定时器过期前发送端接收到确定(收到M3的确认即可，即只用确认最后一个)，再次将CWND翻倍，并以此类推。 当出现数据丢失时，需要将慢开始阈值(Slow Start Threshold, SSTHRESH)设置为当前CWND的一半，并将CWND重设为1MSS。并重新开始慢开始，此时若CWND再次达到SSTHRESH便停止使用慢开始，转用拥塞避免。 值得注意的是，一般SSTHRESH初始值为64KB。 2. 拥塞避免拥塞避免的基本思想是，当CWND再次达到SSTHRESH时，让拥塞窗口的大小每经过一个RTT(数据传输往返时间)时仅增加1MSS。如果这时还是发生了数据丢失，同样的还是把SSTHRESH设为当前CWND的一半，把CWND设为1MSS，并重新开始慢开始。 3. 快重传/快恢复快重传的基本思想是，当接收端收到一个不是按序到达的数据段时，TCP实体迅速发送一个重复ACK数据段，而不用等到有数据需要发送时才顺带发出重复ACK。在连续收到3个重复ACK数据段后，即认为对应确认号字段的数据丢失，TCP不等重传定时器超时就会重传丢失的数据段。 快恢复是在快重传发挥作用时，确切的说是收到第三个重复ACK时，把当前CWND设为当前SSTHRESH的一半，以减轻网络负载，然后执行拥塞避免算法。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://fengggggggg.github.io/tags/Network/"}]},{"title":"常见路由算法","slug":"computer_science/Computer_Network/routing_algorithm","date":"2015-04-14T06:12:00.000Z","updated":"2015-04-14T06:12:00.000Z","comments":true,"path":"2015/04/14/computer_science/Computer_Network/routing_algorithm/","link":"","permalink":"http://fengggggggg.github.io/2015/04/14/computer_science/Computer_Network/routing_algorithm/","excerpt":"路由算法是指从源节点和目的节点之间选择一条最佳的路径用于传输数据。为了完成这个任务，在路由器中通常会收集和保存各种与传输路径相关的数据，如拓扑结构、端口度量、端口速率等，然后根据相应的路由算法生成路由表，在数据发送时提供路由选择。 一般而言，路由算法分为自适应路由算法和非自适应路由算法。","text":"路由算法是指从源节点和目的节点之间选择一条最佳的路径用于传输数据。为了完成这个任务，在路由器中通常会收集和保存各种与传输路径相关的数据，如拓扑结构、端口度量、端口速率等，然后根据相应的路由算法生成路由表，在数据发送时提供路由选择。 一般而言，路由算法分为自适应路由算法和非自适应路由算法。 1. 非自适应路由算法非自适应路由算法是指不能根据网络流量和拓扑结构的变化动态更新路由表的算法，这类算法使用静态路由表。 1.1 静态路由静态路由是指由管理员手动在路由表中一条条添加路由选项，这种方法费时费力，都不能称之为算法。不过RapidIO中采用了这种方法，RapidIO是嵌入式通信网络之一，其路由表建立的方式之一就是将路由表烧进芯片里。 1.2 扩散法扩散法是指当一个路由收到报文分组后，向它所有的端口复制扩散该报文。因为有多条路径，所以即使网络局部瘫痪也不影响通信，但是大量重复加重了网络负担，因此这种算法适合规模较小、通信负载轻、可靠性要求极高的通信场合，如军用通信。 1.3 随机走动法该方法指挡路有收到报文分组后，随机选择一个端口将其发送出去。这种方法通信效率低、实用价值低。 1.4 最短路径法该算法是指利用Dijkstra算法构建一个节点之间的最短路径，即跳数最少的路径，作为路由表。每次收到报文后查询路由表进行转发。 1.5 基于流量的路由算法最短路径算法只考虑网络拓扑结构，而基于流量的算法还会考虑网络流量及负载。 2. 自适应路由算法自适应路由算法是指能根据网络流量和拓扑情况而动更新路由表的算法。该类算法一般分为两类，一类是路由中只保留相邻器的路由信息的分散式路由算法，另一类是保留网络(或部分网络)中所有路由器的全部信息的总体式路由算法。 2.1 距离矢量路由算法距离矢量路由算法(Distance Vector, DV)是分散式路由算法的一种，而DV是指源节点和目的节点之间所经过的路由器的数目减一(需要减去源节点直连路由器)，该距离也称为跳数。采用DV的经典路由协议有RIP、内部网关协议IGRP、增强型内部网关协议EIGRP和边界网关协议BGP。 2.2 链路状态路由算法该算法是总体式路由算法的一种，又被称为最短路径优先算法，它和基于流量的路由算法有点类似，只是前者会动态更新路由表，而后者不会。使用该算法的路由协议有开放最短路径优先(OSPF)、中间系统-中间系统(IS-IS)、EIGPR(同时支持距离矢量算法和链路状态算法)等。 2.3 分级路由算法前面两种自适应路由算法中，每个路由器都要保存其他路由器的一些信息，随着网络规模的增加，路由表的规模也会增大，从而使路由器不能有效的进行流量控制，分级路由算法可以解决这个问题。 在分级路由中，路由器被分成很多组，称之为区域。每个路由器都只有自己所在区域路由器的信息。使用该算法的有OSPF、IS-IS、BGP。 总的来说，在部分区域内，一般使用的是距离矢量路由算法和链路状态路由算法，而在全局网络中一般使用分级路由算法","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Route","slug":"Route","permalink":"http://fengggggggg.github.io/tags/Route/"}]},{"title":"计算机网络物理层简介","slug":"computer_science/Computer_Network/physical_layer_in_network","date":"2015-03-22T06:12:00.000Z","updated":"2015-03-22T06:12:00.000Z","comments":true,"path":"2015/03/22/computer_science/Computer_Network/physical_layer_in_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/22/computer_science/Computer_Network/physical_layer_in_network/","excerpt":"物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议","text":"物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议 1. 物理层的主要作用物理层有如下几个作用 构建数据通路：即两个通信端之间的可以连续传输数据的物理通路 透明传输：作为物理通路的材质可能有很多，例如双绞线、光纤等，物理层需要确保数据对这些材质透明，即不管什么材质都不影响数据传输 传输数据：既然是通路其基本功能就是传输数据。物理层的基本传输单元是bit 数据编码：不同传输介质所支持的数据编码可能不同，如归零码、曼彻斯特码、差分曼彻斯特码等。物理层需要确保不同编码的数据能够正常在通路上传输 数据传输管理：对比特流的数据传输流量控制、差错控制、物理线路的激活与释放等 2. 物理层特性物理层需要规范其接口的特性，有了统一的标准，不同的厂商能够以相同的标准来实现彼此产品的互联 机械特性：定义了传输介质接线器、物理接口的形状和尺寸、引线数目和排列顺序以及连接器与接口之间的固定和锁定装置 电气特性：规定了在通路上传输比特流时线路上信号电压的高低、阻抗匹配情况，以及传输速率和传输距离限制等参数属性，主要分为三类： 非平衡型 差分接收器的非平衡型 平衡型 功能特性：指传输介质中各条线上所出现的某一电平的含义，以及物理接口各条信号线的用途，包括：接口信号线的功能规定，接口信号线的功能分类。 规程特性：利用接口传输比特流的全过程以及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时，DTE/DEC双方在各自电路上的动作顺序。 3. 物理层传输介质 导向性传输介质 双绞线 同轴电缆 光纤 非导向性传输介质 短波无线传输 地面微波接力通信 卫星通信","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://fengggggggg.github.io/tags/Network/"}]},{"title":"计算机网络的拓扑结构","slug":"computer_science/Computer_Network/topology_of_network","date":"2015-03-22T06:12:00.000Z","updated":"2015-03-22T06:12:00.000Z","comments":true,"path":"2015/03/22/computer_science/Computer_Network/topology_of_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/22/computer_science/Computer_Network/topology_of_network/","excerpt":"计算机网络拓扑结构是指网络中各个端点之间的逻辑结构，本文对其进行简单介绍","text":"计算机网络拓扑结构是指网络中各个端点之间的逻辑结构，本文对其进行简单介绍 1. 网络拓扑中的基本概念 节点：即一个网络端口，如PC； 结点：通常连接了多个节点，如路由器和交换机； 链路：两个节点之间的线路； 通路：两个节点之间的通信线路，可能包含多条链路。 2. 星型拓扑结构目前应用最广的一种拓扑结构，各节点以交换机或集线器等设备连接在一起，其优点包括扩展方便、网速较快、易于维护，但缺点也很明显：核心交换机负载过重、通信过于依赖核心交换机等。 3. 环形拓扑结构这种网络因为传输速率低、扩展性差，已经被淘汰不用了，使用这种结构的有令牌环网。 4. 总线型拓扑结构该结构中，所有设备都连接到一条总线上，和环形拓扑不同的是不形成闭环。总线型拓扑结构会在总线两端加装“终接器”的设备，主要用于与总线进行阻抗匹配，最大限度吸收传送端部的能量，避免信号反射回总线产生不必要的干扰。其优点有：结构简单、易于扩展、易于维护，缺点有：传输速率低、故障诊断苦难、难以实现大规模扩展； 4. 树形拓扑结构树根为核心交换机，叶节点为终端设备 5. 网状拓扑结构网络可靠性高、布线复杂 6. 混合型拓扑结构应用广泛、维护困难 7. WLAN的拓扑结构 Ad-Hoc：点对点连接方式，只能单点通信，性能较差； Infrastructure：和星型拓扑类似。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://fengggggggg.github.io/tags/Network/"}]},{"title":"死锁问题","slug":"computer_science/Operating_System/deadlock","date":"2015-03-16T06:12:00.000Z","updated":"2015-03-16T06:12:00.000Z","comments":true,"path":"2015/03/16/computer_science/Operating_System/deadlock/","link":"","permalink":"http://fengggggggg.github.io/2015/03/16/computer_science/Operating_System/deadlock/","excerpt":"关于死锁的一些归纳和总结","text":"关于死锁的一些归纳和总结 1. 死锁产生的原因和必要条件进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。 可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。 不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。 因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点： 系统资源不足。这是根本原因，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时； 进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。 对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4： 互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用； 请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源； 不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占； 循环等待。若干个进程形成循环等待链。 2. 死锁的预防通过破坏死锁的必要条件来控制死锁的策略称为死锁预防，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。 破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的优点是安全简单易实现，缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源。 破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”。 破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高。 3. 死锁的避免与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的前提是每个进程清除自己需要多少资源，因此死锁避免还是有局限性的。 系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全； 银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。 4. 银行家算法银行家算法有5种数据结构： 系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲； 最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k； 分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数； 需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源； 请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。 当某个进程i对j类资源提出k个请求是，需要按照下列步骤检查： 若$Request[j]&lt;=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错； 若$Request[j]&lt;=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i； 系统进行试探性分配，并修改相应的表： Available[j] -= Request[j]; Allocation[i][j] += Request[j]; Need[i][j] -= Request[j]; 调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。 判断当前状态是否安全 添加两个数组： Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa； Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。 检查当前状态的完整过程如下： 初始化Work和Finish。Work[j]=Available[j], Finish[i]=false; 在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4: Finish[h] = false; Need[h][j] &lt;= Work[j] 由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2 若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。 5. 死锁检测6. 死锁解除","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Deadlock","slug":"Deadlock","permalink":"http://fengggggggg.github.io/tags/Deadlock/"}]},{"title":"计算机网络的分类","slug":"computer_science/Computer_Network/classify_in_network","date":"2015-03-15T06:12:00.000Z","updated":"2015-03-15T06:12:00.000Z","comments":true,"path":"2015/03/15/computer_science/Computer_Network/classify_in_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/15/computer_science/Computer_Network/classify_in_network/","excerpt":"计算机网络分类","text":"计算机网络分类 1. 按覆盖范围分 局域网LAN：LAN是将一个较小的区域内的各种通信设备连接在一起组成的网络，最常见、最常应用的网络。LAN具有以下特点： 私有服务：LAN用于私用，例如校园网和企业网 分布范围小 结构简单、布线容易 网速较快，误码率低 城域网MAN：通常用于为一个城市范围提供服务 广域网WAN：分布范围最大，可以遍布一个国家甚至全球，特点有： 覆盖范围广 构建成本高 网络结构和类型复杂：可以连接多种不同的网络类型 传输速率低，误码率高 2. 按网络管理模式分 对等网：即网络中的各成员地位相等。这种网络配置简单，适合家庭、校园和小型办公室用户，但其缺点也很明显，例如管理困难、安全性差、成本高、性能差等； C/S网：客户/服务器网，其特点是易于管理、安全性高、性能好。 3. 按传输方式分 点对点传输网络：该网络中数据是以点对点的方式传输的，因此这类网络采用基于点对点的通信协议，如点对点协议PPP、基于以太网的点对点协议PPPOE等。 广播式传输网络：该网络中任一节点都可以通过公用信道传输数据到其他节点上，其他节点通过匹配数据地址来判断是否接收。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Network","slug":"Computer-Science/Computer-Network","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://fengggggggg.github.io/tags/Network/"}]},{"title":"进程、线程与协程之间的区别与联系","slug":"computer_science/Operating_System/process_and_thread_coroutines","date":"2015-03-12T06:12:00.000Z","updated":"2015-03-12T06:12:00.000Z","comments":true,"path":"2015/03/12/computer_science/Operating_System/process_and_thread_coroutines/","link":"","permalink":"http://fengggggggg.github.io/2015/03/12/computer_science/Operating_System/process_and_thread_coroutines/","excerpt":"进程、线程与协程之间的区别与联系","text":"进程、线程与协程之间的区别与联系 1. 进程进程是程序的动态执行。保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。一块CPU在某一时刻只能运行一个进程，多进程是通过进程调度抢占CPU来实现的。 进程间的通信方式 无名管道(Pipe)、有名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存(Shared Memory)、套接字(Socket)。 2. 线程线程也被称为轻量级进程(Lightweight Process，LWP)，是操作系统调度(CPU调度)执行的最小单位。 2.1 线程与进程的区别与联系联系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 资源分配给进程，同一进程的所有线程共享该进程的所有资源； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属进程的资源。进程维护的是程序所包含的资源(静态资源)，如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等；线程所维护的运行相关的资源(动态资源)，如：运行栈、调度相关的控制信息、待处理的信号集等； 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致创建进程的系统开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 3. 协程协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总有一个入口，一次返回，并且调用顺序是明确的。而协程的调用和子程序不同，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。 协程的优点 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显； 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://fengggggggg.github.io/tags/Process/"}]},{"title":"进程间的通信方式","slug":"computer_science/Operating_System/communication_of_process","date":"2015-03-09T06:12:00.000Z","updated":"2015-03-09T06:12:00.000Z","comments":true,"path":"2015/03/09/computer_science/Operating_System/communication_of_process/","link":"","permalink":"http://fengggggggg.github.io/2015/03/09/computer_science/Operating_System/communication_of_process/","excerpt":"同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。","text":"同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。 1. 进程通信的概念进程的特征之一是其具有独立性，一个进程不能访问另一个进程的程序或者数据，以保证进程之间不会相互干扰，但这样也造成了进程间无法直接交换数据。 一般而言，进程通过两种方案来实现进程间的通信 发送、接受双方通过磁盘等外设交换数据。这种通信方式需要I/O操作的支持。 利用内核运行在内核态的特点，通过对内核空间读写来交换数据。这种通信方式是在内存中完成的。 根据进程通信交换信息量的大小，可以将进程通信分为两种： 低级通信。进程之间一次只传输少量数据，速度快，效率低，通信过程对用户不透明。这类通信主要用于互斥与同步的工具，P、V原语是低级通信原语 高级通信。一次可以传输大量信息，效率高，对用户透明，编程简单。高级通信又分为三种： 共享内存通信方式：利用共享内存通信； 消息传递通信方式：利用OS提供的消息系统通信； 共享文件通信方式：又被称为管道通信。 高级通信方式既适用于集中式操作系统，又适用于分布式操作系统。 2. 共享内存通信方式共享内存是指在内存中划出一块区域作为数据共享区，称为共享内存分区，通信双方将自己的虚拟地址空间映射到共享内存分区上。通信时通过对该分区读写实现通信。该方式是进程间最快捷、最有效的通信方式，Unix、Windows和OSX都采用了这种通信方式。 3. 消息缓冲(消息队列)通信方式消息缓冲属于直接通信方式，该方法中，发送进程直接发送原语到接收进程的消息队列，而接受进程使用接受原语从消息队列中取出信息，进程间以消息为单位进行信息交换。该方法与生产者-消费者问题类似。该方式与共享内存有点相似，该方法使用内存中的公用消息缓冲区来传递消息。 4. 信箱通信方式该方式是间接通信方式，通信双方通过一种叫信箱的共享数据结构来进行交互。该方法和消息队列没什么区别，也是在内存中设置一种特殊的数据结构。 5. 管道通信方式所谓的管道就是一种共享通信文件，也称为pipe文件，专门用于进程间通信。管道有三个特点： 管道专门用于特性 管道只能单向传送数据 管道对用户透明 管道分为两种： 无名管道。无名管道是利用系统调用pipe建立起来的无路径名的无名文件，并且是一个临时文件，该文件物理上由文件系统的高速缓冲区构成，且很少启动外部设备。当进程不再需要无名管道时，系统关闭并回收与它相关联的索引节点。此外，通过文件系统看不到无名管道的存在。 有名管道。有名管道是一个有目录和索引的长期存在的真实文件，不能与文件系统中的任何文件重名，且在文件系统中能看到该有名管道。 6. 信号量7. 套接字","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://fengggggggg.github.io/tags/Process/"}]},{"title":"计算机网络中的数制与编码","slug":"computer_science/Computer_Basic/number_system_and_coding_in_network","date":"2015-03-08T06:12:00.000Z","updated":"2015-03-08T06:12:00.000Z","comments":true,"path":"2015/03/08/computer_science/Computer_Basic/number_system_and_coding_in_network/","link":"","permalink":"http://fengggggggg.github.io/2015/03/08/computer_science/Computer_Basic/number_system_and_coding_in_network/","excerpt":"计算机网络中的进制与编码","text":"计算机网络中的进制与编码 1. 常见进制计算机是二进制的世界，及其只能识别01串，但是为了人类理解方便，还是制定了多种进制，例如: 十进制：十进制数的标志为D，例如(123)D 二进制：二进制的标识为B，例如(101)B 八进制：标识为\b字母O，在C/C++中八进制数前需要加数字0，如0123位八进制数 十六进制：标识为H，C/C++中十六进制数以0x开头 十二进制：时钟用到的进制 六十进制：分钟与秒钟用到的进制 2. 进制转换 非十进制转换成十进制：按位的幂的累加和，例如$(11010)2 = 12^4 + 12^3 + 02^2 + 12^1 + 0*2^0 = (26){10}$ 十进制转换成非十进制：整数使用除基取余法，小数使用乘基正序取整法(即每次乘基后，取大于1的部分整数) 非十进制与非十进制之间的转换：可以利用二进制作为中介 3. 计算机中二进制数的表示计算机中二进制采用的表示形式为补码。计算机中的字长是指计算机一次可以处理的二进制数的长度。 原码：最高位用于表示数的正负。这种表示的缺陷是对异号加减操作不便，与此同时0有+0和-0两种不同的表示，存在二义性。故计算机不采用这种表示形式 补码：正数补码与原码相同，负数的补码为原码除符号位外按位取反，再将末位加1得到。补码的优点是运算时可以将符号位一起运算，且0只有一种表示形式 反码：正数反码与源码相同，负数为除符号位外按位取反。反码是原码和补码的中间过渡形式。 移码：补码的符号位取反即是移码","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Basic","slug":"Computer-Science/Computer-Basic","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Basic/"}],"tags":[{"name":"Basic","slug":"Basic","permalink":"http://fengggggggg.github.io/tags/Basic/"}]},{"title":"进程的基本概念","slug":"computer_science/Operating_System/process","date":"2015-03-07T06:12:00.000Z","updated":"2015-03-07T06:12:00.000Z","comments":true,"path":"2015/03/07/computer_science/Operating_System/process/","link":"","permalink":"http://fengggggggg.github.io/2015/03/07/computer_science/Operating_System/process/","excerpt":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。","text":"为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。 1. 进程的概念1.1 程序的顺序执行在计算机中常使用程序这个概念，程序是一个在时间上严格按先后次序操作实现算法功能的指令序列，程序本身是静态的，是指令编译出的结果。在单道程序设计环境中，程序总是顺序执行的，若有多个程序，则各个程序试一次呗调入内存的。程序的顺行执行有以下三个特点： 顺序性。CPU严格按照程序规定的顺序(即指令顺序)执行程序的操作，每个操作都必须在前一个操作结束后才能执行； 封闭性。程序一旦开始执行，其结果仅由初始条件和程序本身操作决定，不受外界因素影响； 可再现性。当初始条件相同，程序的运行结果也相同。 单道程序的顺序性、封闭性和可再现性给程序的编制、调试带来了便利，但是资源利用率底。 1.2 程序的并发执行1.3 进程1.3.1. 进程的定义单道程序环境下，程序与CPU执行的活动是一致的。多道环境下，并发破坏了程序的封闭性和可再现性，程序与CPU执行的活动不再一一对应。程序是完成某一特定功能的指令序列，是一个静态过程，而CPU执行的活动是一个动态的过程。因此20世纪60年代Dijkstra引入了进程的概念。他给出的进程定义是：行为的规则称为程序，程序在CPU上执行时的活动称为进程。 1.3.2. 进程的结构通常程序是不能并发执行的，为了使程序及它所要使用的资源能独立运行，OS为程序配置了一个特殊的数据结构进程控制块PCB(Process Control Block)，PCB用来存储程序向前执行过程中所要记录的有关运行信息，即该进程动态之行的相关资料。因此： 进程实体 = 程序段 + 相关数据段 + PCB 1.3.3. 进程的特征进程作为OS的一个实体有以下5个特征。 动态性。进程是程序的一次执行，因此进程是动态的，具有生命期。 并发性。多个进程实体在一段时间内能够并发执行，从而提高系统资源利用率。 独立性。每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位。 异步性。各进程按各自独立的、不可预知的速度向前推进。对单CPU系统而言，任何时刻只能有一个进程占用CPU。 结构性。每个进程的结构都由程序段、数据段和PCB组成。 1.3.4. 进程和程序的区别 程序是指令的有序集合，是静态的；Process是程序在CPU上的一次执行，是动态的； 程序作为软件可以长期保存；Process有自己的生命周期； 程序不会占有和调度资源；Process会为其分配和调度资源； 进程与程序之间无一一对应关系，一个程序可以多次执行产生多个进程，不同进程也可以包含同一个程序； 程序是记录在存储介质上的指令有序集合；进程则由程序段、数据段、PCB组成。 2. 进程的状态及转换2.1. 5状态进程模型进程有5个状态：创建、就绪、运行、阻塞、终止，下面对其一一说明。 进程的创建。通常有4件事会导致新进程的产生： 在一个批处理环境中，为了响应一个任务的要求而产生进程； 在一个交互式环境中，当一个新用户企图登录时会产生进程； 操作系统代替用户程序产生进程； 由用户程序产生进程。通常进程都是由操作系统产生的，但是一个进程也可以产生另一个进程，分别称为父进程和子进程。 进程的终止。当一个进程执行到自然结束点，或因不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程进入终止态。处于终止态的进程不能被再次调度执行，与其相关的数据信息由OS临时保存，随后OS逐步释放为其分配的资源，最后释放PCB。 进程的就绪。进程获得了除CPU之外的所需资源，一旦得到CPU就可运行。就绪状态的进程会组成就绪队列。 进程的运行。进程获得了CPU和其他资源，正在CPU上运行时的状态。 进程的阻塞。进程运行中发生了某种等待事件(如I/O操作)而暂时不能运行的状态，此状态的进程不能竞争CPU，而需要等事件完成后转到就绪态才能竞争。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Operating-System/"}],"tags":[{"name":"Process","slug":"Process","permalink":"http://fengggggggg.github.io/tags/Process/"}]},{"title":"Introduction To Computer","slug":"computer_science/Computer_Basic/introduction","date":"2014-02-22T16:00:00.000Z","updated":"2014-02-22T16:00:00.000Z","comments":true,"path":"2014/02/23/computer_science/Computer_Basic/introduction/","link":"","permalink":"http://fengggggggg.github.io/2014/02/23/computer_science/Computer_Basic/introduction/","excerpt":"《计算机组装与维修技术》阅读笔记","text":"《计算机组装与维修技术》阅读笔记 1.计算机及其组成什么是计算机计算机全称电子计算机，俗称电脑、PC等，是一种用于计算的机器，其种类繁多，包括个人计算机、高性能计算机、服务器等。 计算机的组成一个完整的可正常工作的计算机包括硬件和软件两个部分： 1. 计算机硬件硬件是指组成计算机的实体部件，从外观上来看硬件包括：主机、显示器、键盘、鼠标、音响、打印机、扫描仪等，其中主机使整个计算机最重要的组件，一般的，主机都包括: CPU：Central Processing Uint，计算机核心的核心，目前CPU的生产厂商有Intel和AMD两家公司，市场占比大约82开 主板：承担着操控和协调CPU、声卡、显卡等部件的任务 显卡 风扇 电源 网卡 声卡 2. 计算机软件软件是指在硬件上运行的各种程序，例如聊天软件、游戏软件，其中操作系统也是软件的一种，例如Unbuntu、Windows等 2. CPUCPU作为计算机的核心，其性能指标包括以下几种： 主频：即CPU的时钟频率，单位为MHz或GHz，标示CPU的运算速度，CPU的主频=外频x倍频 外频：CPU的总线频率，是由主板为CPU提供的基准时钟频率，单位为MHz，外频决定了主板的运行速度。通常我们在台机中所说的超频，就是指超CPU的外频，大部分CPU外频和主板频率是同步运行的，如果改变外频可能会导致系统不稳定 倍频：CPU主频和外频之间的倍率，一般情况下CPU的倍频是锁定的，有的CPU可以调节倍频 前端总线频率：也称FSB带宽，是CPU与内存间的数据交换的速率，一般数据带宽=(总线频率x数据位宽)/8 缓存：由于CPU和内存处理数据速度不一致，因而引入了缓存，一般而言CPU中有2～3级缓存，L1 Cache是一级缓存，由SRAM组成 3. 主板主板是一块印刷电路板PCB，一般采用4或6层板，4层板包括主板信号层、接地层、电源层、次信号层，6层板多了辅助电源层和中信号层，6层的抗电磁干扰能力更强。一般主板有如下几个组件： 芯片组：芯片组主要由BIOS芯片、南北桥芯片、磁盘阵列RAID、控制芯片等组成 BIOS芯片：BIOS芯片是一块方块型的存储器，里面存有与该主板搭配的基本输入输出系统程序，改程序能够让主板识别各种硬件，以及设置引导系统、调整CPU外频等，BIOS芯片是可写入的。 南北桥：横跨AGP插槽左右两侧的两块芯片就是南北桥芯片。南桥芯片多位于PCI插槽的上方；而CPU插槽旁边，被散热片盖住的则是北桥芯片，一般而言主板的命名都是以北桥的核心名称命名的。北桥芯片主要负责处理CPU、内存、显卡三者之间的交互；南桥负责硬盘等存储设备和PCI之间的数据流通。南北桥合称芯片组。现代的一些高端主机会将南北桥芯片封装到一起。 RAID：控制芯片 总线：总线是主板的重要组成部分，各个部件通过插槽连接到总线上，通常包括：CPU插槽、内存插槽、AGP插槽(用于插AGP显卡，目前逐渐被PCI Express插槽取缔)、PCI插槽(插声卡、网卡等)、CNR插槽(插CNR接口的软Modem或网卡) 对外接口：硬盘接口(一般都是SATA接口)、软驱接口、COM接口(连接串行鼠标和外置Modem等)、PS/2接口(仅用于连接键鼠，目前逐渐被USB接口取代)、USB接口、LPT接口(连接打印机或扫描仪)、MIDI接口(声卡和游戏杆，目前逐渐淘汰)。 4. 内存内存是有内存芯片、电路板、金手指(即内存条边缘的一排金黄色导电触片)等组成，当计算机运行时，CPU就会把运行所需的数据从硬盘中调到内存中，运算完成后再传出，目前市面上流行的内存类型为DDR3和DDR4，DDR即双倍速率同步动态随机存储器Double Data Rate Synchronous Dynamic Random Access Memory的简称，DDR在每个时钟的上升沿和下降沿各传输一次数据 性能指标 内存主频：内存的运行速度 内存容量 CAS延迟：内存读写数据所需的时延 5. 显卡显卡即显示接口卡、显示适配器、显示器配置卡，承担输出图形显示的重要任务。由于显卡的特性，它特别适合处理矩阵运算，因此显卡在现代机器学习中扮演了重要的角色。在机器学习中通常会有大量的矩阵操作，所以可以将这部分操作送给显卡中的GPU去操作。显卡一般分为两种 集成显卡：即芯片组中集成了显卡，这样的芯片组也称为整合型芯片，集显一般没有显存，而是使用内存作为其显存，因此其性能和独显相比较差 独立显卡：显卡成独立的板卡，通常有自己的显存 显卡的基本结构如下： GPU:图形处理芯片 显存 显卡BIOS:驱动程序之间的控制程序,存有显卡的型号、规格、生产厂家及出场时间等 输出接口 显卡PCB板 性能指标 显卡频率：显卡的工作频率，通常越高越好 显存位宽：一个时钟周期内所能传送数据的位数，市场上主流的有128位、256位、320位等 显存在显卡上工作时的频率 显存容量：主流的是256MB和512MB 3D API：显卡与应用程序之间的接口 6. 声卡声卡是实现模拟信号/数字信号相互转换的一种硬件，一般分为板卡式(目前已被淘汰)、集成式(主流)和外置式三种，声卡的基本构成有： 声音控制芯片：可通过数模转换器将模拟信号转换成数字信号，或反过来 DSP：执行和声音处理有关的命令、执行压缩解压缩程序、增加特殊声效和传真Modem等，高档声卡一般配有DSP CODEC：编解码器 输入输出接口 跳线：用于设置声卡的硬件设备，包括CD-ROM的I/O地址、声卡的I/O地址设置。 性能指标 采样频率：每秒从连续信号中采样出离散信号的个数，单位Hz。通俗地讲是指计算机美妙采集多少个声音样本 采样位数：即采样值或取样值，用来衡量声音波动变化的参数，含义是声卡在采集和播放声音文件时所使用数字声音信号的二进制位数 信噪比SNR：放大器的输出信号的电压与同时输出的噪声电压的比例，单位分贝，一般信噪比越高，说明信号李的噪声越小，声音质量越高 频率响应：系统或计量传感器的阻抗随频率的变化 7. 硬盘硬盘是计算机中的存储器件，一般的机械硬盘由一个或多个铝制或玻璃制的碟片组成，碟片外覆盖有铁磁性材料。传统的机械硬盘其内部构造包括： 磁头：负责对磁盘进行读写，与磁盘表面的磁性物质发生作用，一般有MR磁头和GMR磁头，硬盘里的磁头数=磁盘盘体数x2 盘体：存储数据的主体，有一或多个盘片叠在一起组成，盘体有以下几个概念： 磁道：一个盘片的一个面上的一个同心圆成为一个磁道，一般内侧磁道和外侧磁道存储量不同 扇区：每个磁道都被分为若干个弧段，这些弧段就是扇区，每个扇区可以存放512字节的信息，磁盘读写数据以扇区为单位 柱面：每个盘面上相同位置的磁道组成一个柱面，硬盘容量=柱面数x磁头数x扇区数x512B 主轴电机：用于驱动盘体转动的设备，主流的为7200转/分钟 寻道电机、驱动臂：寻道电机带动磁头在盘体上寻道，驱动臂把磁头和寻道电机连接在一起 性能指标 容量 转速：单位为转/分钟或RPM，转的越快，其传输率越高，发热量越大 平均访问时间：磁头从起始位置找到需要读写的数据位置的时间，体现了硬盘的读写速度。一般包括了平均寻道时间和平均等待时间，平均寻道时间是指磁头移动到指定磁道所需的时间，平均等待时间磁头已经在目标磁道，等待所需访问的扇区转至磁头下方所需时间 传输速率：包括内部传输速率和外部传输速率，内部传输速率指未用硬盘缓冲区时的性能，外部传输速率是系统总线与硬盘缓冲区之间的传输速率 缓存：硬盘也有缓存，是硬盘控制器上的一块内存芯片 固态硬盘SSD是一种新型的硬盘，由固态电子存储芯片阵列组成，其存储介质一般有闪存(FLASH)和DRAM两种，和传统硬盘比，SSD有读写速度快、低功耗、无噪声、体积小等优点，也有造价高、使用寿命短的缺点。关于SSD的使用寿命，也就是SSD擦写次数限制，闪存完全擦写一次叫做一次P/E，因此闪存的寿命以P/E为单位，一般34nm的闪存寿命为5000P/E，25nm的为3000P/E。不过由于SSD固件算法升级，SSD能提供更少的不必要写入量。 举个例子，一款128G的SSD，要写入128G的文件才算做一次P/E，即使每天写入50G的内容，2.5天才能完成一次P/E，一年也才用去150次左右的P/E，一块3000P/E的SSD够用200年了。 8. BIOS和CMOSBIOS是基本输入输出系统。启动计算机时，CPU首先根据集成在主板、显卡等设备上的BIOS芯片来核对每个基础设备是否正常，然后从硬盘中拷贝操作系统到内存中。BIOS有3个基本功能： 自检及初始化：开机后BIOS最先被启动，然后BIOS会检查计算机硬件设备，若设备正常才会启动操作系统 程序服务：BIOS直接与计算机的I/O设备交互，实现软件程序对硬件的直接操作 设定中断 CMOS是指互补金属氧化物半导体，是计算机主板上的一块可读写的RAM芯片，用来保存当前系统的硬件配置和用户对某些参数的设定。CMOS由主板的可充电电池供电，即使系统断电CMOS中的信息也不会丢失。 通常计算机中的开机密码存储在CMOS中，当忘记密码时，可以抠下主板上的电池，将CMOS放电，放电后CMOS内容会被清空，因而密码也会被清除。","categories":[{"name":"Computer Science","slug":"Computer-Science","permalink":"http://fengggggggg.github.io/categories/Computer-Science/"},{"name":"Computer Basic","slug":"Computer-Science/Computer-Basic","permalink":"http://fengggggggg.github.io/categories/Computer-Science/Computer-Basic/"}],"tags":[{"name":"Basic","slug":"Basic","permalink":"http://fengggggggg.github.io/tags/Basic/"}]}]}
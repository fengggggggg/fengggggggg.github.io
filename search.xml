<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>熵权法</title>
      <link href="/2019/09/05/mathematics/entropy_weight_method/"/>
      <url>/2019/09/05/mathematics/entropy_weight_method/</url>
      
        <content type="html"><![CDATA[<p>熵权法计算权值，Python3实现</p><hr><a id="more"></a><h2 id="1-输入矩阵"><a href="#1-输入矩阵" class="headerlink" title="1. 输入矩阵"></a>1. 输入矩阵</h2><p>假设计算矩阵为：$x=[[1,2,2],[2,1,1]]$</p><h2 id="2-极差标准化"><a href="#2-极差标准化" class="headerlink" title="2. 极差标准化"></a>2. 极差标准化</h2><p>评价指标分为正指标和逆指标，计算公式如下</p><p>$$x_{ij}’=\frac{x_{ij} - \min_{j=1}^n x_{ij}}{\max_{j=1}^n x_{ij} - \min_{j=1}^n x_{ij}}$$</p><p>此处仅展示正指标计算公式。<br>将所有指标都视为正指标，标准化后的$x=[[0,1,1],[1,0,0]]$，因为标准化后存在0值，需要将矩阵各分量加1，因此矩阵应当变为$x=[[1,2,2],[2,1,1]]$</p><h2 id="3-计算指标信息熵"><a href="#3-计算指标信息熵" class="headerlink" title="3. 计算指标信息熵"></a>3. 计算指标信息熵</h2><p>$e$应当为$1*n$大小的矩阵，式中$e_j$代表第$j$项指标的信息熵，信息熵的计算公式为：<br>$$e_j = (-\frac{1}{\ln m})\sum_{i=1}^m (p_{ij} \cdot \ln p_{ij})$$<br>其中$p_{ij}$<br>为第$j$个指标的状态为$i$时的概率，即<br>$$p_{ij}= \frac{x_{ij}}{\sum_{i=1}^m x_{ij}}$$<br>因此<br>$$e_j = (-\frac{1}{\ln m})\sum_{i=1}^m (\frac{x_{ij}}{\sum_{i=1}^m x_{ij}} \cdot \ln(\frac{x_{ij}}{\sum_{i=1}^m x_{ij}}))$$<br>应用到上述矩阵，可以得到$e=[0.9183, 0.9183, 0.9183]$即</p><table><thead><tr><th align="center">指标名称</th><th align="center">信息熵</th></tr></thead><tbody><tr><td align="center">指标1</td><td align="center">0.9183</td></tr><tr><td align="center">指标2</td><td align="center">0.9183</td></tr><tr><td align="center">指标3</td><td align="center">0.9183</td></tr></tbody></table><h2 id="4-计算指标权重"><a href="#4-计算指标权重" class="headerlink" title="4.计算指标权重"></a>4.计算指标权重</h2><p>$w$应当为$1*n$大小的矩阵，式中$w_j$代表第$j$项指标的权重<br>$$w_j = \frac{1 - e_j}{\sum_{j=1}^n (1-e_j)}$$<br>应用到上述$e$，可以得到$w=[0.33, 0.33, 0.33]$，即</p><table><thead><tr><th align="center">指标名称</th><th align="center">权重</th></tr></thead><tbody><tr><td align="center">指标1</td><td align="center">0.33</td></tr><tr><td align="center">指标2</td><td align="center">0.33</td></tr><tr><td align="center">指标3</td><td align="center">0.33</td></tr></tbody></table><h2 id="5-计算指标贡献度"><a href="#5-计算指标贡献度" class="headerlink" title="5. 计算指标贡献度"></a>5. 计算指标贡献度</h2><p>$$U=\sum_{j=1}^n w_j \cdot x_{ij}$$</p><p>使用上述$w$计算可以得到 $U \approx 3$</p><h2 id="6-Coding"><a href="#6-Coding" class="headerlink" title="6. Coding"></a>6. Coding</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># language = python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从excel表格中读入数据</span></span><br><span class="line">file = <span class="string">"test.xlsx"</span></span><br><span class="line">data = pd.read_excel(file, header = <span class="literal">None</span>)</span><br><span class="line">print(<span class="string">"读入数据为:\n"</span>, data)</span><br><span class="line"></span><br><span class="line">m, n = data.shape</span><br><span class="line"></span><br><span class="line">x = data.values</span><br><span class="line">x_2 = x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    min_xi = x[i].min()</span><br><span class="line">    max_xi = x[i].max()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        x_2[i][j] = (x[i][j] - min_xi) / (max_xi - min_xi) + <span class="number">1</span></span><br><span class="line">print(<span class="string">"标准化后矩阵为:\n"</span>, x_2)</span><br><span class="line"></span><br><span class="line">p = x_2 / x_2.sum(axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">e = (<span class="number">-1</span>/ np.log(m)) * np.nan_to_num(p * np.log(p)).sum(axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">w = (<span class="number">1</span> - e) / np.sum(<span class="number">1</span> - e)</span><br><span class="line"></span><br><span class="line">U = np.sum(w * x_2)</span><br><span class="line">print(<span class="string">"U = %f"</span> % U)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动2020校招笔试题</title>
      <link href="/2019/08/11/computer_science/Algorithm/xor1/"/>
      <url>/2019/08/11/computer_science/Algorithm/xor1/</url>
      
        <content type="html"><![CDATA[<p>字节跳动2020校招笔试真题</p><hr><a id="more"></a><h2 id="1-第二题"><a href="#1-第二题" class="headerlink" title="1. 第二题"></a>1. 第二题</h2><p>对于给定的一串0/1串，我们给定一种加密方式：</p><p>将字符串右移K-1次，每次右移一位，随后将这K串0/1串异或，得到的结果就是密文。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K = 2</span><br><span class="line">原始明文 = 101111</span><br><span class="line">右移一次 =  101111</span><br><span class="line">加密密文 = 1110001</span><br></pre></td></tr></table></figure><p>现给出加密后的密文、原文的长度以及K，求原文。</p><h2 id="2-第三题"><a href="#2-第三题" class="headerlink" title="2. 第三题"></a>2. 第三题</h2><p>第三题其实就是<a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">LeetCode第135题</a>。</p><p><strong>题目描述</strong></p><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>解法</strong></p><p>使用一个数组C用来保存最终每个孩子分到的糖果数，先将数组C初始化为全1，表示每个孩子至少分到一个糖果。</p><p>随后从左边第1个元素开始向右遍历，如果当前孩子评分比前一个高，则该孩子分到的糖果比前一个孩子多1个，否则还是1个。</p><p>最后从右边第1个元素向左遍历，如果当前孩子比后一个评分高，如果当前孩子已有的糖果数比后一个孩子多，则不变，否则比后一个孩子多分一个糖果；如果当前孩子比后一个孩子评分低，则当前孩子分的糖果数不变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ratings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candy(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            candy[i] = (ratings[i] &gt; ratings[i - <span class="number">1</span>] ? (candy[i - <span class="number">1</span>] + <span class="number">1</span>): candy[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            candy[i] = (ratings[i] &gt; ratings[i + <span class="number">1</span>]) ? max(candy[i + <span class="number">1</span>] + <span class="number">1</span>, candy[i]) : candy[i];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            count += candy[i];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11/14/17新特性简单总结</title>
      <link href="/2019/08/11/computer_science/C&amp;C++/C++14%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/08/11/computer_science/C&amp;C++/C++14%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>C++11/14/17新特性简单总结</p><hr><a id="more"></a><h2 id="1-C-11新特性"><a href="#1-C-11新特性" class="headerlink" title="1. C++11新特性"></a>1. C++11新特性</h2><p>包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进</p><h3 id="1-auto关键字"><a href="#1-auto关键字" class="headerlink" title="1. auto关键字"></a>1. auto关键字</h3><p>C++11中引入auto第一种作用是为了自动类型推导，auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作。需要注意的是，<strong>使用auto声明一个变量时，必须对其进行初始化</strong>，因为auto是通过初始化表达式进行类型推导的。</p><h3 id="2-decltype关键字"><a href="#2-decltype关键字" class="headerlink" title="2. decltype关键字"></a>2. decltype关键字</h3><p>decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型</p><h3 id="3-nullptr"><a href="#3-nullptr" class="headerlink" title="3. nullptr"></a>3. nullptr</h3><p>nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0</p><h3 id="4-序列for循环"><a href="#4-序列for循环" class="headerlink" title="4. 序列for循环"></a>4. 序列for循环</h3><p>在C++中for循环可以使用类似python的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator）</p><h3 id="5-Lambda表达式"><a href="#5-Lambda表达式" class="headerlink" title="5. Lambda表达式"></a>5. Lambda表达式</h3><p>lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数]（操作符重载函数参数）-&gt;返回值类型&#123;函数体&#125;</span><br></pre></td></tr></table></figure><h3 id="6-其他。。。"><a href="#6-其他。。。" class="headerlink" title="6. 其他。。。"></a>6. 其他。。。</h3><h2 id="2-C-14新特性"><a href="#2-C-14新特性" class="headerlink" title="2. C++14新特性"></a>2. C++14新特性</h2><p>C++14的新特性主要分为三个领域：Lambda函数、constexpr和类型推导。</p><ul><li>函数返回类型auto</li><li>lambda参数auto</li><li>lambda捕获参数初始化</li><li>[[deprecated]]</li><li>二进制常量0b/0B</li><li>单引号分位符0b1111’0000</li><li>模板变量</li></ul><h2 id="3-C-17新特性"><a href="#3-C-17新特性" class="headerlink" title="3. C++17新特性"></a>3. C++17新特性</h2><ol><li>结构化绑定auto</li><li>[a, b]构造函数模板推导std::pair{1, 5.0}</li><li>inline变量</li><li>if constexpr</li><li>fold表达式</li><li>非类型模板参数auto</li><li>satic_assert自定义错误信息</li><li>typename代替class声明模板的模板参数</li><li>嵌套命名空间namespace X::Y {…}</li><li>新增加属性[[fallthrough]] [[maybe_unused]] [[nodiscard]]</li><li>if/switch初始化</li><li>string_view</li><li>variant/any/optional</li><li>void_t</li><li>container.extract</li><li>删除trigraphs（即三连字符??*)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中结构体和类的区别</title>
      <link href="/2019/08/10/computer_science/C&amp;C++/different_between_struct_and_class/"/>
      <url>/2019/08/10/computer_science/C&amp;C++/different_between_struct_and_class/</url>
      
        <content type="html"><![CDATA[<p>C++中结构体和类的区别</p><hr><a id="more"></a><h2 id="1-C和C-中struct的不同"><a href="#1-C和C-中struct的不同" class="headerlink" title="1. C和C++中struct的不同"></a>1. C和C++中struct的不同</h2><ol><li>C中的结构体只能定义成员变量，不能定义成员函数，C++可以；</li><li>C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性；</li><li>C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1;</li><li>C++中之所以要引入结构体，是为了保持和C程序的兼容性。C++中不使用结构体丝毫不会影响程序的表达能力，但有时仍会在C++中使用结构体，这是因为使用结构体将不同类型数据组成整体便于保存数据。（若用类来保存，因类中成员默认为私有，还要为每个数据成员特定函数来读取和改写各个属性，比较麻烦。）</li></ol><h2 id="2-C-中struct和class的不同"><a href="#2-C-中struct和class的不同" class="headerlink" title="2. C++中struct和class的不同"></a>2. C++中struct和class的不同</h2><p>C++中struct和class唯一的不同是<strong>struct和class具有不同的默认访问控制属性</strong>，class中的成员的默认控制访问属性为private，而struct中的默认访问控制属性为public。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法总结与比较</title>
      <link href="/2019/08/08/computer_science/Algorithm/sort/"/>
      <url>/2019/08/08/computer_science/Algorithm/sort/</url>
      
        <content type="html"><![CDATA[<p>本文总结了目前常见的几种排序算法，包括冒泡、选择、插入、快排、堆排等。</p><hr><a id="more"></a><h2 id="1-总体比较"><a href="#1-总体比较" class="headerlink" title="1. 总体比较"></a>1. 总体比较</h2><p><strong>时间复杂度与稳定性</strong></p><table><thead><tr><th align="center">类别</th><th align="center">名称</th><th align="center">平均复杂度</th><th align="center">最好情况</th><th align="center">最差情况</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">交换比较类</td><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">交换比较类</td><td align="center">快速排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(logn)$</td><td align="center">不稳定</td></tr><tr><td align="center">选择类</td><td align="center">选择排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">选择类</td><td align="center">堆排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">插入类</td><td align="center">直接插入</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">插入类</td><td align="center">二分排序</td><td align="center">$O(n^2)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(n^2)$</td><td align="center">–</td><td align="center">稳定</td></tr><tr><td align="center">插入类</td><td align="center">希尔排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">$O(n^s)1$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">其他</td><td align="center">归并排序</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">基数排序</td><td align="center">$O(log_R B)$</td><td align="center">–</td><td align="center">$O(log_R B)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">二叉排序</td><td align="center">$O(nlogn)$</td><td align="center">–</td><td align="center">$O(nlogn)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">计数排序</td><td align="center">$O(n+k)$</td><td align="center">–</td><td align="center">$O(n+k)$</td><td align="center">$O(k)$</td><td align="center">稳定</td></tr><tr><td align="center">其他</td><td align="center">拓扑排序</td><td align="center">$O(n+e)$</td><td align="center">–</td><td align="center">–</td><td align="center">$O(n)$</td><td align="center">–</td></tr><tr><td align="center">其他</td><td align="center">枚举排序</td><td align="center">$O(n^2)$</td><td align="center">–</td><td align="center">–</td><td align="center">–</td><td align="center">–</td></tr></tbody></table><p><strong>算法特性</strong></p><table><thead><tr><th align="center">名称</th><th align="center">时间复杂度与初序</th><th align="center">移动次数与初序</th><th align="center">比较次数与初序</th><th align="center">排序趟数与初序</th><th align="center">每趟确定最终位置</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td align="center">快速排序</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td></tr><tr><td align="center">选择排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">-</td></tr><tr><td align="center">堆排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">-</td><td align="center">⭕️</td></tr><tr><td align="center">直接插入</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">⭕️</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">二分排序</td><td align="center">-</td><td align="center">-</td><td align="center">❌</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">希尔排序</td><td align="center">⭕️</td><td align="center">-</td><td align="center">⭕️</td><td align="center">-</td><td align="center">❌</td></tr><tr><td align="center">归并排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">⭕️</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">基数排序</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">二叉排序</td><td align="center">⭕️</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">计数排序</td><td align="center">⭕️</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">拓扑排序</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">枚举排序</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p>冒泡排序是一种典型的交换排序算法，相邻两数两两⽐比较并交换，直到所有数据排序完成，每一趟排序总能够将无序队列中的最⼤/小置于队尾。<br><strong>适用情况</strong>: 待排序列列较小时性能较优。<br><strong>最坏情况</strong>: 初始序列基本有序但顺序相反<br><strong>最好情况</strong>: 初始序列列基本有序(没有插⼊快，因为要两两比较)<br><strong>应用</strong>: 对基本有序序列查前n个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.size() - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">                swap(<span class="built_in">array</span>[j + <span class="number">1</span>], <span class="built_in">array</span>[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p>反复选择未排序序列中最大或最小元素，并将其放于已排序序列尾部，直到未排序序列长度为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="built_in">array</span>.size(); j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-直接插入排序"><a href="#4-直接插入排序" class="headerlink" title="4. 直接插入排序"></a>4. 直接插入排序</h2><p>将数据分为有序和无序两部分，首先有序部分为空，依次从无序部分中拿出元素插入到有序序列中<br><strong>可能出现情况</strong>: 最后一趟开始前，所有元素都不在正确位置上<br><strong>最佳情况</strong>: 基本有序下，插⼊排序是最快的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[i], j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>n越⼤大越好<br><strong>优点</strong>: 当待排序列列较大，内存一次性放不不下时，需要外部排序，通常使用归并排序<br><strong>归并趟数</strong>: m个元素k路归并趟数$s = log_k m$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)<span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> MergeSort(<span class="built_in">array</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l1, j = l2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(<span class="built_in">array</span>.size());</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[j])</span><br><span class="line">            temp[index++] = <span class="built_in">array</span>[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[index++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= r1)</span><br><span class="line">        temp[index++] = <span class="built_in">array</span>[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r2)</span><br><span class="line">        temp[index++] = <span class="built_in">array</span>[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        <span class="built_in">array</span>[l1 + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(<span class="built_in">array</span>, left, mid);</span><br><span class="line">        MergeSort(<span class="built_in">array</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        Merge(<span class="built_in">array</span>, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p>分治法<br><strong>优点</strong>: 平均最快，平均比较次数最少<br><strong>最好情况</strong>: 每次能够均匀划分<br><strong>最坏情况</strong>: 序列有序，或不均匀划分<br><strong>优化</strong>: 快排需要使用递归，因此处理左右子段时，先处理短子段可以减少时间复杂度。先处理短⼦段的话，每次递归深度都是短⼦段的长度<br><strong>对排序对象的要求</strong>: 待排序列的存储方式是顺序存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)<span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> QuickSort(<span class="built_in">array</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[right] &gt; temp)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="built_in">array</span>[left] = <span class="built_in">array</span>[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[left] &lt; temp)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="built_in">array</span>[right] = <span class="built_in">array</span>[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[left] = temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = Partition(<span class="built_in">array</span>, left, right);</span><br><span class="line">        QuickSort(<span class="built_in">array</span>, left, pos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(<span class="built_in">array</span>, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 探索初级算法 字符串</title>
      <link href="/2019/08/07/computer_science/LeetCode/Primary_Algorithm_String/"/>
      <url>/2019/08/07/computer_science/LeetCode/Primary_Algorithm_String/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://leetcode-cn.com/problems/reverse-string/submissions/" target="_blank" rel="noopener">反转字符串</a></li><li><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">整数反转</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></li><li><a href="https://leetcode-cn.com/problems/valid-anagram/submissions/" target="_blank" rel="noopener">有效的字母异位词</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文字符串</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">字符串转换整数(atoi)</a></li><li><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现strStr()</a></li><li>报数</li><li>最长公共前缀</li></ol><hr><a id="more"></a><h2 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。你可以假设数组中的所有字符都是ASCII码表中的可打印字符。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><h3 id="解法1：双指针法"><a href="#解法1：双指针法" class="headerlink" title="解法1：双指针法"></a>解法1：双指针法</h3><p>设置双指针i、j分别指向头尾，交换头尾后各向中间进1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(s[i], s[j]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="解法2：reverse函数"><a href="#解法2：reverse函数" class="headerlink" title="解法2：reverse函数"></a>解法2：reverse函数</h3><p>直接使用reverse()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2. 整数反转"></a>2. 整数反转</h2><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><h3 id="解法：模拟栈"><a href="#解法：模拟栈" class="headerlink" title="解法：模拟栈"></a>解法：模拟栈</h3><p>每次对x取%10余，并将余数×10累加到res中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cur;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX/<span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; cur &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN/<span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; cur &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(log(x))$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="3-字符串中的第一个唯一字符"><a href="#3-字符串中的第一个唯一字符" class="headerlink" title="3. 字符串中的第一个唯一字符"></a>3. 字符串中的第一个唯一字符</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">返回2.</span><br></pre></td></tr></table></figure><h3 id="解法：hash表"><a href="#解法：hash表" class="headerlink" title="解法：hash表"></a>解法：hash表</h3><p>使用map保存字符-位置键对，且这一键对的值为该字符出现的次数。随后从头按字符出现的次序遍历map，第一个键值为1的便是解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            hash[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (hash[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">**复杂度分析**</span><br><span class="line"></span><br><span class="line">- 时间复杂度：$O(n)$</span><br><span class="line">- 空间复杂度：$O(n)$</span><br></pre></td></tr></table></figure><h2 id="4-有效的字母异位词"><a href="#4-有效的字母异位词" class="headerlink" title="4. 有效的字母异位词"></a>4. 有效的字母异位词</h2><p>给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aacc&quot;, t = &quot;ccac&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="解法：hash表-1"><a href="#解法：hash表-1" class="headerlink" title="解法：hash表"></a>解法：hash表</h3><p>使用26大小的数组作为hash表，同时遍历s和t，并在对应位分别++和–。最后再遍历一遍hash表，如果存在不为0的元素，则说明s和t字符不对应，即不是异位词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() != t.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            count[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            count[t[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : count)</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="5-验证回文字符串"><a href="#5-验证回文字符串" class="headerlink" title="5. 验证回文字符串"></a>5. 验证回文字符串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="解法：双指针法"><a href="#解法：双指针法" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h3><p>利用双指针分别从头和尾进行比较，两个关键函数：isalnum()判断是否为字母数字，以及tolower()转换成小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i++]) != <span class="built_in">tolower</span>(s[j--]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="6-字符串转换整数-atoi"><a href="#6-字符串转换整数-atoi" class="headerlink" title="6. 字符串转换整数(atoi)"></a>6. 字符串转换整数(atoi)</h2><p>请你来实现一个atoi函数，使其能将字符串转换成整数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这题实在是太麻烦了，各种意想不到的输入都需要考虑到，因此这里提供一个懒人方法，使用sstream库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">        is &gt;&gt; digit;</span><br><span class="line">        <span class="keyword">return</span> digit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="7-实现strStr"><a href="#7-实现strStr" class="headerlink" title="7. 实现strStr()"></a>7. 实现strStr()</h2><p>给定一个haystack字符串和一个needle字符串，在haystack字符串中找出needle字符串出现的第一个位置(从0开始)。如果不存在，则返回-1</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h3 id="解法1：暴力求解"><a href="#解法1：暴力求解" class="headerlink" title="解法1：暴力求解"></a>解法1：暴力求解</h3><p>从头至尾遍历一遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)) :</span><br><span class="line">            <span class="keyword">if</span> needle == haystack[i : i + len(needle)]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(nm)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="解法2：KMP算法"><a href="#解法2：KMP算法" class="headerlink" title="解法2：KMP算法"></a>解法2：KMP算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getnext(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=str.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next.push_back(<span class="number">-1</span>);<span class="comment">//next数组初值为-1</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">-1</span>||str[j]==str[k]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(str[j]!=str[k])</span><br><span class="line">                    next.push_back(k);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    next.push_back(next[k]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k=next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//源串</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//子串</span></span><br><span class="line">        <span class="keyword">int</span> len1=haystack.size();</span><br><span class="line">        <span class="keyword">int</span> len2=needle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next=getnext(needle);</span><br><span class="line">        <span class="keyword">while</span>((i&lt;len1)&amp;&amp;(j&lt;len2)) &#123;</span><br><span class="line">            <span class="keyword">if</span>((j==<span class="number">-1</span>)||(haystack[i]==needle[j])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j=next[j];<span class="comment">//获取下一次匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len2)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n+m)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="解法3：BM算法"><a href="#解法3：BM算法" class="headerlink" title="解法3：BM算法"></a>解法3：BM算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_bmB</span><span class="params">(<span class="built_in">string</span>&amp; T,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bmB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tlen=T.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">            bmB.push_back(tlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tlen<span class="number">-1</span>;i++) &#123;</span><br><span class="line">            bmB[T[i]]=tlen-i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_suff</span><span class="params">(<span class="built_in">string</span>&amp; T,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tlen=T.size();</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tlen<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            k=i;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;=<span class="number">0</span>&amp;&amp;T[k]==T[tlen<span class="number">-1</span>-i+k])</span><br><span class="line">                k--;</span><br><span class="line">            suff[i]=i-k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_bmG</span><span class="params">(<span class="built_in">string</span>&amp; T,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bmG)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span> tlen=T.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suff(tlen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        get_suff(T,suff);<span class="comment">//suff存储子串的最长匹配长度</span></span><br><span class="line">        <span class="comment">//初始化 当没有好后缀也没有公共前缀时</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tlen;i++)</span><br><span class="line">            bmG[i]=tlen;</span><br><span class="line">        <span class="comment">//没有好后缀 有公共前缀 调用suff 但是要右移一位 类似KMP里的next数组</span></span><br><span class="line">        <span class="keyword">for</span>(i=tlen<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(suff[i]==i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;tlen<span class="number">-1</span>;j++)</span><br><span class="line">                    <span class="keyword">if</span>(bmG[j]==tlen)<span class="comment">//保证每个位置不会重复修改</span></span><br><span class="line">                        bmG[j]=tlen<span class="number">-1</span>-i;</span><br><span class="line">        <span class="comment">//有好后缀 有公共前缀</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tlen<span class="number">-1</span>;i++)</span><br><span class="line">            bmG[tlen<span class="number">-1</span>-suff[i]]=tlen<span class="number">-1</span>-i;<span class="comment">//移动距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tlen=needle.size();</span><br><span class="line">        <span class="keyword">int</span> slen=haystack.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bmG(tlen,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bmB;</span><br><span class="line">        get_bmB(needle,bmB);</span><br><span class="line">        get_bmG(needle,bmG);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=slen-tlen) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=tlen<span class="number">-1</span>;j&gt;<span class="number">-1</span>&amp;&amp;haystack[i+j]==needle[j];j--);</span><br><span class="line">            <span class="keyword">if</span>(j==(<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            i+=max(bmG[j],bmB[haystack[i+j]]-(tlen<span class="number">-1</span>-j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：最差$O(n+m)$，最好$O(n)$</li><li>空间复杂度：$O(n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 探索初级算法 数组</title>
      <link href="/2019/08/03/computer_science/LeetCode/Primary_Algorithm_Array/"/>
      <url>/2019/08/03/computer_science/LeetCode/Primary_Algorithm_Array/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">旋转数组</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">从数组中删除重复项</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机II</a></li><li><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复</a></li><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">两个数组的交集II</a></li><li><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一</a></li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></li><li><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">有效的数独</a></li><li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></li></ol><hr><a id="more"></a><h2 id="1-旋转数组"><a href="#1-旋转数组" class="headerlink" title="1. 旋转数组"></a>1. 旋转数组</h2><p>给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h3 id="解法1：暴力解法"><a href="#解法1：暴力解法" class="headerlink" title="解法1：暴力解法"></a>解法1：暴力解法</h3><p>旋转k次，每次将数组向右旋转移动一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre, tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[nums.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">            tmp = nums[j];</span><br><span class="line">            nums[j] = pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每次都将移动n个元素，总共移动k次，时间复杂度为$O(n*k)$</li><li>空间复杂度：仅使用了两个辅助变量，空间复杂度为$O(1)$</li></ul><h3 id="解法2：使用额外数组"><a href="#解法2：使用额外数组" class="headerlink" title="解法2：使用额外数组"></a>解法2：使用额外数组</h3><p>使用一个额外的数组，将原数组第i个位置上的元素放于新数组第(i+k)%array.size()位置上.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        arr[(i + k) % nums.size()] = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        nums[i] = arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于遍历了两次数组，因此时间复杂度为$O(2*n)$</li><li>空间复杂度：由于使用了临时数组，因此空间复杂度$O(n)$</li></ul><h3 id="解法3：使用环状替换"><a href="#解法3：使用环状替换" class="headerlink" title="解法3：使用环状替换"></a>解法3：使用环状替换</h3><p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量$temp$里面。然后，我们将被替换数字$(temp)$放到它正确的位置，并继续这个过程n次，n是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果$n%k==0$，其中$k=k%n$(因为如果k大于n，移动k次实际上相当于移动$k%n$次)。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>现在，我们看看上面方法的证明。假设，数组里我们有n个元素并且k是要求移动的次数。更进一步，假设$n%k=0$。第一轮中，所有移动数字的下标i满足$i%k==0$。这是因为我们每跳k步，我们只会到达相距为k个位置下标的数。每一轮，我们都会移动$n/k$个元素。下一轮中，我们会移动满足$i%k==1$的位置的数。这样的轮次会一直持续到我们再次遇到$i%k==0$的地方为止，此时i=k。此时在正确位置上的数字共有$k*(n/k)=n$个。因此所有数字都在正确位置上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.size(); start++) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = start;</span><br><span class="line">        <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> next = (current + k) % nums.size();</span><br><span class="line">            <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">            nums[next] = prev;</span><br><span class="line">            prev = temp;</span><br><span class="line">            current = next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：只遍历了一遍数组，$O(n)$</li><li>空间复杂度：只用了常数个额外空间，$O(1)$</li></ul><h3 id="解法4：数组反转"><a href="#解法4：数组反转" class="headerlink" title="解法4：数组反转"></a>解法4：数组反转</h3><p>先将所有数组反转，再反转前k个数组元素，最后再反转后n-k个数组元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.size())</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">    reverse(nums.begin(), nums.end());</span><br><span class="line">    reverse(nums.begin(), nums.begin() + k);</span><br><span class="line">    reverse(nums.begin() + k, nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$，没有使用额外空间</li></ul><h2 id="2-从数组中删除重复项"><a href="#2-从数组中删除重复项" class="headerlink" title="2. 从数组中删除重复项"></a>2. 从数组中删除重复项</h2><p>给定一个排序数组，你需要在<strong>原地删除重复出现的元素</strong>，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成.</p><h3 id="解法：双指针法"><a href="#解法：双指针法" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h3><p>数组完成排序后，可以放置两个指针i和j，其中i为慢指针，j为快指针，当nums[i]==nums[j]时，表示nums[i]到nums[j]之间为重复项，此时增加j以跳过重复项。当nums[i]!=nums[j]时，将num[j]赋值给nums[i+1]，并增加i。以数组[0, 1, 1, 2, 3, 3, 3]为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜ [0,1,1,2,3,3,3] ➜</span><br><span class="line"> i                   i                   i</span><br><span class="line"> j                   j                 j</span><br><span class="line"></span><br><span class="line">[0,1,1,2,3,3,3] ➜ [0,1,2,2,3,3,3] ➜ [0,1,2,3,3,3,3] ➜ ...</span><br><span class="line">       i                 i                   i</span><br><span class="line">   j                   j                   j</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j:nums)</span><br><span class="line">            <span class="keyword">if</span> (!i || j &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[i++] = j;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="3-买卖股票的最佳时机II"><a href="#3-买卖股票的最佳时机II" class="headerlink" title="3. 买卖股票的最佳时机II"></a>3. 买卖股票的最佳时机II</h2><p>给定一个数组，它的第i个元素是一支给定股票第i天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出,</span><br><span class="line">    　这笔交易所能获得利润=5-1=4。随后，在第4天（股票价格=3）的时候买入，</span><br><span class="line">    　在第5天（股票价格=6）的时候卖出,这笔交易所能获得利润=6-3=3。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出,</span><br><span class="line">    　这笔交易所能获得利润=5-1=4。注意你不能在第1天和第2天接连购买股票，</span><br><span class="line">    　之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h3 id="解法：暴力解法"><a href="#解法：暴力解法" class="headerlink" title="解法：暴力解法"></a>解法：暴力解法</h3><p>首先，当数组长度小于2时，不能进行一次完整的买卖，返回0，当数组长度大于2时，分两种情况讨论：</p><ul><li>一开始股市是升的：这种情况下从一开始就要购入，并将购买tag置为true。随后继续遍历数组，当遇到最高点时抛售股票。反复执行购买抛售，直到最后一天。如果最后一天tag仍然为true(对应示例2)，此时需要抛售，因此可在循环外加一个if判断；</li><li>一开始股市是降的：这种情况下就一直遍历数组，直到最低谷，随后将其视为第一种情况；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_buy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices[<span class="number">0</span>] &lt; prices[<span class="number">1</span>]) &#123;</span><br><span class="line">            profit -= prices[<span class="number">0</span>];</span><br><span class="line">            has_buy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (has_buy == <span class="literal">true</span> &amp;&amp; prices[i] &gt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                profit += prices[i];</span><br><span class="line">                has_buy = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_buy == <span class="literal">false</span> &amp;&amp; prices[i] &lt; prices[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                profit -= prices[i];</span><br><span class="line">                has_buy = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (has_buy == <span class="literal">true</span>)</span><br><span class="line">            profit += *(prices.end() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="4-存在重复"><a href="#4-存在重复" class="headerlink" title="4. 存在重复"></a>4. 存在重复</h2><p>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回true。如果数组中每个元素都不相同，则返回false。</p><h3 id="解法：使用unorder-set"><a href="#解法：使用unorder-set" class="headerlink" title="解法：使用unorder_set"></a>解法：使用unorder_set</h3><p>使用unorder_set，unorder_set是基于hashtable的按键唯一存储关联容器，容器内元素无序。因此可以遍历数组，如果遍历到的数在unorder_set不存在，则将其插入unorder_set，否则就返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.count(it) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">set</span>.insert(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="5-只出现一次的数字"><a href="#5-只出现一次的数字" class="headerlink" title="5. 只出现一次的数字"></a>5. 只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h3 id="解法：使用异或"><a href="#解法：使用异或" class="headerlink" title="解法：使用异或"></a>解法：使用异或</h3><p>该题可以使用暴力解法，但其时空消耗过大。此处介绍一种数学方法：由于除了欲找出的那个数字外，其余数字均出现两次，因此我们可以利用异或操作。异或的性质是，任何一个数字异或自己都为0，因此我们可以异或所有的数字而得到目标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">            ans ^= i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：仅遍历一次数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="6-两个数组的交集II"><a href="#6-两个数组的交集II" class="headerlink" title="6. 两个数组的交集II"></a>6. 两个数组的交集II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,3,4,5], nums2 = [2,3,5]</span><br><span class="line">输出: [2,3,5]</span><br></pre></td></tr></table></figure><h3 id="解法：使用find-函数"><a href="#解法：使用find-函数" class="headerlink" title="解法：使用find()函数"></a>解法：使用find()函数</h3><p>使用std::find()函数，如果从nums2中找到了和nums1中相同的数字，则放进res中，并从nums2中删去该数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.size();i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=find(nums2.begin(),nums2.end(),nums1[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=nums2.end()) &#123;</span><br><span class="line">                res.push_back(*it);</span><br><span class="line">                nums2.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：find函数遍历nums2整个数组，外层for循环遍历nums1数组，因此时间复杂度为$O(mn) \sim O(n^2)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="7-加一"><a href="#7-加一" class="headerlink" title="7. 加一"></a>7. 加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字123。</span><br></pre></td></tr></table></figure><h3 id="解法：反向遍历"><a href="#解法：反向遍历" class="headerlink" title="解法：反向遍历"></a>解法：反向遍历</h3><p>首先将数组最后一位加一，随后从后向前遍历直到第1个数，如果有一个数等于10，则将其变为0并将其前一位加一，退出循环后再判断第0个数是否为10，若为10则变为0并在数组首部插入1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        digits[digits.size() - <span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = digits.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                digits[i - <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">10</span>) &#123;</span><br><span class="line">            digits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="8-移动零"><a href="#8-移动零" class="headerlink" title="8. 移动零"></a>8. 移动零</h2><p>给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br><span class="line">说明: 必须在原数组上操作，不能拷贝额外的数组，尽量减少操作次数。</span><br></pre></td></tr></table></figure><h3 id="解法：双指针法-1"><a href="#解法：双指针法-1" class="headerlink" title="解法：双指针法"></a>解法：双指针法</h3><p>设置快指针i和慢指针j，其中i指针从头开始遍历，遇到0则继续遍历，遇到非0则停下，并交换nums[i]和nums[j]，慢指针j和i同步从头开始遍历，遇到0则停下并等待i，遇到非0则加1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：for循环遍历一遍数组，时间复杂度为$O(n)$</li><li>空间复杂度：仅使用了常数个辅助变量，空间复杂度为$O(1)$</li></ul><h2 id="9-两数之和"><a href="#9-两数之和" class="headerlink" title="9. 两数之和"></a>9. 两数之和</h2><p>给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [0,1]</span><br><span class="line">说明: 因为 nums[0] + nums[1] = 2 + 7 = 9,所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="解法1：暴力法"><a href="#解法1：暴力法" class="headerlink" title="解法1：暴力法"></a>解法1：暴力法</h3><p>暴力法很简单，遍历每个元素x，并查找是否存在一个值与target−x相等的目标元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                    ans.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="解法2：两遍哈希表"><a href="#解法2：两遍哈希表" class="headerlink" title="解法2：两遍哈希表"></a>解法2：两遍哈希表</h3><p>以空间换时间，使用hash表保存数组，在想hash表插入数的同时查找对应值是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash_set;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash_set.count(target - nums[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(hash_set[target - nums[i]]);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash_set[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="10-有效的数独"><a href="#10-有效的数独" class="headerlink" title="10. 有效的数独"></a>10. 有效的数独</h2><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="解法：一次遍历"><a href="#解法：一次遍历" class="headerlink" title="解法：一次遍历"></a>解法：一次遍历</h3><p>使用hash表。思想是遍历每一个格子，然后判断该格子的值是否已在hash表中，若已存在则返回false，否则记录入hash表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; rows(<span class="number">9</span>), cols(<span class="number">9</span>), boxes(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">int</span> box_index = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">char</span> n = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(n != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rows[i].count(n) || cols[j].count(n) || boxes[box_index].count(n))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    rows[i][n] = <span class="number">1</span>;</span><br><span class="line">                    cols[j][n] = <span class="number">1</span>;</span><br><span class="line">                    boxes[box_index][n] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(1)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="11-旋转图像"><a href="#11-旋转图像" class="headerlink" title="11. 旋转图像"></a>11. 旋转图像</h2><p>给定一个n×n的二维矩阵表示一个图像。将图像顺时针旋转90度。</p><p><strong>示例1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定matrix= </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解法：翻转"><a href="#解法：翻转" class="headerlink" title="解法：翻转"></a>解法：翻转</h3><p>先转置数组，即swap(nums[i][j], nums[j][i])，再翻转每一行。该方法已经达到了最优时间复杂度$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">            reverse(matrix[i].begin(), matrix[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的内联函数</title>
      <link href="/2019/07/30/computer_science/C&amp;C++/inline_in_C++/"/>
      <url>/2019/07/30/computer_science/C&amp;C++/inline_in_C++/</url>
      
        <content type="html"><![CDATA[<p>内联函数相关知识点梳理</p><hr><a id="more"></a><h2 id="1-内联函数的作用"><a href="#1-内联函数的作用" class="headerlink" title="1. 内联函数的作用"></a>1. 内联函数的作用</h2><p>引入内联函数inline的主要目的是，用它来代替C或C++中的表达式形式的宏定义，从而解决程序中函数调用的效率问题。在C或C++中，可以如下定义一个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Expression(a, b) (((a) + (b)) * ((a) - (b)))</span></span><br></pre></td></tr></table></figure><p>该宏定义用于计算两数的和差积。这种宏在形式上类似于函数，但它<strong>使用预处理器实现</strong>，没有参数压栈、代码生成等操作，因而效率很高。但与此同时，这种宏<strong>不能进行参数有效性检测</strong>，不能享受C++编译器类型检查带来的好处，因此这种宏的使用有一定的隐患和局限性。</p><p>另外，在C++的类中，当一个操作涉及到保护成员和私有成员时，类的访问控制机制使得这些成员不能通过上面的宏进行操作。</p><p>为此，inline推出的作用就是取代这种表达式形式的宏定义，消除表达式宏的缺点，继承表达式宏的优点。</p><h2 id="2-inline与宏定义的区别"><a href="#2-inline与宏定义的区别" class="headerlink" title="2. inline与宏定义的区别"></a>2. inline与宏定义的区别</h2><ul><li>inline函数的本质是一个函数，而宏不是；</li></ul><ul><li>inline函数在编译时展开，宏在预编译时展开；</li></ul><ul><li>在编译时，inline函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换；</li></ul><ul><li>inline可以完成参数类型检查、语法检查等编译功能，宏则不具备这样的功能；</li></ul><ul><li>宏定义时容易出现二义性(一般需要加很多括号以解决这个问题)，inline则不会出现这样的问题(本质是函数)。</li></ul><h2 id="3-inline的优点"><a href="#3-inline的优点" class="headerlink" title="3. inline的优点"></a>3. inline的优点</h2><ul><li>inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，像宏一样展开，没有了调用的开销，效率很高；</li></ul><ul><li>类的内联函数是一个真正的函数，在调用一个内联函数时，编译器会对其进行参数类型检查等相关检查，消除了隐患和局限性；</li></ul><ul><li>inline可以作为某个类的成员函数，可以使用所在类的保护成员变量和私有成员变量。</li></ul><h2 id="4-inline的使用场合"><a href="#4-inline的使用场合" class="headerlink" title="4. inline的使用场合"></a>4. inline的使用场合</h2><ul><li>用于取代表达式形式的宏定义；</li></ul><ul><li>用于C++类中私有成员或保护成员的存取函数定义。一般而言，类的外部想要访问类的私有成员，需要使用接口函数来对这些私有成员进行读写，如果将这些读写私有成员的函数定义为内联函数则能获得较高的效率(符号表替换)。需要注意的是，<strong>定义在类体内的函数会被自动转换成内联函数</strong>。</li></ul><h2 id="5-inline的缺点"><a href="#5-inline的缺点" class="headerlink" title="5. inline的缺点"></a>5. inline的缺点</h2><p><strong>inline是以代码复制为代价的</strong>，仅仅省去了函数调用的开销，从而提高函数的执行效率。<strong>若函数体内代码的执行时间相比于函数调用的开销大，那么使用inline的效率收益则较低</strong>。另外，<strong>每一处内联函数的调用都需要复制代码</strong>，会使程序的总代码量增大，消耗更多的内存空间。因此以下情况下不适合使用inline：</p><ul><li>函数体内代码较长：使用inline将导致较高的内存消耗；</li></ul><ul><li>函数体内出现循环：执行函数体内的代码的时间会比函数调用的开销大；</li></ul><ul><li>不用于类的构造函数和析构函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的数据类型及其大小</title>
      <link href="/2019/07/29/computer_science/C&amp;C++/data_type_in_C++/"/>
      <url>/2019/07/29/computer_science/C&amp;C++/data_type_in_C++/</url>
      
        <content type="html"><![CDATA[<p>在C/C++中的数据类型及其所占空间大小总结</p><hr><a id="more"></a><h2 id="1-内置数据类型"><a href="#1-内置数据类型" class="headerlink" title="1. 内置数据类型"></a>1. 内置数据类型</h2><p>常见的内置数据类型如下表所示，可以使用sizeof查看其大小：</p><table><thead><tr><th>type</th><th align="left">size</th></tr></thead><tbody><tr><td>char</td><td align="left">1B</td></tr><tr><td>unsigned char</td><td align="left">1B</td></tr><tr><td>signed char</td><td align="left">1B</td></tr><tr><td>int</td><td align="left">4B</td></tr><tr><td>unsigned int</td><td align="left">4B</td></tr><tr><td>signed int</td><td align="left">4B</td></tr><tr><td>short (int)</td><td align="left">2B</td></tr><tr><td>long (int)</td><td align="left">8B</td></tr><tr><td>float</td><td align="left">4B</td></tr><tr><td>double</td><td align="left">8B</td></tr><tr><td>long double</td><td align="left">16B</td></tr><tr><td>wchar_t</td><td align="left">2B or 4B</td></tr></tbody></table><p>其中wchar_t是宽字符型，其定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>也就是说，实际上wchar_t和short int是等价的。</p><h2 id="2-数组与字符串"><a href="#2-数组与字符串" class="headerlink" title="2. 数组与字符串"></a>2. 数组与字符串</h2><p>对数组使用sizeof运算，其大小为<strong>数组中元素的个数*元素所占内存大小</strong>，而对于char数组型的字符串，例如<br><code>char str[] = &quot;Hello&quot;</code>，其大小为字符个数+1，因为结尾需要保存<strong>\0</strong>。但需要注意的是，C++中的string类型的字符串其空间大小和char数组字符串不同，string是一个类，其声明的变量的大小是可变的，为了减少对内存的申请，一般在一开始声明变量时都会申请一块较大的内存，因此string类型的变量用sizeof得到的结果通常都比字符串中的字符数要大。</p><h2 id="3-自定义数据类型"><a href="#3-自定义数据类型" class="headerlink" title="3. 自定义数据类型"></a>3. 自定义数据类型</h2><h3 id="3-1-class及struct"><a href="#3-1-class及struct" class="headerlink" title="3.1. class及struct"></a>3.1. class及struct</h3><h4 id="3-1-1-空类"><a href="#3-1-1-空类" class="headerlink" title="3.1.1. 空类"></a>3.1.1. 空类</h4><p>对于一个空类，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大小为1B，因为C++中<strong>每一个类都有一个独一无二的地址</strong>，因此即使是空类也会为其分配1B的内存空间。</p><h4 id="3-1-2-类对象所占内存大小"><a href="#3-1-2-类对象所占内存大小" class="headerlink" title="3.1.2. 类对象所占内存大小"></a>3.1.2. 类对象所占内存大小</h4><p><strong>类所占的内存大小由其成员变量决定，成员函数不计算在内</strong>，但是如果一个struct、union或class B作为另一个类A的成员变量，这些玩意也不计入其内存大小，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof(A) = 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(B) = 4, 成员函数不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(C) = 1, 结构体不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stc1</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> sa;</span><br><span class="line">        <span class="keyword">char</span> sb;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(D) = 1, 联合体不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">union</span> un1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ua;</span><br><span class="line">        <span class="keyword">short</span> ub;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(E) = 1, class不计入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">cl1</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ca;</span><br><span class="line">        <span class="keyword">short</span> cb;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-类对象的字节对齐"><a href="#3-1-3-类对象的字节对齐" class="headerlink" title="3.1.3. 类对象的字节对齐"></a>3.1.3. 类对象的字节对齐</h4><p>由于不同的硬件对存储空间的处理方式不同，一些硬件对某些特定类型的数据只能<strong>从某些特定地址开始存取</strong>，如果不对其，会给存取效率带来损失。</p><p>字节对齐的细节和编译器的实现有关，一般而言，字节对齐遵守三个准则：</p><ol><li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节；</li><li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。</li></ol><p>如果类中包含虚函数，则<strong>无论其有多少个虚函数，这些虚函数所占内存均为4B</strong>，因为内存中需要保存一个虚表指针成员</p><p>举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ii;</span><br><span class="line">    <span class="keyword">short</span> j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ii;</span><br><span class="line">    <span class="keyword">int</span> iii;</span><br><span class="line">    <span class="keyword">short</span> j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">J</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A, <span class="keyword">virtual</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ii;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(A) = 4</span></span><br><span class="line"><span class="comment">// sizeof(B) = 1</span></span><br><span class="line"><span class="comment">// sizeof(C) = 4 + 1 + 3(规则3补齐) = 8</span></span><br><span class="line"><span class="comment">// sizeof(D) = 4 + 2 + 1 + 1(规则3补齐) = 8</span></span><br><span class="line"><span class="comment">// sizeof(E) = 4 + 4 + 2 + 1 + 1 = 12</span></span><br><span class="line"><span class="comment">// sizeof(F) = 4 + 4 + 4 + 2 + 1 + 1 = 16</span></span><br><span class="line"><span class="comment">// sizeof(G) = 1 + 3(规则2填充) + 4 + 2 + 2(规则3补齐) = 12</span></span><br><span class="line"><span class="comment">// sizeof(H) = 4 + 4 = 8 (!!!在Mac中，指针的大小为8，因此sizeof(H)= 4 + 4(规则2填充) + 8 = 16)</span></span><br><span class="line"><span class="comment">// sizeof(I) = 4 + 1 + 3(规则3填充) = 8 (继承也需要用相同规则进行字节对齐)</span></span><br><span class="line"><span class="comment">// sizeof(J) = 8</span></span><br><span class="line"><span class="comment">// sizeof(K) = (4 + 4) + (1 + 4) + 3(规则3对齐) = 16</span></span><br><span class="line"><span class="comment">// sizeof(L) = 4 (静态成员变量和全局变量一样存放于静态存储区中，被每一个类的实例共享，不计入类空间中)</span></span><br></pre></td></tr></table></figure><h3 id="3-2-union"><a href="#3-2-union" class="headerlink" title="3.2. union"></a>3.2. union</h3><p>联合体的大小取决于该体中<strong>所有的成员中占用空间最大的一个成员的大小</strong>，并且同样的需要对齐：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> u1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> u2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> u3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(u1) = 8;</span></span><br><span class="line"><span class="comment">// sizeof(u2) = 13 + 3(以int的整数倍补齐);</span></span><br><span class="line"><span class="comment">// sizeof(u3) = 13;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下GDB的使用</title>
      <link href="/2019/07/27/computer_science/Linux/gdb_in_ubuntu/"/>
      <url>/2019/07/27/computer_science/Linux/gdb_in_ubuntu/</url>
      
        <content type="html"><![CDATA[<p>最近项目中经常需要使用GDB，因此总结了一下在使用GDB时遇到的技巧</p><hr><a id="more"></a><h2 id="1-使用GDB调试可执行文件"><a href="#1-使用GDB调试可执行文件" class="headerlink" title="1. 使用GDB调试可执行文件"></a>1. 使用GDB调试可执行文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb a.out               <span class="comment"># 不带参数</span></span><br><span class="line">或</span><br><span class="line">gdb --args a.out 参数   <span class="comment"># 带参数</span></span><br></pre></td></tr></table></figure><h2 id="2-GDB常用命令"><a href="#2-GDB常用命令" class="headerlink" title="2. GDB常用命令"></a>2. GDB常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">r [args]                <span class="comment"># 带参数从头开始执行程序</span></span><br><span class="line">b arg                   <span class="comment"># 在arg处设置断点，arg可以为行数、地址</span></span><br><span class="line">b xxx <span class="keyword">if</span> (condition)    <span class="comment"># 条件断点</span></span><br><span class="line">b test.c:30 <span class="keyword">if</span> n==100   <span class="comment"># 当变量n等于100的时候在test.c的30行处加断点</span></span><br><span class="line">n (next)                <span class="comment"># 单步执行，如遇函数则直接返回函数的执行结果</span></span><br><span class="line">s (step)                <span class="comment"># 单步执行，如遇函数则进入函数体执行</span></span><br><span class="line">stop                    <span class="comment"># 停止执行</span></span><br><span class="line">q (quit)                <span class="comment"># 退出GDB</span></span><br><span class="line">until                   <span class="comment"># 当不想反复执行循环时，可以用until跳出循环</span></span><br><span class="line">finish                  <span class="comment"># 跳出当前函数</span></span><br><span class="line">c (<span class="built_in">continue</span>)            <span class="comment"># 继续执行，直到下一个断点或程序结束</span></span><br><span class="line">p arg                   <span class="comment"># 打印出arg的值，arg可以为变量或地址</span></span><br><span class="line">whatis variable         <span class="comment"># 打印出变量的类型</span></span><br><span class="line">ptype variable          <span class="comment"># 打印出变量的类型，只不过比whatis更详细</span></span><br><span class="line">i variables variable    <span class="comment"># 打印出定义variable的文件</span></span><br><span class="line">i <span class="built_in">source</span>                <span class="comment"># 查看当前程序</span></span><br><span class="line">i b                     <span class="comment"># 查看arg，arg可以为断点、变量值、</span></span><br><span class="line">i args                  <span class="comment"># 打印出当前函数的参数值</span></span><br><span class="line">i locals                <span class="comment"># 打印出当前函数中所有局部变量值</span></span><br><span class="line">i r (r_name)            <span class="comment"># 查看所有寄存器(寄存器r_name)的值</span></span><br><span class="line">i threads               <span class="comment"># 查看线程</span></span><br><span class="line">d b                     <span class="comment"># 删除断点，b为断点编号</span></span><br><span class="line">bt                      <span class="comment"># 查看函数的back trace</span></span><br><span class="line">l (list) arg            <span class="comment"># 显示arg附近的前后共10行代码，arg可以为行数或函数名</span></span><br><span class="line">watch arg               <span class="comment"># 设置监控，在arg改变时停止(需要先加断点)</span></span><br></pre></td></tr></table></figure><h2 id="3-设置断点"><a href="#3-设置断点" class="headerlink" title="3. 设置断点"></a>3. 设置断点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当欲设断点在当前文件中时，可以b+行数或b+函数名</span></span><br><span class="line">b 45/main</span><br><span class="line"><span class="comment"># 当欲设断点在其他文件中时，b 文件名:行数</span></span><br><span class="line">b head.cpp:45</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中const、define和static</title>
      <link href="/2019/07/03/computer_science/C&amp;C++/const_define_static_in_C++/"/>
      <url>/2019/07/03/computer_science/C&amp;C++/const_define_static_in_C++/</url>
      
        <content type="html"><![CDATA[<p>关键字const、define和static相关知识点整理</p><hr><a id="more"></a><h2 id="1-const和define区别"><a href="#1-const和define区别" class="headerlink" title="1. const和define区别"></a>1. const和define区别</h2><ol><li>宏定义的本质是文本替换，编译器会在编译之前将所有的宏定义替换，它的生命周期仅存在于编译器；宏定义没有数据类型，不进行类型检查;</li><li>const常量存在于程序的数据段，并在<strong>堆栈</strong>分配了地址空间。它的生命周期一直存在；const常量有数据类型，进行类型检查;</li></ol><h2 id="2-C-中关键字const的作用"><a href="#2-C-中关键字const的作用" class="headerlink" title="2. C++中关键字const的作用"></a>2. C++中关键字const的作用</h2><ol><li>定义常量;</li><li>修饰函数形参：当函数参数为用户自定义类型或抽象数据类型时，将“值传递”改为const引用传递可以提高效率。例如如下两个函数，第一个函数效率较低，因为函数体内会产生一个A类型的临时对象用于复制a，浪费存储空间，临时对象的构造、复制、析构消耗时间。第二个函数使用“引用传递”，不需要产生临时对象，但是如果是简单地引用可能会改变a的值，所以可以加一个const:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A <span class="keyword">const</span> &amp;a)</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>修饰函数的返回值：被const修饰的指针函数，因为其返回值是const类型，所以其返回值只能返回给const常量:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">GetChar</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> *ch = GetChar();       <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ch = GetChar()  <span class="comment">//correct</span></span><br></pre></td></tr></table></figure><ol start="4"><li>const修饰类的成员函数：任何不会修改数据成员的函数都应该用const修饰，防止修改数据成员。其形式如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GeoCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-静态变量static"><a href="#3-静态变量static" class="headerlink" title="3. 静态变量static"></a>3. 静态变量static</h2><h3 id="1-static的作用"><a href="#1-static的作用" class="headerlink" title="1. static的作用"></a>1. static的作用</h3><ol><li>一个static变量可以维持其值在被调用的过程中不变；</li><li>在一个模块内的static变量，可以被模块内的函数访问，但不能被模块外的函数访问；</li><li>模块内的一个static修饰的<strong>函数</strong>只可以被该模块内的函数调用。</li></ol><h3 id="2-static变量和普通变量的区别"><a href="#2-static变量和普通变量的区别" class="headerlink" title="2. static变量和普通变量的区别"></a>2. static变量和普通变量的区别</h3><h4 id="1-static全局变量和普通全局变量"><a href="#1-static全局变量和普通全局变量" class="headerlink" title="1. static全局变量和普通全局变量"></a>1. static全局变量和普通全局变量</h4><ol><li>static全局变量只初始化一次，防止在其他单元文件中被引用；普通全局变量，可以在多个文件声明，但是只能在一个文件中赋值；</li><li>static全局变量其作用域是当前文件，在其他文件中不可用，普通全局变量在其他文件中可用；</li><li>（相同点）两种都以<strong>静态存储方式</strong>存储；</li></ol><h4 id="2-static局部变量和普通局部变量"><a href="#2-static局部变量和普通局部变量" class="headerlink" title="2. static局部变量和普通局部变量"></a>2. static局部变量和普通局部变量</h4><ol><li>static局部变量只被初始化一次，下一次使用依据上一次的结果</li></ol><h4 id="3-static函数和普通函数"><a href="#3-static函数和普通函数" class="headerlink" title="3. static函数和普通函数"></a>3. static函数和普通函数</h4><ol><li>static函数在内存中只有一份，普通函数在每个被调用中维持一份复制品；</li><li>static函数作用域仅在本文件中，普通函数可在其他文件被调用；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> C &amp; C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Array</title>
      <link href="/2019/06/29/computer_science/Data_Structure/array/"/>
      <url>/2019/06/29/computer_science/Data_Structure/array/</url>
      
        <content type="html"><![CDATA[<p>学习数组时的一个简单的笔记</p><hr><a id="more"></a><h2 id="数组及其初始化"><a href="#数组及其初始化" class="headerlink" title="数组及其初始化"></a>数组及其初始化</h2><p>对于一个只声明未赋值的int型数组，如果该数组为全局变量，该数组会被初始化为0，若为局部变量，则被初始化为乱值；</p><hr><h2 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h2><p><strong>稀疏矩阵</strong>：对于一个稀疏矩阵(即矩阵中的大部分元素为0)，可以使用三元组表示法对其压缩。在一个三元组中，每一个一个条目都形如(行号, 列号, 值)，稀疏矩阵中的每一个非零值由三元组表中的条目唯一表示。稀疏矩阵经过三元组压缩存储后，会失去随机存取能力；</p><p><strong>特殊矩阵</strong>：特殊矩阵形如上三角矩阵、对角矩阵、对称矩阵等，特殊矩阵的压缩存储并不会丧失随机存取的能力。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS/Ubuntu 18.10 安装PyTorch</title>
      <link href="/2019/03/30/computer_science/Linux/PyTorch_for_Linux/"/>
      <url>/2019/03/30/computer_science/Linux/PyTorch_for_Linux/</url>
      
        <content type="html"><![CDATA[<p>MacOS/Ubuntu 18.10 安装PyTorch</p><a id="more"></a><hr><h2 id="1-MacOS-Ubuntu-18-10-安装Conda管理环境"><a href="#1-MacOS-Ubuntu-18-10-安装Conda管理环境" class="headerlink" title="1. MacOS/Ubuntu 18.10 安装Conda管理环境"></a>1. MacOS/Ubuntu 18.10 安装Conda管理环境</h2><p>MacOS下前往Anaconda官网下载安装即可<br>Linux下，从官网下载的是一个.sh文件，下载后终端执行zsh xxxx.sh并根据指示安装即可.<br>如果安装后使用zsh启动conda显示找不到conda，可以在.zshrc文件中添加<em>export PATH=”/home/user_name/anaconda3/bin:$PATH”</em>并source一下即可</p><hr><h2 id="2-MacOS-Ubuntu-18中安装PyTorch"><a href="#2-MacOS-Ubuntu-18中安装PyTorch" class="headerlink" title="2. MacOS/Ubuntu 18中安装PyTorch"></a>2. MacOS/Ubuntu 18中安装PyTorch</h2><ol><li>(可选) 为了避免各种软件的版本冲突问题，推荐使用python虚拟环境，在虚拟环境中安装pytorch</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n environment_name python=X.X (2.7/3.6)   # 创建虚拟环境</span><br><span class="line">conda info --env    # 显示所有的conda虚拟环境</span><br><span class="line">conda activate environment_name # 激活虚拟环境</span><br></pre></td></tr></table></figure><ol start="2"><li>修改安装镜像源并安装PyTorch，由于国外的conda源安装速度很慢，因此建议改为清华源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> for Anaconda</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> for PyTroch</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><ol start="3"><li>安装PyTorch</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision</span><br><span class="line">conda deactivate    # 使用结束后退出虚拟环境</span><br></pre></td></tr></table></figure><hr><h2 id="3-虚拟环境中安装jupyter"><a href="#3-虚拟环境中安装jupyter" class="headerlink" title="3. 虚拟环境中安装jupyter"></a>3. 虚拟环境中安装jupyter</h2><p>如果是新建的虚拟环境，即使你之前已经安装了anaconda，也有可能需要重新在虚拟环境中重新安装jupyter</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install jupyter</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> MacOS </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Queue</title>
      <link href="/2019/03/04/computer_science/Data_Structure/Queue/"/>
      <url>/2019/03/04/computer_science/Data_Structure/Queue/</url>
      
        <content type="html"><![CDATA[<p>A note to queue</p><hr><a id="more"></a><h2 id="1-循环队列"><a href="#1-循环队列" class="headerlink" title="1. 循环队列"></a>1. 循环队列</h2><ol><li>计算大小为n的循环队列中元素的个数</li></ol><center>$(rear - front + n) % n$</center> <center>$(rear - front + n + 1) % n$</center><ol start="2"><li>循环队列判空</li></ol><center>$front = rear$</center><ol start="3"><li>循环队列判满</li></ol><center>$(rear + 1) % n = front $</center><ol start="4"><li>出队后头指针front的值</li></ol><center>$ front = (front + 1) % m $</center>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.10安装LLVM</title>
      <link href="/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/"/>
      <url>/2018/12/30/computer_science/Linux/LLVM_for_Ubuntu/</url>
      
        <content type="html"><![CDATA[<p>因为课题需要使用LLVM，因此在Ubuntu上安装了LLVM 8.0 Debug版本</p><hr><a id="more"></a><h2 id="1-安装cmake"><a href="#1-安装cmake" class="headerlink" title="1.安装cmake"></a>1.安装cmake</h2><p>安装LLVM需要使用cmake，可以使用如下命令安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><h2 id="2-修改swap分区-可选，不推荐"><a href="#2-修改swap分区-可选，不推荐" class="headerlink" title="2.修改swap分区(可选，不推荐)"></a>2.修改swap分区(可选，不推荐)</h2><p>从源码安装LLVM Debug版本时，链接过程会占用大量内存，因此可以尝试使用修改sawp分区加快安装进程。步骤如下：</p><ol><li>查看系统中已有的交换空间,如果没有条目或swap为0则说明没有可用交换空间:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon --show</span><br><span class="line">or</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><ol start="2"><li>检查磁盘使用情况,一般/dev下的设备是我们的磁盘，swap分区应小于此值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><ol start="3"><li>在根目录(/)下创建名为swapfile的swap文件， 一般我们使用fallocate命令， 建议将swap分区设为20G以满足安装LLVM需求。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a     # 先关闭所有的swap分区，否则可能因为系统中存在swap分区而报错fallocate: fallocate failed: Text file busy，</span><br><span class="line">sudo fallocate -l 20G /swapfile     # 创建swapfile</span><br><span class="line">ls -lh /swapfile    # 验证是否成功创建swapfile，</span><br></pre></td></tr></table></figure><p>　　如果显示<em>-rw——1 root root 20G 日期 /swapfile</em> 则表示创建成功</p><ol start="4"><li>启用交换文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 600 /swapfile    # 锁定swapfile权限</span><br><span class="line">sudo mkswap /swapfile       # 将文件标记为交换空间</span><br></pre></td></tr></table></figure><p>　　若显示:<em>Setting up swapspace……</em> 则表示成功标记swapfile，标记之后启用该文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon /swapfile   # 启用</span><br><span class="line">free -h                 # 验证</span><br></pre></td></tr></table></figure><ol start="5"><li>永久保留swap文件：虽然我们更改了swap分区，但是重启后不会保留设置，因此可以将将swap文件添加到/etc/fstab来将其永久保留</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/fstab /etc/fstab.bak   # 备份</span><br><span class="line">echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab  # 将swap文件信息添加到/etc/fstab文件</span><br></pre></td></tr></table></figure><hr><h2 id="3-安装LLVM-8-0-Debug版本"><a href="#3-安装LLVM-8-0-Debug版本" class="headerlink" title="3.安装LLVM-8.0 Debug版本"></a>3.安装LLVM-8.0 Debug版本</h2><ol><li>首先去<a href="http://releases.llvm.org/download.html#8.0.0" target="_blank" rel="noopener">LLVM官网</a>下载必要的软件包;</li><li>获取源码:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在适当位置放置LLVM源码，此处放在home下</span><br><span class="line">cd ~</span><br><span class="line">mkdir tmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压LLVM源码</span><br><span class="line">cd tmp</span><br><span class="line">tar -Jxvg llvm-7.0.0.src.tar.xz</span><br><span class="line">mv llvm-7.0.0.src llvm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压clang源码(此时在tmp目录下)</span><br><span class="line">cd llvm/tools</span><br><span class="line">tar -Jxvg cfe-7.0.0.src.tar.xz</span><br><span class="line">mv cfe-7.0.0.src clang</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压clang-tools-extra源码(此时在tmp/llvm/tools目录下)</span><br><span class="line">cd clang/tools</span><br><span class="line">tar -Jxvg clang-tools-extra-7.0.0.src.tar.xz</span><br><span class="line">mv clang-tools-extra-7.0.0.src extra</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压compiler-rt源码(此时在tmp/llvm/tools/clang/tools目录下)</span><br><span class="line">cd ~/tmp/llvm/projects</span><br><span class="line">tar -Jxvg compiler-rt-7.0.0.src.tar.xz</span><br><span class="line">mv compiler-rt-7.0.0.src compiler-rt</span><br></pre></td></tr></table></figure><ol start="3"><li>开始安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在tmp目录下新建build文件夹</span><br><span class="line">cd build</span><br><span class="line">cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug ../llvm</span><br><span class="line">make -j2 # 使用两个CPU核安装，该步骤既慢且卡，推荐设置为核心数一半</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 将路径添加到环境变量中</span><br><span class="line">cd ~</span><br><span class="line">vim .bashrc</span><br><span class="line">export PATH=/usr/lib/llvm-7/bin</span><br><span class="line">export LD_LIBRARY_PATH=/usr/lib/llvm-7/lib</span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><ol start="4"><li>重启终端并测试</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -v</span><br><span class="line">clang++ -v</span><br><span class="line">clang test.c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.10安装与配置</title>
      <link href="/2017/06/04/computer_science/Linux/install_ubuntu/"/>
      <url>/2017/06/04/computer_science/Linux/install_ubuntu/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu 18.10安装与配置</p><a id="more"></a><hr><h2 id="1-安装Ubuntu-18-10"><a href="#1-安装Ubuntu-18-10" class="headerlink" title="1. 安装Ubuntu 18.10"></a>1. 安装Ubuntu 18.10</h2><p>安装过程不多说，安装镜像可以去<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">中科大镜像</a>下载。</p><hr><h2 id="2-安装搜狗输入法"><a href="#2-安装搜狗输入法" class="headerlink" title="2. 安装搜狗输入法"></a>2. 安装搜狗输入法</h2><ol><li>前往<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">搜狗输入法官网</a>下载deb安装文件，双击安装；</li><li>前往Settings ➜ Region &amp; Language ➜ Nanage Installed Languages， 将键盘输入系统改为fcixt；</li><li>当前帐号注销并重新登入，打开应用菜单找到Fcitx Config Tool， 点击右下角的+，取消选定“只展示当前语言”，搜索”sogou”找到并添加搜狗输入法；</li><li>重启系统。</li></ol><hr><h2 id="3-修改软件源"><a href="#3-修改软件源" class="headerlink" title="3. 修改软件源"></a>3. 修改软件源</h2><p>应用菜单 ➜ Software &amp; Updates ➜ Download from ➜ Other ➜ China ➜ mirrors.ustc.edu.cn</p><hr><h2 id="4-安装Chrome"><a href="#4-安装Chrome" class="headerlink" title="4. 安装Chrome"></a>4. 安装Chrome</h2><p>前往<a href="https://www.google.cn/intl/zh-CN_ALL/chrome/" target="_blank" rel="noopener">Chrome官网</a>下载.deb安装包，双击安装即可。</p><hr><h2 id="5-开启夜览模式"><a href="#5-开启夜览模式" class="headerlink" title="5. 开启夜览模式"></a>5. 开启夜览模式</h2><p>夜览可以在Setting ➜ Device ➜ Night Light开启，但是默认的暖度过高，需要调整：</p><ol><li>打开Terminal安装dconf-editor</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dconf-editor</span><br></pre></td></tr></table></figure><ol start="2"><li>在终端打开dconf-editor</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><ol start="3"><li>dconf-editor ➜ org ➜ gnome ➜ setting-deamon ➜ plugins ➜ color ➜ night-light-temperature</li><li>关闭”Use default value”，并将温度值调到合适的值，一般5500比较合适</li></ol><hr><h2 id="6-系统美化"><a href="#6-系统美化" class="headerlink" title="6. 系统美化"></a>6. 系统美化</h2><p>安装Tweaks工具用以配置桌面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gnome-tweak-tool</span><br></pre></td></tr></table></figure><p>在应用菜单中打开Tweaks，在Window Titlebars中可以将窗口按钮调至左侧，在Tweaks ➜ Desktop中可以将桌面上令人捉急的Trash图标抹去。默认情况下无法通过Tweaks修改Shell外观，因此需要安装扩展，打开应用中心，找到Add-ons ➜ Shell Extension ➜ User Themes ➜ 安装。推荐的扩展还有：</p><ul><li>Weather In The Clock，点击屏幕上方的时间可以展示天气;</li><li>Dash to Dock，将Ubuntu原生应用栏变得和MacOS一样，不过默认的会自动隐藏，因此需要到应用中心中该扩展的设置里关闭autohide Hide Top Bar，自动隐藏顶部栏；</li></ul><hr><h2 id="7-配置终端"><a href="#7-配置终端" class="headerlink" title="7. 配置终端"></a>7. 配置终端</h2><ol><li>安装zsh与git</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh </span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><ol start="2"><li>安装oh-my-zsh</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><ol start="3"><li>将Shell切换到zsh，登出并重新登入</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><ol start="4"><li>在Home下的.zshrc文件中可以更换主题，个人比较喜欢ys主题</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME="ys"</span><br></pre></td></tr></table></figure><ol start="5"><li>安装一些强大的zsh插件<br>首当其冲的插件就是incr，一个超级强大的自动补全插件，下载该插件到Home目录下的/.oh-my-zsh/plugins/incr下，在.zshrc文件中添加命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.oh-my-zsh/plugins/incr/incr*.zsh</span><br></pre></td></tr></table></figure><ol start="6"><li>同时还推荐一些其他的插件，例如extract，在plugins=()语句括号中添加extract即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction To Data Structure</title>
      <link href="/2016/09/23/computer_science/Data_Structure/introduction/"/>
      <url>/2016/09/23/computer_science/Data_Structure/introduction/</url>
      
        <content type="html"><![CDATA[<p>对常见数据结构的一个简单地总结</p><hr><a id="more"></a><h2 id="1-数据结构定义"><a href="#1-数据结构定义" class="headerlink" title="1. 数据结构定义"></a>1. 数据结构定义</h2><p>数据结构是指<strong>相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成</strong>，记为：</p><center>$Data Structure = (D, R)$</center>其中$D$是数据元素的集合，$R$是$D$中元素之间的关系的集合。  <p>通俗的理解，<strong>数据结构=逻辑结构(线性、非线性) + 存储结构(顺序、链式、索引、散列)</strong></p><ul><li>逻辑结构：数据元素间抽象化的相互关系</li><li>存储结构：数据在计算机中的存储形式，也是物理结构</li></ul><hr><h2 id="2-逻辑结构"><a href="#2-逻辑结构" class="headerlink" title="2. 逻辑结构"></a>2. 逻辑结构</h2><p>数据的逻辑结构是指数据之间的逻辑关系，比如一对一、一对多、多对一、多对多等。通常，逻辑关系可以分为两种：线性关系和非线性关系。线性关系指：<strong>除第一个外，每个元素有且只有一个前驱；除最后一个元素外，每个元素有且只有一个后继</strong>。</p><p>常见的逻辑结构有以下几种：</p><ul><li><strong>集合</strong>：数据元素间没有任何关系</li><li><strong>线性结构</strong>：数据元素间存在线性关系</li><li><strong>树</strong>：数据元素间有层次关系</li><li><strong>图</strong>：数据元素间you网状关系</li></ul><p><strong>常见的线性结构</strong>：线性表、栈、队列、双队列、数组、串等<br><strong>常见的非线性结构</strong>：多维数组、树、图、广义表等</p><hr><h2 id="3-存储结构"><a href="#3-存储结构" class="headerlink" title="3. 存储结构"></a>3. 存储结构</h2><p>数据的存储结构是指数据在计算机中的存储形式，也是数据的物理结构。</p><p>常见的存储结构有以下几种：</p><ol><li><strong>顺序存储</strong>：逻辑上相邻的节点存储在物理位置上相邻的存储单元中，节点之间的逻辑关系由存储单元的邻接关系体现<ul><li>优点：可实现对节点的随机存取</li><li>缺点：不便于插入、删除，因为要大量移动数据</li></ul></li><li><strong>链式存储</strong>：逻辑上相邻的节点在物理存储上不相邻，而是通过指针等体现逻辑关系<ul><li>优点：便于插入、删除，存储密度比顺序存储小</li><li>缺点：不便于查找</li></ul></li><li><strong>索引存储</strong>：通过建立索引表来标识节点的地址</li><li><strong>散列存储</strong>：根据节点的关键字直接计算出节点的存储地址</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP中的拥塞控制简介</title>
      <link href="/2015/05/27/computer_science/Computer_Network/congestion_control/"/>
      <url>/2015/05/27/computer_science/Computer_Network/congestion_control/</url>
      
        <content type="html"><![CDATA[<p>TCP中的拥塞控制的目的是控制网络拥塞的出现，网络拥塞的原因多种多样，比如某结点的缓存太小、某段链路带宽太低等等。为了防止网络拥塞，V.Jacobson在1988年的论文中提出了用于TCP的拥塞控制，由慢开始和拥塞避免组成，后来在TCP Reno版本中又加入了快重传和快恢复。这4种技术能够很好的避免网络拥塞。</p><hr><a id="more"></a><h2 id="1-慢开始"><a href="#1-慢开始" class="headerlink" title="1. 慢开始"></a>1. 慢开始</h2><p>如果将网络通路比作高速公路，那么我们可以想象一下，如果这条路的出口只有一个车道，而入口却有很多车道，那么这条路必然会造成拥塞。慢开始就是针对这一情况而提出的。其基本思想是逐渐增大发送的数据大小(即拥塞窗口)直到指定的阈值(即慢开始阈值)。</p><p>在慢开始中，发送端除了要维护正常情况下根据接收端发来的窗口大小字段值而调整的<strong>发送窗口</strong>外，还要维护一个<strong>拥塞窗口(Congestion Window, CWND)</strong>，CWND的目的是为了避免发生拥塞，最终<strong>允许发送的字节数是CWND和发送窗口两者中的最小值</strong>。</p><p>下面介绍慢开始的具体步骤(假设CWND总是小于发送窗口)：</p><ol><li>在TCP传输连接建立时，发送端将CWND初始化为该连接上当前使用的最大数据段大小(Maximum Segment Size, MSS)，即CWND=MSS，然后发送端发送一个MSS大小的数据段M1。</li><li>如果在定时器过期前发送端收到了该数据段的确认(即对M1的确认)，则发送端将CWND大小翻倍，即CWND=2MSS，并发送2MSS大小的数据，假定发送的数据段位M2、M3。</li><li>同样的，如果在定时器过期前发送端接收到确定(收到M3的确认即可，即只用确认最后一个)，再次将CWND翻倍，并以此类推。</li><li>当出现数据丢失时，需要将<strong>慢开始阈值(Slow Start Threshold, SSTHRESH)</strong>设置为当前CWND的一半，并将CWND重设为1MSS。并重新开始慢开始，此时若CWND再次达到SSTHRESH便停止使用慢开始，转用拥塞避免。</li></ol><p>值得注意的是，一般SSTHRESH初始值为64KB。</p><p><img src="https://raw.githubusercontent.com/fengggggggg/figure_for_blog/master/13afefqewf23232f.png" alt></p><h2 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2. 拥塞避免"></a>2. 拥塞避免</h2><p>拥塞避免的基本思想是，当CWND再次达到SSTHRESH时，让拥塞窗口的大小每经过一个RTT(数据传输往返时间)时仅增加1MSS。如果这时还是发生了数据丢失，同样的还是把SSTHRESH设为当前CWND的一半，把CWND设为1MSS，并重新开始慢开始。</p><h2 id="3-快重传-快恢复"><a href="#3-快重传-快恢复" class="headerlink" title="3. 快重传/快恢复"></a>3. 快重传/快恢复</h2><p>快重传的基本思想是，当接收端收到一个不是按序到达的数据段时，TCP实体迅速发送一个重复ACK数据段，而不用等到有数据需要发送时才顺带发出重复ACK。在连续收到3个重复ACK数据段后，即认为对应确认号字段的数据丢失，TCP不等重传定时器超时就会重传丢失的数据段。</p><p>快恢复是在快重传发挥作用时，确切的说是收到第三个重复ACK时，把当前CWND设为当前SSTHRESH的一半，以减轻网络负载，然后执行拥塞避免算法。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见路由算法</title>
      <link href="/2015/04/14/computer_science/Computer_Network/routing_algorithm/"/>
      <url>/2015/04/14/computer_science/Computer_Network/routing_algorithm/</url>
      
        <content type="html"><![CDATA[<p>路由算法是指从源节点和目的节点之间选择一条最佳的路径用于传输数据。为了完成这个任务，在路由器中通常会收集和保存各种与传输路径相关的数据，如拓扑结构、端口度量、端口速率等，然后根据相应的路由算法生成路由表，在数据发送时提供路由选择。</p><p>一般而言，路由算法分为自适应路由算法和非自适应路由算法。</p><hr><a id="more"></a><h2 id="1-非自适应路由算法"><a href="#1-非自适应路由算法" class="headerlink" title="1. 非自适应路由算法"></a>1. 非自适应路由算法</h2><p>非自适应路由算法是指不能根据网络流量和拓扑结构的变化动态更新路由表的算法，这类算法使用静态路由表。</p><h3 id="1-1-静态路由"><a href="#1-1-静态路由" class="headerlink" title="1.1 静态路由"></a>1.1 静态路由</h3><p>静态路由是指由管理员手动在路由表中一条条添加路由选项，这种方法费时费力，都不能称之为算法。不过RapidIO中采用了这种方法，RapidIO是嵌入式通信网络之一，其路由表建立的方式之一就是将路由表烧进芯片里。</p><h3 id="1-2-扩散法"><a href="#1-2-扩散法" class="headerlink" title="1.2 扩散法"></a>1.2 扩散法</h3><p>扩散法是指当一个路由收到报文分组后，向它所有的端口复制扩散该报文。因为有多条路径，所以即使网络局部瘫痪也不影响通信，但是大量重复加重了网络负担，因此这种算法适合规模较小、通信负载轻、可靠性要求极高的通信场合，如军用通信。</p><h3 id="1-3-随机走动法"><a href="#1-3-随机走动法" class="headerlink" title="1.3 随机走动法"></a>1.3 随机走动法</h3><p>该方法指挡路有收到报文分组后，随机选择一个端口将其发送出去。这种方法通信效率低、实用价值低。</p><h3 id="1-4-最短路径法"><a href="#1-4-最短路径法" class="headerlink" title="1.4 最短路径法"></a>1.4 最短路径法</h3><p>该算法是指利用Dijkstra算法构建一个节点之间的最短路径，即跳数最少的路径，作为路由表。每次收到报文后查询路由表进行转发。</p><h3 id="1-5-基于流量的路由算法"><a href="#1-5-基于流量的路由算法" class="headerlink" title="1.5 基于流量的路由算法"></a>1.5 基于流量的路由算法</h3><p>最短路径算法只考虑网络拓扑结构，而基于流量的算法还会考虑网络流量及负载。</p><h2 id="2-自适应路由算法"><a href="#2-自适应路由算法" class="headerlink" title="2. 自适应路由算法"></a>2. 自适应路由算法</h2><p>自适应路由算法是指能根据网络流量和拓扑情况而动更新路由表的算法。该类算法一般分为两类，一类是路由中只保留相邻器的路由信息的分散式路由算法，另一类是保留网络(或部分网络)中所有路由器的全部信息的总体式路由算法。</p><h3 id="2-1-距离矢量路由算法"><a href="#2-1-距离矢量路由算法" class="headerlink" title="2.1 距离矢量路由算法"></a>2.1 距离矢量路由算法</h3><p>距离矢量路由算法(Distance Vector, DV)是分散式路由算法的一种，而DV是指源节点和目的节点之间所经过的路由器的数目减一(需要减去源节点直连路由器)，该距离也称为跳数。采用DV的经典路由协议有<strong>RIP</strong>、<strong>内部网关协议IGRP</strong>、<strong>增强型内部网关协议EIGRP</strong>和<strong>边界网关协议BGP</strong>。</p><h3 id="2-2-链路状态路由算法"><a href="#2-2-链路状态路由算法" class="headerlink" title="2.2 链路状态路由算法"></a>2.2 链路状态路由算法</h3><p>该算法是总体式路由算法的一种，又被称为最短路径优先算法，它和基于流量的路由算法有点类似，只是前者会动态更新路由表，而后者不会。使用该算法的路由协议有<strong>开放最短路径优先(OSPF)、中间系统-中间系统(IS-IS)、EIGPR(同时支持距离矢量算法和链路状态算法)</strong>等。</p><h3 id="2-3-分级路由算法"><a href="#2-3-分级路由算法" class="headerlink" title="2.3 分级路由算法"></a>2.3 分级路由算法</h3><p>前面两种自适应路由算法中，每个路由器都要保存其他路由器的一些信息，随着网络规模的增加，路由表的规模也会增大，从而使路由器不能有效的进行流量控制，分级路由算法可以解决这个问题。</p><p>在分级路由中，路由器被分成很多组，称之为区域。每个路由器都只有自己所在区域路由器的信息。使用该算法的有<strong>OSPF、IS-IS、BGP</strong>。</p><p>总的来说，在部分区域内，一般使用的是距离矢量路由算法和链路状态路由算法，而在全局网络中一般使用分级路由算法</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络物理层简介</title>
      <link href="/2015/03/22/computer_science/Computer_Network/physical_layer_in_network/"/>
      <url>/2015/03/22/computer_science/Computer_Network/physical_layer_in_network/</url>
      
        <content type="html"><![CDATA[<p>物理层是OSI体系结构中的最底层，而在TCP/IP协议中并没有单独的物理层，其功能由网络访问层实现。本文介绍物理层的几个特性与协议</p><hr><a id="more"></a><h2 id="1-物理层的主要作用"><a href="#1-物理层的主要作用" class="headerlink" title="1. 物理层的主要作用"></a>1. 物理层的主要作用</h2><p>物理层有如下几个作用</p><ul><li>构建数据通路：即两个通信端之间的可以连续传输数据的物理通路</li><li>透明传输：作为物理通路的材质可能有很多，例如双绞线、光纤等，物理层需要确保数据对这些材质透明，即不管什么材质都不影响数据传输</li><li>传输数据：既然是通路其基本功能就是传输数据。物理层的<strong>基本传输单元是bit</strong></li><li>数据编码：不同传输介质所支持的数据编码可能不同，如归零码、曼彻斯特码、差分曼彻斯特码等。物理层需要确保不同编码的数据能够正常在通路上传输</li><li>数据传输管理：对比特流的数据传输流量控制、差错控制、物理线路的激活与释放等</li></ul><h2 id="2-物理层特性"><a href="#2-物理层特性" class="headerlink" title="2. 物理层特性"></a>2. 物理层特性</h2><p>物理层需要规范其接口的特性，有了统一的标准，不同的厂商能够以相同的标准来实现彼此产品的互联</p><ol><li>机械特性：定义了传输介质接线器、物理接口的形状和尺寸、引线数目和排列顺序以及连接器与接口之间的固定和锁定装置</li><li>电气特性：规定了在通路上传输比特流时线路上信号电压的高低、阻抗匹配情况，以及传输速率和传输距离限制等参数属性，主要分为三类：<ul><li>非平衡型</li><li>差分接收器的非平衡型</li><li>平衡型</li></ul></li><li>功能特性：指传输介质中各条线上所出现的某一电平的含义，以及物理接口各条信号线的用途，包括：接口信号线的功能规定，接口信号线的功能分类。</li><li>规程特性：利用接口传输比特流的全过程以及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时，DTE/DEC双方在各自电路上的动作顺序。</li></ol><h2 id="3-物理层传输介质"><a href="#3-物理层传输介质" class="headerlink" title="3. 物理层传输介质"></a>3. 物理层传输介质</h2><ol><li>导向性传输介质<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul></li><li>非导向性传输介质<ul><li>短波无线传输</li><li>地面微波接力通信</li><li>卫星通信</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的拓扑结构</title>
      <link href="/2015/03/22/computer_science/Computer_Network/topology_of_network/"/>
      <url>/2015/03/22/computer_science/Computer_Network/topology_of_network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络拓扑结构是指网络中各个端点之间的逻辑结构，本文对其进行简单介绍</p><hr><a id="more"></a><h2 id="1-网络拓扑中的基本概念"><a href="#1-网络拓扑中的基本概念" class="headerlink" title="1. 网络拓扑中的基本概念"></a>1. 网络拓扑中的基本概念</h2><ol><li>节点：即一个网络端口，如PC；</li><li>结点：通常连接了多个节点，如路由器和交换机；</li><li>链路：两个节点之间的线路；</li><li>通路：两个节点之间的通信线路，可能包含多条链路。</li></ol><h2 id="2-星型拓扑结构"><a href="#2-星型拓扑结构" class="headerlink" title="2. 星型拓扑结构"></a>2. 星型拓扑结构</h2><p>目前应用最广的一种拓扑结构，各节点以交换机或集线器等设备连接在一起，其优点包括<strong>扩展方便</strong>、<strong>网速较快</strong>、<strong>易于维护</strong>，但缺点也很明显：<strong>核心交换机负载过重</strong>、<strong>通信过于依赖核心交换机</strong>等。</p><h2 id="3-环形拓扑结构"><a href="#3-环形拓扑结构" class="headerlink" title="3. 环形拓扑结构"></a>3. 环形拓扑结构</h2><p>这种网络因为传输速率低、扩展性差，已经被淘汰不用了，使用这种结构的有令牌环网。</p><h2 id="4-总线型拓扑结构"><a href="#4-总线型拓扑结构" class="headerlink" title="4. 总线型拓扑结构"></a>4. 总线型拓扑结构</h2><p>该结构中，所有设备都连接到一条总线上，和环形拓扑不同的是不形成闭环。总线型拓扑结构会在总线两端加装“终接器”的设备，主要用于与总线进行阻抗匹配，最大限度吸收传送端部的能量，避免信号反射回总线产生不必要的干扰。其优点有：<strong>结构简单</strong>、<strong>易于扩展</strong>、<strong>易于维护</strong>，缺点有：<strong>传输速率低</strong>、<strong>故障诊断苦难</strong>、<strong>难以实现大规模扩展</strong>；</p><h2 id="4-树形拓扑结构"><a href="#4-树形拓扑结构" class="headerlink" title="4. 树形拓扑结构"></a>4. 树形拓扑结构</h2><p>树根为核心交换机，叶节点为终端设备</p><h2 id="5-网状拓扑结构"><a href="#5-网状拓扑结构" class="headerlink" title="5. 网状拓扑结构"></a>5. 网状拓扑结构</h2><p>网络可靠性高、布线复杂</p><h2 id="6-混合型拓扑结构"><a href="#6-混合型拓扑结构" class="headerlink" title="6. 混合型拓扑结构"></a>6. 混合型拓扑结构</h2><p>应用广泛、维护困难</p><h2 id="7-WLAN的拓扑结构"><a href="#7-WLAN的拓扑结构" class="headerlink" title="7. WLAN的拓扑结构"></a>7. WLAN的拓扑结构</h2><ol><li>Ad-Hoc：点对点连接方式，只能单点通信，性能较差；</li><li>Infrastructure：和星型拓扑类似。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁问题</title>
      <link href="/2015/03/16/computer_science/Operating_System/deadlock/"/>
      <url>/2015/03/16/computer_science/Operating_System/deadlock/</url>
      
        <content type="html"><![CDATA[<p>关于死锁的一些归纳和总结</p><hr><a id="more"></a><h2 id="1-死锁产生的原因和必要条件"><a href="#1-死锁产生的原因和必要条件" class="headerlink" title="1. 死锁产生的原因和必要条件"></a>1. 死锁产生的原因和必要条件</h2><p>进程共享资源可能会导致死锁，而这些能导致死锁产生的资源基本上都是不可抢占性资源。</p><ol><li>可抢占性资源。即：即使该资源正在被一个进程使用，但当另一个优先级更高的进行想要使用该资源时，就可以将该资源抢占。例如CPU。</li><li>不可抢占性资源。某进程在获得这类资源后，该资源就不能再被其他进程所使用。因此该类资源通常都是互斥的。</li></ol><p>因此，死锁产生的中心就是资源问题，死锁的原因可以归纳为一下两点：</p><ol><li>系统资源不足。这是<strong>根本原因</strong>，当资源不足时，多个进程就可能因为竞争不可抢占资源而导致死锁，并且死锁总是发生在进程提出资源请求时；</li><li>进程推进顺序不当。由于系统中各进程都是独立向前推进，导致不能很好地协商如何分配资源。</li></ol><p>对死锁问题而言，其关键是找出死锁产生的必要条件，若必要条件不成立，则死锁可解，其必要条件有4：</p><ol><li>互斥条件。即资源应为互斥的，任一时刻一个资源仅能被一个进程占用；</li><li>请求和保持。一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经占有的资源；</li><li>不可抢占。进程所获得的资源在未使用完毕前不可被其他进程抢占；</li><li>循环等待。若干个进程形成循环等待链。</li></ol><h2 id="2-死锁的预防"><a href="#2-死锁的预防" class="headerlink" title="2. 死锁的预防"></a>2. 死锁的预防</h2><p>通过破坏死锁的必要条件来控制死锁的策略称为<strong>死锁预防</strong>，但是由于条件1无法破坏(进行互斥访问是不可抢占资源的固有特性)因此可以破坏其他3个条件。</p><ol><li>破坏请求和保持：可以在每个进程运行之前一次性将它运行所需的所有资源都分配给它，并在资源得不到满足前不投入运行，一旦投入运行就不可再申请新资源。这种方法的<strong>优点是安全简单易实现</strong>，<strong>缺点是：1. 浪费系统资源(一次性分配所有资源，但这些资源通常不会被全程使用)；2. 可能导致另一些进程因为分不到资源而长时间得不到运行；3. 很多进行在运行前并不确切的知道需要多少资源</strong>。</li><li>破坏不可抢占：当一个已拥有某些资源的进行提出新的要求而未被满足时，该进程应当释放自己已获得的资源。<strong>缺点很明显：1. 释放资源会导致前功尽弃；2. 该方法实现复杂代价大，反复申请和释放资源会使进程推进很慢；3. 可能存在某些进程的资源总是被抢占而造成“饥饿”</strong>。</li><li>破坏循环等待：采用资源有序分配策略，将系统中所有资源编号，并严格按照资源编号递增或递减的顺序申请资源。<strong>缺点是进程的资源使用顺序通常与资源编号顺序不一致，且添加新资源后不好编号，局限性太高</strong>。</li></ol><h2 id="3-死锁的避免"><a href="#3-死锁的避免" class="headerlink" title="3. 死锁的避免"></a>3. 死锁的避免</h2><p>与死锁预防相比，死锁避免是在不改变资源固有特性的前提下，对资源的分配策略施加较少的限制来避免死锁的发生。死锁避免的<strong>前提是每个进程清除自己需要多少资源</strong>，因此死锁避免还是有局限性的。</p><ol><li>系统的安全状态与不安全状态：在某一时刻，若能给出一个进程分配资源并执行的策略，该策略能指导所有的进程安全执行完，这称该时刻系统处于安全状态，否则不安全；</li><li>银行家算法：即动态的分配资源。系统在分配资源前先计算资源分配的安全性，保证至少有一个进程能够运行到结束，并在安全运行过程中回收已结束进程的资源，并将这些资源分配给其他进程，直到所有进程执行结束。</li></ol><h2 id="4-银行家算法"><a href="#4-银行家算法" class="headerlink" title="4. 银行家算法"></a>4. 银行家算法</h2><p>银行家算法有5种数据结构：</p><ol><li>系统可用资源向量Available：一个大小为m的数组，每个数组元素代表一类资源当前可用的数量，例如$Available[i]=k$代表第i类资源现有k个空闲；</li><li>最大需求矩阵Max。一个n*m矩阵，定义了所有的n个进程对m类资源的最大需求，M[i][j]=k代码第i个进程对第j类资源的总需求为k；</li><li>分配矩阵Allocation。n*m矩阵，表示n个进程当前已获得的m类资源的总数；</li><li>需求矩阵Need。n*m矩阵，表示当前n个进程还需要多少个m类资源；</li><li>请求向量Request。m大小的数组，每个元素代表正在运行的进程i此时请求某类资源总量，例如Request[j]=k表示进程i请求k个j类资源。</li></ol><p>当某个进程i对j类资源提出k个请求是，需要<strong>按照下列步骤检查</strong>：</p><ol><li>若$Request[j]&lt;=Need[i][j]$，转步骤2，否则因为进程i申请的资源已经超过它宣称的最大资源而认为出错；</li><li>若$Request[j]&lt;=Available[j]$，转步骤3，否则因为当前可供的j类资源不足而阻塞进程i；</li><li>系统进行试探性分配，并修改相应的表：<ul><li>Available[j] -= Request[j];</li><li>Allocation[i][j] += Request[j];</li><li>Need[i][j] -= Request[j];</li></ul></li><li>调用“判断当前状态是否安全”的子算法，若安全则按照步骤3的分配资源，否则拒绝i的资源申请请求。</li></ol><p><strong>判断当前状态是否安全</strong></p><p>添加两个数组：</p><ul><li>Work，m维数组，代表在检测过程中的某个时刻没类资源空闲的数量，初值等于Availa；</li><li>Finish，n维数组，Finish[i]代表进程i能否得到足够的资源而运行结束。其值为bool型，初值为false。</li></ul><p>检查当前状态的完整过程如下：</p><ol><li>初始化Work和Finish。Work[j]=Available[j], Finish[i]=false;</li><li>在进程集合中尝试寻找一个能满足以下条件的进程h，找到转步骤3，否则转步骤4:<ul><li>Finish[h] = false;</li><li>Need[h][j] &lt;= Work[j]</li></ul></li><li>由于步骤2中找到的h其全部资源均可得到满足，因此h获得资源后可顺利运行完毕，然后释放h所占有的资源，因此Work[j]+=Allocation[j][j], Finish[h]=true，回到步骤2</li><li>若对所有的进程i， Finish[i]均为true，则表示系统处于安全状态，否则不安全。</li></ol><h2 id="5-死锁检测"><a href="#5-死锁检测" class="headerlink" title="5. 死锁检测"></a>5. 死锁检测</h2><h2 id="6-死锁解除"><a href="#6-死锁解除" class="headerlink" title="6. 死锁解除"></a>6. 死锁解除</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deadlock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络的分类</title>
      <link href="/2015/03/15/computer_science/Computer_Network/classify_in_network/"/>
      <url>/2015/03/15/computer_science/Computer_Network/classify_in_network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络分类</p><hr><a id="more"></a><h2 id="1-按覆盖范围分"><a href="#1-按覆盖范围分" class="headerlink" title="1. 按覆盖范围分"></a>1. 按覆盖范围分</h2><ol><li>局域网LAN：LAN是将一个较小的区域内的各种通信设备连接在一起组成的网络，最常见、最常应用的网络。LAN具有以下特点：<ul><li>私有服务：LAN用于私用，例如校园网和企业网</li><li>分布范围小</li><li>结构简单、布线容易</li><li>网速较快，误码率低</li></ul></li><li>城域网MAN：通常用于为一个城市范围提供服务</li><li>广域网WAN：分布范围最大，可以遍布一个国家甚至全球，特点有：<ul><li>覆盖范围广</li><li>构建成本高</li><li>网络结构和类型复杂：可以连接多种不同的网络类型</li><li>传输速率低，误码率高</li></ul></li></ol><h2 id="2-按网络管理模式分"><a href="#2-按网络管理模式分" class="headerlink" title="2. 按网络管理模式分"></a>2. 按网络管理模式分</h2><ol><li>对等网：即网络中的各成员地位相等。这种网络配置简单，适合家庭、校园和小型办公室用户，但其缺点也很明显，例如<strong>管理困难</strong>、<strong>安全性差</strong>、<strong>成本高</strong>、<strong>性能差</strong>等；</li><li>C/S网：客户/服务器网，其特点是<strong>易于管理</strong>、<strong>安全性高</strong>、<strong>性能好</strong>。</li></ol><h2 id="3-按传输方式分"><a href="#3-按传输方式分" class="headerlink" title="3. 按传输方式分"></a>3. 按传输方式分</h2><ol><li>点对点传输网络：该网络中数据是以点对点的方式传输的，因此这类网络采用基于点对点的通信协议，如点对点协议PPP、基于以太网的点对点协议PPPOE等。</li><li>广播式传输网络：该网络中任一节点都可以通过公用信道传输数据到其他节点上，其他节点通过匹配数据地址来判断是否接收。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程与协程之间的区别与联系</title>
      <link href="/2015/03/12/computer_science/Operating_System/process_and_thread_coroutines/"/>
      <url>/2015/03/12/computer_science/Operating_System/process_and_thread_coroutines/</url>
      
        <content type="html"><![CDATA[<p>进程、线程与协程之间的区别与联系</p><hr><a id="more"></a><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h2><p>进程是程序的动态执行。保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），<strong>进程是资源分配的最小单位</strong>。一块CPU在某一时刻只能运行一个进程，多进程是通过进程调度抢占CPU来实现的。</p><p><strong>进程间的通信方式</strong></p><p>无名管道(Pipe)、有名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存(Shared Memory)、套接字(Socket)。</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><p>线程也被称为轻量级进程(Lightweight Process，LWP)，是操作系统调度(CPU调度)执行的最小单位。</p><h3 id="2-1-线程与进程的区别与联系"><a href="#2-1-线程与进程的区别与联系" class="headerlink" title="2.1 线程与进程的区别与联系"></a>2.1 线程与进程的区别与联系</h3><p><strong>联系</strong></p><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li><li>处理机分给线程，即真正在处理机上运行的是线程；</li><li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li></ol><p><strong>区别</strong></p><ol><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属进程的资源。进程维护的是程序所包含的资源(静态资源)，如：地址空间、打开的文件句柄集、文件系统状态、信号处理handler等；线程所维护的运行相关的资源(动态资源)，如：运行栈、调度相关的控制信息、待处理的信号集等；</li><li>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致创建进程的系统开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li></ol><h2 id="3-协程"><a href="#3-协程" class="headerlink" title="3. 协程"></a>3. 协程</h2><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制(也就是在用户态执行)。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总有一个入口，一次返回，并且调用顺序是明确的。而协程的调用和子程序不同，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p><strong>协程的优点</strong></p><ol><li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li><li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间的通信方式</title>
      <link href="/2015/03/09/computer_science/Operating_System/communication_of_process/"/>
      <url>/2015/03/09/computer_science/Operating_System/communication_of_process/</url>
      
        <content type="html"><![CDATA[<p>同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，进程通信指进程间的信息交换。</p><hr><a id="more"></a><h2 id="1-进程通信的概念"><a href="#1-进程通信的概念" class="headerlink" title="1. 进程通信的概念"></a>1. 进程通信的概念</h2><p>进程的特征之一是其具有独立性，一个进程不能访问另一个进程的程序或者数据，以保证进程之间不会相互干扰，但这样也造成了进程间无法直接交换数据。</p><p>一般而言，进程通过两种方案来实现进程间的通信</p><ol><li>发送、接受双方通过磁盘等外设交换数据。这种通信方式需要I/O操作的支持。</li><li>利用内核运行在内核态的特点，通过对内核空间读写来交换数据。这种通信方式是在内存中完成的。</li></ol><p>根据进程通信交换信息量的大小，可以将进程通信分为两种：</p><ol><li>低级通信。进程之间一次只传输少量数据，速度快，效率低，通信过程对用户不透明。这类通信主要用于互斥与同步的工具，P、V原语是低级通信原语</li><li>高级通信。一次可以传输大量信息，效率高，对用户透明，编程简单。高级通信又分为三种：<ul><li>共享内存通信方式：利用共享内存通信；</li><li>消息传递通信方式：利用OS提供的消息系统通信；</li><li>共享文件通信方式：又被称为管道通信。</li></ul></li></ol><p>高级通信方式既适用于集中式操作系统，又适用于分布式操作系统。</p><h2 id="2-共享内存通信方式"><a href="#2-共享内存通信方式" class="headerlink" title="2. 共享内存通信方式"></a>2. 共享内存通信方式</h2><p>共享内存是指在内存中划出一块区域作为数据共享区，称为共享内存分区，<strong>通信双方将自己的虚拟地址空间映射到共享内存分区上</strong>。通信时通过对该分区读写实现通信。该方式是进程间最快捷、最有效的通信方式，Unix、Windows和OSX都采用了这种通信方式。</p><h2 id="3-消息缓冲-消息队列-通信方式"><a href="#3-消息缓冲-消息队列-通信方式" class="headerlink" title="3. 消息缓冲(消息队列)通信方式"></a>3. 消息缓冲(消息队列)通信方式</h2><p>消息缓冲属于<strong>直接通信</strong>方式，该方法中，发送进程直接发送原语到接收进程的消息队列，而接受进程使用接受原语从消息队列中取出信息，进程间以<strong>消息</strong>为单位进行信息交换。该方法与生产者-消费者问题类似。该方式与共享内存有点相似，该方法<strong>使用内存中的公用消息缓冲区来传递消息</strong>。</p><h2 id="4-信箱通信方式"><a href="#4-信箱通信方式" class="headerlink" title="4. 信箱通信方式"></a>4. 信箱通信方式</h2><p>该方式是<strong>间接通信</strong>方式，通信双方通过一种叫<strong>信箱</strong>的共享数据结构来进行交互。该方法和消息队列没什么区别，也是在内存中设置一种特殊的数据结构。</p><h2 id="5-管道通信方式"><a href="#5-管道通信方式" class="headerlink" title="5. 管道通信方式"></a>5. 管道通信方式</h2><p>所谓的<strong>管道就是一种共享通信文件</strong>，也称为pipe文件，专门用于进程间通信。管道有三个特点：</p><ol><li>管道专门用于特性</li><li>管道只能<strong>单向传送数据</strong></li><li>管道对用户透明</li></ol><p>管道分为两种：</p><ol><li>无名管道。无名管道是利用系统调用pipe建立起来的无路径名的无名文件，并且是一个临时文件，该文件物理上由文件系统的高速缓冲区构成，且很少启动外部设备。当进程不再需要无名管道时，系统关闭并回收与它相关联的索引节点。此外，通过文件系统看不到无名管道的存在。</li><li>有名管道。有名管道是一个有目录和索引的长期存在的真实文件，不能与文件系统中的任何文件重名，且在文件系统中能看到该有名管道。</li></ol><h2 id="6-信号量"><a href="#6-信号量" class="headerlink" title="6. 信号量"></a>6. 信号量</h2><h2 id="7-套接字"><a href="#7-套接字" class="headerlink" title="7. 套接字"></a>7. 套接字</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络中的数制与编码</title>
      <link href="/2015/03/08/computer_science/Computer_Basic/number_system_and_coding_in_network/"/>
      <url>/2015/03/08/computer_science/Computer_Basic/number_system_and_coding_in_network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络中的进制与编码</p><hr><a id="more"></a><h2 id="1-常见进制"><a href="#1-常见进制" class="headerlink" title="1. 常见进制"></a>1. 常见进制</h2><p>计算机是二进制的世界，及其只能识别01串，但是为了人类理解方便，还是制定了多种进制，例如:</p><ul><li><strong>十进制</strong>：十进制数的标志为D，例如(123)D</li><li><strong>二进制</strong>：二进制的标识为B，例如(101)B</li><li><strong>八进制</strong>：标识为字母O，在C/C++中八进制数前需要加数字0，如0123位八进制数</li><li><strong>十六进制</strong>：标识为H，C/C++中十六进制数以0x开头</li><li><strong>十二进制</strong>：时钟用到的进制</li><li><strong>六十进制</strong>：分钟与秒钟用到的进制</li></ul><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><ul><li><strong>非十进制转换成十进制</strong>：按位的幂的累加和，例如$(11010)<em>2 = 1<em>2^4 + 1</em>2^3 + 0<em>2^2 + 1</em>2^1 + 0*2^0 = (26)</em>{10}$</li><li><strong>十进制转换成非十进制</strong>：整数使用除基取余法，小数使用乘基正序取整法(即每次乘基后，取大于1的部分整数)</li><li><strong>非十进制与非十进制之间的转换</strong>：可以利用二进制作为中介</li></ul><h2 id="3-计算机中二进制数的表示"><a href="#3-计算机中二进制数的表示" class="headerlink" title="3. 计算机中二进制数的表示"></a>3. 计算机中二进制数的表示</h2><p>计算机中二进制采用的表示形式为补码。<br>计算机中的字长是指计算机一次可以处理的二进制数的长度。</p><ul><li>原码：最高位用于表示数的正负。这种表示的缺陷是<strong>对异号加减操作不便</strong>，与此同时<strong>0有+0和-0两种不同的表示</strong>，存在二义性。故计算机不采用这种表示形式</li><li>补码：正数补码与原码相同，负数的补码为原码除符号位外按位取反，再将末位加1得到。补码的优点是运算时可以将符号位一起运算，且0只有一种表示形式</li><li>反码：正数反码与源码相同，负数为除符号位外按位取反。反码是原码和补码的中间过渡形式。</li><li>移码：补码的符号位取反即是移码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的基本概念</title>
      <link href="/2015/03/07/computer_science/Operating_System/process/"/>
      <url>/2015/03/07/computer_science/Operating_System/process/</url>
      
        <content type="html"><![CDATA[<p>为了有效的管理CPU，OS引入进程的概念，即以进程为基本单位来实现CPU的分配与执行。</p><hr><a id="more"></a><h2 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1. 进程的概念"></a>1. 进程的概念</h2><h3 id="1-1-程序的顺序执行"><a href="#1-1-程序的顺序执行" class="headerlink" title="1.1 程序的顺序执行"></a>1.1 程序的顺序执行</h3><p>在计算机中常使用程序这个概念，<strong>程序是一个在时间上严格按先后次序操作实现算法功能的指令序列</strong>，程序本身是静态的，是指令编译出的结果。在单道程序设计环境中，程序总是顺序执行的，若有多个程序，则各个程序试一次呗调入内存的。程序的顺行执行有以下三个特点：</p><ol><li>顺序性。CPU严格按照程序规定的顺序(即指令顺序)执行程序的操作，每个操作都必须在前一个操作结束后才能执行；</li><li>封闭性。程序一旦开始执行，其结果仅由初始条件和程序本身操作决定，不受外界因素影响；</li><li>可再现性。当初始条件相同，程序的运行结果也相同。</li></ol><p>单道程序的顺序性、封闭性和可再现性给程序的编制、调试带来了便利，但是资源利用率底。</p><h3 id="1-2-程序的并发执行"><a href="#1-2-程序的并发执行" class="headerlink" title="1.2 程序的并发执行"></a>1.2 程序的并发执行</h3><h3 id="1-3-进程"><a href="#1-3-进程" class="headerlink" title="1.3 进程"></a>1.3 进程</h3><h4 id="1-3-1-进程的定义"><a href="#1-3-1-进程的定义" class="headerlink" title="1.3.1. 进程的定义"></a>1.3.1. 进程的定义</h4><p>单道程序环境下，程序与CPU执行的活动是一致的。多道环境下，并发破坏了程序的封闭性和可再现性，程序与CPU执行的活动不再一一对应。<strong>程序是完成某一特定功能的指令序列，是一个静态过程</strong>，而CPU执行的活动是一个动态的过程。因此20世纪60年代Dijkstra引入了进程的概念。他给出的进程定义是：<strong>行为的规则称为程序，程序在CPU上执行时的活动称为进程</strong>。</p><h4 id="1-3-2-进程的结构"><a href="#1-3-2-进程的结构" class="headerlink" title="1.3.2. 进程的结构"></a>1.3.2. 进程的结构</h4><p>通常程序是不能并发执行的，<strong>为了使程序及它所要使用的资源能独立运行，OS为程序配置了一个特殊的数据结构进程控制块PCB(Process Control Block)</strong>，PCB用来存储程序向前执行过程中所要记录的有关运行信息，即该进程动态之行的相关资料。因此：</p><center>进程实体 = 程序段 + 相关数据段 + PCB</center><h4 id="1-3-3-进程的特征"><a href="#1-3-3-进程的特征" class="headerlink" title="1.3.3. 进程的特征"></a>1.3.3. 进程的特征</h4><p>进程作为OS的一个实体有以下5个特征。</p><ol><li>动态性。进程是程序的一次执行，因此进程是动态的，具有生命期。</li><li>并发性。多个进程实体在一段时间内能够并发执行，从而提高系统资源利用率。</li><li>独立性。每个进程都是一个独立运行的基本单位，也是系统进行资源分配和调度的基本单位。</li><li>异步性。各进程按各自独立的、不可预知的速度向前推进。对单CPU系统而言，任何时刻只能有一个进程占用CPU。</li><li>结构性。每个进程的结构都由程序段、数据段和PCB组成。</li></ol><h4 id="1-3-4-进程和程序的区别"><a href="#1-3-4-进程和程序的区别" class="headerlink" title="1.3.4. 进程和程序的区别"></a>1.3.4. 进程和程序的区别</h4><ol><li>程序是指令的有序集合，是静态的；Process是程序在CPU上的一次执行，是动态的；</li><li>程序作为软件可以长期保存；Process有自己的生命周期；</li><li>程序不会占有和调度资源；Process会为其分配和调度资源；</li><li>进程与程序之间无一一对应关系，一个程序可以多次执行产生多个进程，不同进程也可以包含同一个程序；</li><li>程序是记录在存储介质上的指令有序集合；进程则由程序段、数据段、PCB组成。</li></ol><h2 id="2-进程的状态及转换"><a href="#2-进程的状态及转换" class="headerlink" title="2. 进程的状态及转换"></a>2. 进程的状态及转换</h2><h3 id="2-1-5状态进程模型"><a href="#2-1-5状态进程模型" class="headerlink" title="2.1. 5状态进程模型"></a>2.1. 5状态进程模型</h3><p>进程有5个状态：创建、就绪、运行、阻塞、终止，下面对其一一说明。</p><ol><li>进程的创建。通常有4件事会导致新进程的产生：<ul><li>在一个批处理环境中，为了响应一个任务的要求而产生进程；</li><li>在一个交互式环境中，当一个新用户企图登录时会产生进程；</li><li>操作系统代替用户程序产生进程；</li><li>由用户程序产生进程。通常进程都是由操作系统产生的，但是一个进程也可以产生另一个进程，分别称为父进程和子进程。</li></ul></li><li>进程的终止。当一个进程执行到自然结束点，或因不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程进入终止态。处于终止态的进程不能被再次调度执行，与其相关的数据信息由OS临时保存，随后OS逐步释放为其分配的资源，最后释放PCB。</li><li>进程的就绪。进程获得了除CPU之外的所需资源，一旦得到CPU就可运行。就绪状态的进程会组成就绪队列。</li><li>进程的运行。进程获得了CPU和其他资源，正在CPU上运行时的状态。</li><li>进程的阻塞。进程运行中发生了某种等待事件(如I/O操作)而暂时不能运行的状态，此状态的进程不能竞争CPU，而需要等事件完成后转到就绪态才能竞争。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction To Computer</title>
      <link href="/2014/02/23/computer_science/Computer_Basic/introduction/"/>
      <url>/2014/02/23/computer_science/Computer_Basic/introduction/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/30823911/" target="_blank" rel="noopener">《计算机组装与维修技术》</a>阅读笔记</p><a id="more"></a><hr><h2 id="1-计算机及其组成"><a href="#1-计算机及其组成" class="headerlink" title="1.计算机及其组成"></a>1.计算机及其组成</h2><h3 id="什么是计算机"><a href="#什么是计算机" class="headerlink" title="什么是计算机"></a>什么是计算机</h3><p>计算机全称电子计算机，俗称电脑、PC等，是一种用于计算的机器，其种类繁多，包括个人计算机、高性能计算机、服务器等。</p><h3 id="计算机的组成"><a href="#计算机的组成" class="headerlink" title="计算机的组成"></a>计算机的组成</h3><p>一个完整的可正常工作的计算机包括硬件和软件两个部分：</p><h4 id="1-计算机硬件"><a href="#1-计算机硬件" class="headerlink" title="1. 计算机硬件"></a>1. 计算机硬件</h4><p>硬件是指组成计算机的实体部件，从外观上来看硬件包括：主机、显示器、键盘、鼠标、音响、打印机、扫描仪等，其中主机使整个计算机最重要的组件，一般的，主机都包括:</p><ul><li>CPU：Central Processing Uint，计算机核心的核心，目前CPU的生产厂商有Intel和AMD两家公司，市场占比大约82开</li><li>主板：承担着操控和协调CPU、声卡、显卡等部件的任务</li><li>显卡</li><li>风扇</li><li>电源</li><li>网卡</li><li>声卡</li></ul><h4 id="2-计算机软件"><a href="#2-计算机软件" class="headerlink" title="2. 计算机软件"></a>2. 计算机软件</h4><p>软件是指在硬件上运行的各种程序，例如聊天软件、游戏软件，其中操作系统也是软件的一种，例如Unbuntu、Windows等</p><hr><h2 id="2-CPU"><a href="#2-CPU" class="headerlink" title="2. CPU"></a>2. CPU</h2><p>CPU作为计算机的核心，其性能指标包括以下几种：</p><ol><li><strong>主频</strong>：即CPU的时钟频率，单位为MHz或GHz，标示CPU的运算速度，CPU的主频=外频x倍频</li><li><strong>外频</strong>：CPU的总线频率，是由主板为CPU提供的基准时钟频率，单位为MHz，外频决定了主板的运行速度。通常我们在台机中所说的超频，就是指超CPU的外频，大部分CPU外频和主板频率是同步运行的，如果改变外频可能会导致系统不稳定</li><li><strong>倍频</strong>：CPU主频和外频之间的倍率，一般情况下CPU的倍频是锁定的，有的CPU可以调节倍频</li><li><strong>前端总线频率</strong>：也称FSB带宽，是CPU与内存间的数据交换的速率，一般数据带宽=(总线频率x数据位宽)/8</li><li><strong>缓存</strong>：由于CPU和内存处理数据速度不一致，因而引入了缓存，一般而言CPU中有2～3级缓存，L1 Cache是一级缓存，由SRAM组成</li></ol><hr><h2 id="3-主板"><a href="#3-主板" class="headerlink" title="3. 主板"></a>3. 主板</h2><p>主板是一块印刷电路板PCB，一般采用4或6层板，4层板包括主板信号层、接地层、电源层、次信号层，6层板多了辅助电源层和中信号层，6层的抗电磁干扰能力更强。<br>一般主板有如下几个组件：</p><ol><li><strong>芯片组</strong>：芯片组主要由BIOS芯片、南北桥芯片、磁盘阵列RAID、控制芯片等组成<ul><li><strong>BIOS芯片</strong>：BIOS芯片是一块方块型的存储器，里面存有与该主板搭配的基本输入输出系统程序，改程序能够让主板识别各种硬件，以及设置引导系统、调整CPU外频等，BIOS芯片是可写入的。</li><li><strong>南北桥</strong>：横跨AGP插槽左右两侧的两块芯片就是南北桥芯片。南桥芯片多位于PCI插槽的上方；而CPU插槽旁边，被散热片盖住的则是北桥芯片，一般而言主板的命名都是以北桥的核心名称命名的。北桥芯片主要负责处理CPU、内存、显卡三者之间的交互；南桥负责硬盘等存储设备和PCI之间的数据流通。南北桥合称芯片组。现代的一些高端主机会将南北桥芯片封装到一起。</li><li><strong>RAID</strong>：控制芯片</li></ul></li><li>总线：总线是主板的重要组成部分，各个部件通过插槽连接到总线上，通常包括：CPU插槽、内存插槽、AGP插槽(用于插AGP显卡，目前逐渐被PCI Express插槽取缔)、PCI插槽(插声卡、网卡等)、CNR插槽(插CNR接口的软Modem或网卡)</li><li>对外接口：硬盘接口(一般都是SATA接口)、软驱接口、COM接口(连接串行鼠标和外置Modem等)、PS/2接口(仅用于连接键鼠，目前逐渐被USB接口取代)、USB接口、LPT接口(连接打印机或扫描仪)、MIDI接口(声卡和游戏杆，目前逐渐淘汰)。</li></ol><hr><h2 id="4-内存"><a href="#4-内存" class="headerlink" title="4. 内存"></a>4. 内存</h2><p>内存是有内存芯片、电路板、金手指(即内存条边缘的一排金黄色导电触片)等组成，当计算机运行时，CPU就会把运行所需的数据从硬盘中调到内存中，运算完成后再传出，目前市面上流行的内存类型为DDR3和DDR4，DDR即双倍速率同步动态随机存储器Double Data Rate Synchronous Dynamic Random Access Memory的简称，DDR在每个时钟的上升沿和下降沿各传输一次数据</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>内存主频</strong>：内存的运行速度</li><li>内存容量</li><li>CAS延迟：内存读写数据所需的时延</li></ul><hr><h2 id="5-显卡"><a href="#5-显卡" class="headerlink" title="5. 显卡"></a>5. 显卡</h2><p>显卡即显示接口卡、显示适配器、显示器配置卡，承担输出图形显示的重要任务。由于显卡的特性，它特别适合处理矩阵运算，因此显卡在现代机器学习中扮演了重要的角色。在机器学习中通常会有大量的矩阵操作，所以可以将这部分操作送给显卡中的GPU去操作。显卡一般分为两种</p><ul><li><strong>集成显卡</strong>：即芯片组中集成了显卡，这样的芯片组也称为整合型芯片，集显一般没有显存，而是使用内存作为其显存，因此其性能和独显相比较差</li><li><strong>独立显卡</strong>：显卡成独立的板卡，通常有自己的显存</li></ul><p>显卡的基本结构如下：</p><ul><li><strong>GPU</strong>:图形处理芯片</li><li><strong>显存</strong></li><li><strong>显卡BIOS</strong>:驱动程序之间的控制程序,存有显卡的型号、规格、生产厂家及出场时间等</li><li>输出接口</li><li>显卡PCB板</li></ul><h3 id="性能指标-1"><a href="#性能指标-1" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>显卡频率</strong>：显卡的工作频率，通常越高越好</li><li><strong>显存位宽</strong>：一个时钟周期内所能传送数据的位数，市场上主流的有128位、256位、320位等</li><li>显存在显卡上工作时的频率</li><li>显存容量：主流的是256MB和512MB</li><li>3D API：显卡与应用程序之间的接口</li></ul><hr><h2 id="6-声卡"><a href="#6-声卡" class="headerlink" title="6. 声卡"></a>6. 声卡</h2><p>声卡是实现模拟信号/数字信号相互转换的一种硬件，一般分为板卡式(目前已被淘汰)、集成式(主流)和外置式三种，声卡的基本构成有：</p><ul><li><strong>声音控制芯片</strong>：可通过数模转换器将模拟信号转换成数字信号，或反过来</li><li><strong>DSP</strong>：执行和声音处理有关的命令、执行压缩解压缩程序、增加特殊声效和传真Modem等，高档声卡一般配有DSP</li><li><strong>CODEC</strong>：编解码器</li><li>输入输出接口</li><li>跳线：用于设置声卡的硬件设备，包括CD-ROM的I/O地址、声卡的I/O地址设置。</li></ul><h3 id="性能指标-2"><a href="#性能指标-2" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>采样频率</strong>：每秒从连续信号中采样出离散信号的个数，单位Hz。通俗地讲是指计算机美妙采集多少个声音样本</li><li><strong>采样位数</strong>：即采样值或取样值，用来衡量声音波动变化的参数，含义是声卡在采集和播放声音文件时所使用数字声音信号的二进制位数</li><li><strong>信噪比SNR</strong>：放大器的输出信号的电压与同时输出的噪声电压的比例，单位分贝，一般信噪比越高，说明信号李的噪声越小，声音质量越高</li><li>频率响应：系统或计量传感器的阻抗随频率的变化</li></ul><hr><h2 id="7-硬盘"><a href="#7-硬盘" class="headerlink" title="7. 硬盘"></a>7. 硬盘</h2><p>硬盘是计算机中的存储器件，一般的机械硬盘由一个或多个铝制或玻璃制的碟片组成，碟片外覆盖有铁磁性材料。传统的机械硬盘其内部构造包括：</p><ul><li>磁头：负责对磁盘进行读写，与磁盘表面的磁性物质发生作用，一般有MR磁头和GMR磁头，硬盘里的磁头数=磁盘盘体数x2</li><li>盘体：存储数据的主体，有一或多个盘片叠在一起组成，盘体有以下几个概念：<ul><li><strong>磁道</strong>：一个盘片的一个面上的一个同心圆成为一个磁道，一般内侧磁道和外侧磁道存储量不同</li><li><strong>扇区</strong>：每个磁道都被分为若干个弧段，这些弧段就是扇区，每个扇区可以存放512字节的信息，磁盘读写数据以扇区为单位</li><li><strong>柱面</strong>：每个盘面上相同位置的磁道组成一个柱面，<strong>硬盘容量=柱面数x磁头数x扇区数x512B</strong></li></ul></li><li>主轴电机：用于驱动盘体转动的设备，主流的为7200转/分钟</li><li>寻道电机、驱动臂：寻道电机带动磁头在盘体上寻道，驱动臂把磁头和寻道电机连接在一起</li></ul><h3 id="性能指标-3"><a href="#性能指标-3" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>容量</li><li><strong>转速</strong>：单位为转/分钟或RPM，转的越快，其传输率越高，发热量越大</li><li><strong>平均访问时间</strong>：磁头从起始位置找到需要读写的数据位置的时间，体现了硬盘的读写速度。一般包括了平均寻道时间和平均等待时间，平均寻道时间是指磁头移动到指定磁道所需的时间，平均等待时间磁头已经在目标磁道，等待所需访问的扇区转至磁头下方所需时间</li><li><strong>传输速率</strong>：包括内部传输速率和外部传输速率，内部传输速率指未用硬盘缓冲区时的性能，外部传输速率是系统总线与硬盘缓冲区之间的传输速率</li><li><strong>缓存</strong>：硬盘也有缓存，是硬盘控制器上的一块内存芯片</li></ul><p>固态硬盘SSD是一种新型的硬盘，由固态电子存储芯片阵列组成，其存储介质一般有闪存(FLASH)和DRAM两种，和传统硬盘比，SSD有读写速度快、低功耗、无噪声、体积小等优点，也有造价高、使用寿命短的缺点。关于SSD的使用寿命，也就是SSD擦写次数限制，闪存完全擦写一次叫做一次P/E，因此闪存的寿命以P/E为单位，一般34nm的闪存寿命为5000P/E，25nm的为3000P/E。不过由于SSD固件算法升级，SSD能提供更少的不必要写入量。 举个例子，一款128G的SSD，要写入128G的文件才算做一次P/E，即使每天写入50G的内容，2.5天才能完成一次P/E，一年也才用去150次左右的P/E，一块3000P/E的SSD够用200年了。</p><hr><h2 id="8-BIOS和CMOS"><a href="#8-BIOS和CMOS" class="headerlink" title="8. BIOS和CMOS"></a>8. BIOS和CMOS</h2><p>BIOS是基本输入输出系统。启动计算机时，CPU首先根据集成在主板、显卡等设备上的BIOS芯片来核对每个基础设备是否正常，然后从硬盘中拷贝操作系统到内存中。BIOS有3个基本功能：</p><ul><li>自检及初始化：开机后BIOS最先被启动，然后BIOS会检查计算机硬件设备，若设备正常才会启动操作系统</li><li>程序服务：BIOS直接与计算机的I/O设备交互，实现软件程序对硬件的直接操作</li><li>设定中断</li></ul><p>CMOS是指互补金属氧化物半导体，是计算机主板上的一块可读写的RAM芯片，用来保存当前系统的硬件配置和用户对某些参数的设定。CMOS由主板的可充电电池供电，即使系统断电CMOS中的信息也不会丢失。 通常计算机中的开机密码存储在CMOS中，当忘记密码时，可以抠下主板上的电池，将CMOS放电，放电后CMOS内容会被清空，因而密码也会被清除。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
          <category> Computer Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Basic </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
